<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IOC与AOP的使用小结</title>
    <url>/2020/07/10/IOC%E4%B8%8EAOP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、bean的几种创建方式-IOC"><a href="#一、bean的几种创建方式-IOC" class="headerlink" title="一、bean的几种创建方式(IOC)"></a>一、bean的几种创建方式(IOC)</h1><h2 id="1-使用构造函数创建bean"><a href="#1-使用构造函数创建bean" class="headerlink" title="1. 使用构造函数创建bean"></a>1. 使用构造函数创建bean</h2><h3 id="1-1-使用默认构造函数创建bean"><a href="#1-1-使用默认构造函数创建bean" class="headerlink" title="1.1 使用默认构造函数创建bean"></a>1.1 使用默认构造函数创建bean</h3><p>即<code>&lt;bean id=.. class=.. /&gt;</code>, 则默认调用无参构造函数来创建bean，并装入容器中. <strong>此时如果类中没有默认构造函数，那么对象将无法被创建</strong></p>
<h3 id="1-2-使用有参构造函数创建bean"><a href="#1-2-使用有参构造函数创建bean" class="headerlink" title="1.2 使用有参构造函数创建bean"></a>1.2 使用有参构造函数创建bean</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">".."</span> <span class="attr">class</span>=<span class="string">".."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"变量名"</span> <span class="attr">value</span>=<span class="string">"变量值"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"变量名"</span> <span class="attr">ref</span>=<span class="string">"其他bean的id"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="2-使用工厂方法创建bean"><a href="#2-使用工厂方法创建bean" class="headerlink" title="2. 使用工厂方法创建bean"></a>2. 使用工厂方法创建bean</h2><h3 id="2-1-使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）"><a href="#2-1-使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）" class="headerlink" title="2.1 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）"></a>2.1 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</h3><p>例如: 我想通过类<code>GameFactory</code>中的<code>getGame()</code>方法来创建一个<code>Game对象</code></p>
<p>那么在配置文件中:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--先配置GameFactory类的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"GF"</span> <span class="attr">class</span>=<span class="string">"cn.xjtu.czf.factory.GameFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后配置Game类的信息, 但创建对象的来源不再是Game类的全限定名, 而是创建Game对象的类以及对应方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MyGame"</span> <span class="attr">factory-bean</span>=<span class="string">"GF"</span> <span class="attr">factory-method</span>=<span class="string">"getGame"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以通过”MyGame”这个关键字来获取Game的对象了。</p>
<h3 id="2-2-使用静态工厂方法里的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）"><a href="#2-2-使用静态工厂方法里的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）" class="headerlink" title="2.2 使用静态工厂方法里的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）"></a>2.2 使用静态工厂方法里的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）</h3><p>依然用<code>StaticGameFactory</code>的例子来说明，只不过<code>getGame()</code>方法变为静态方法，那么就应该像如下这样弄.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MyGame"</span> <span class="attr">factory-bean</span>=<span class="string">"cn.xjtu.czf.factory.StaticGameFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getGame"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-使用setter方法来创建bean"><a href="#3-使用setter方法来创建bean" class="headerlink" title="3. 使用setter方法来创建bean"></a>3. 使用setter方法来创建bean</h2><bean id="..." class="...">
    <property name="name" value="czf"></property>
    <property name="age" value="22"></property>
    <property name="date" ref="now"></property>
</bean>
注意，集合类型只能通过setter来进行初始化内容(比如想创建一个存入元素0的ArrayList，那么只能用这个方法，具体规则用到再查吧.. 这里不记了)..

<h2 id="4-使用注解来创建bean"><a href="#4-使用注解来创建bean" class="headerlink" title="4. 使用注解来创建bean"></a>4. 使用注解来创建bean</h2><h3 id="1-标记了-Controller-Service-Repository-和-Component的类-用于创建bean"><a href="#1-标记了-Controller-Service-Repository-和-Component的类-用于创建bean" class="headerlink" title="1. 标记了@Controller, @Service, @Repository 和@Component的类, 用于创建bean"></a>1. 标记了<code>@Controller</code>, <code>@Service</code>, <code>@Repository</code> 和<code>@Component</code>的类, 用于创建bean</h3><ul>
<li><code>@Controller</code>： 表现层</li>
<li><code>@Service</code>： 业务层</li>
<li><code>@Repository</code>：持久层<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 等价于 &lt;bean id="aaa" class="包.AAA" /&gt; */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"aaa"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AAA</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-使用配置类-Configuration-Bean来创建"><a href="#2-使用配置类-Configuration-Bean来创建" class="headerlink" title="2. 使用配置类@Configuration+@Bean来创建"></a>2. 使用配置类@Configuration+@Bean来创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"czf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"accountService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAccountService <span class="title">getAccountService</span><span class="params">( Account account )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IAccountServiceImpl(account);  <span class="comment">// 形参的account可以是容器里的id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"account"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Account();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@Configuration</code></p>
<ul>
<li>作用：指定当前类是一个配置类</li>
<li>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。例如 <code>AnnotationConfigApplicationContext(配置类名.class)</code></li>
</ul>
</li>
<li><p><code>@Bean</code></p>
<ul>
<li>作用：用于把当前方法的<strong>返回值</strong>作为<strong>bean对象</strong>存入spring的ioc容器中</li>
<li>属性:<ul>
<li>name:用于指定bean的id。当不写时，默认值是当前方法的名称</li>
</ul>
</li>
<li>细节：<ul>
<li>当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象(bean的id就是形参的名字)。查找的方式和Autowired注解的作用是一样的</li>
</ul>
</li>
<li>其中的<code>initMethod</code>和<code>destroyMethod</code>可以分别指派初始化和销毁方法.（但在多实例的时候，销毁方法不由spring管理，由GC管理..）</li>
</ul>
</li>
<li><p>配置类的导入:</p>
<ul>
<li>平级结构:<br>  使用<code>AnnotationConfigApplicationContext(配置类1.class，配置类2.class，配置类3.class，...)</code></li>
<li>树型结构:<br>  使用<code>AnnotationConfigApplicationContext(根配置类.class)</code>，然后对于根配置类 使用：            <ul>
<li><code>@ContextConfiguration(classes = {配置子类.class})</code> 或者 <code>@ContextConfiguration(locations = {&quot;classpath:包名/aaa.xml&quot;, &quot;classpath*:bbb.xml&quot;})</code></li>
<li><code>@Import({配置子类1.class, 配置子类2.class，...})</code></li>
</ul>
</li>
</ul>
</li>
<li><p>在配置类中使用<code>properties文件</code>来初始化配置类中的成员变量(成员变量可以作为初始化bean的变量，从而降耦)</p>
<ul>
<li><code>@PropertySource</code>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"Config.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;money&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Float money = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"account"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Account(name, age, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中，<code>Config.properties</code>的内容为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;czf</span><br><span class="line">age&#x3D;22</span><br><span class="line">money&#x3D;1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注入数据的注解</p>
<ul>
<li><code>@Autowired</code> : spring会自动到容器中去寻找当前<code>@Autowired</code>标注的类型，根据类型来初始化。 但是要注意的是，这里多态也会起作用，如果有多个类实现了同一个接口，而当前变量或对象类型正好是接口类型，那么就会找到多个匹配成功的对象； 然后就会根据变量名去匹配，如果依然匹配不到的话，就会报错； 但我们一般不会把变量名写的和类名一样，因此解决办法就是使用<code>@Qualifier</code></li>
<li><code>@Qualifier</code> 在给类的成员变量注入的时候，是不可以单独使用的，必须和<code>@Autowired</code>在一起使用； 但是在给方法参数注入的时候，是可以单独使用的； 使用方法就是：<code>@Qualifier(value=&quot;具体某个类的别名&quot;)</code>, 用输入的类名来填充当前需要填充的变量；</li>
<li><code>@Resource</code> 相当于上面两个的合体， 可以直接单独使用，直接通过 类的别名 来确定给当前变量填充的类型，但要注意，这里接收类的别名的参数是<code>name</code>不再是<code>value</code>； <code>@Resource(name=&quot;某个类的别名&quot;)</code></li>
<li>基本类型和String类型的注入(<code>@Value(value=&quot;数据的值&quot;)</code>)<ul>
<li>可以使用Spring中的el表达式；</li>
<li>SlEL的写法：${表达式} (配合<code>@PropertySource</code>使用)</li>
</ul>
</li>
<li>集合类型的注入，只能通过xml来做。</li>
</ul>
</li>
<li><p>Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]</p>
<ul>
<li>@Resource:<ul>
<li>可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的；没有能支持@Primary功能没有支持@Autowired（reqiured=false）;</li>
</ul>
</li>
<li>@Inject:<ul>
<li>需要导入javax.inject的包，和Autowired的功能一样。没有required=false的功能；</li>
</ul>
</li>
<li>@Autowired:Spring定义的； @Resource、@Inject都是java规范</li>
</ul>
</li>
</ul>
<h2 id="5-使用Conditional注解"><a href="#5-使用Conditional注解" class="headerlink" title="5. 使用Conditional注解"></a>5. 使用<code>Conditional</code>注解</h2><p><code>Conditional</code>：按照一定的条件进行判断，满足条件则给容器注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// cmp是一个继承了Condition接口并实现了match方法的类</span></span><br><span class="line">    <span class="comment">// 对于这个match方法，如果返回了true，那么就注入，如果是false就不注入</span></span><br><span class="line">    <span class="comment">// 以此来对注入加上一个或多个条件限制</span></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;cmp<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">class</span> <span class="title">person01</span></span>&#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="6-通过BeanFactory来注册Bean"><a href="#6-通过BeanFactory来注册Bean" class="headerlink" title="6. 通过BeanFactory来注册Bean"></a>6. 通过BeanFactory来注册Bean</h2><ul>
<li>使用Spring提供的 FactoryBean（工厂Bean）;<ol>
<li>默认获取到的是工厂bean调用getObject创建的对象</li>
<li>要获取工厂Bean本身，我们需要给id前面加一个&amp;，&amp;colorFactoryBean</li>
</ol>
</li>
</ul>
<p>下面看个示例, 使用实现了FactoryBean接口的ColorFactoryBean类来注册Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 返回的对象会自动添加到容器中</span></span><br><span class="line">		System.out.println(<span class="string">"ColorFactoryBean...getObject..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//是单例？</span></span><br><span class="line">	<span class="comment">//true：这个bean是单实例，在容器中保存一份</span></span><br><span class="line">	<span class="comment">//false：多实例，每次获取都会创建一个新的bean；</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@...</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</span><br><span class="line">    <span class="comment">// 尽管这里注册的Bean是个工厂，但！实际上注册的对象是“工厂+工厂里的getBean”</span></span><br><span class="line">    <span class="comment">// 1. 默认获取到的是工厂bean调用getObject创建的对象</span></span><br><span class="line">    <span class="comment">// 2. 要获取工厂Bean本身，我们需要给id前面加一个&amp;，&amp;colorFactoryBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-想在自定义Bean中获取Spring框架底层的Bean-例如-ApplicationContext"><a href="#7-想在自定义Bean中获取Spring框架底层的Bean-例如-ApplicationContext" class="headerlink" title="7. 想在自定义Bean中获取Spring框架底层的Bean(例如 ApplicationContext)"></a>7. 想在自定义Bean中获取Spring框架底层的Bean(例如 ApplicationContext)</h2><ul>
<li>自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx）；</li>
<li>自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；Aware；</li>
<li>把Spring底层一些组件注入到自定义的Bean中；</li>
<li>xxxAware：功能使用xxxProcessor（继承了）；<ul>
<li>ApplicationContextAware==》ApplicationContextAwareProcessor；</li>
</ul>
</li>
</ul>
<h1 id="三、Bean的初始化和销毁方法"><a href="#三、Bean的初始化和销毁方法" class="headerlink" title="三、Bean的初始化和销毁方法"></a>三、Bean的初始化和销毁方法</h1><h2 id="1-使用Bean-initMethod-”-”-destoryMethod-”-”"><a href="#1-使用Bean-initMethod-”-”-destoryMethod-”-”" class="headerlink" title="1. 使用Bean(initMethod=”..”, destoryMethod=”..”)"></a>1. 使用Bean(initMethod=”..”, destoryMethod=”..”)</h2><h2 id="2-让Bean实现InitializingBean接口和DisposableBean接口"><a href="#2-让Bean实现InitializingBean接口和DisposableBean接口" class="headerlink" title="2. 让Bean实现InitializingBean接口和DisposableBean接口"></a>2. 让Bean实现InitializingBean接口和DisposableBean接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Excetpion</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用JSR250"><a href="#3-使用JSR250" class="headerlink" title="3. 使用JSR250"></a>3. 使用JSR250</h2><h3 id="PostConstruct-PreDestory"><a href="#PostConstruct-PreDestory" class="headerlink" title="@PostConstruct,@PreDestory"></a><code>@PostConstruct</code>,<code>@PreDestory</code></h3><ul>
<li><code>@PostConstruct</code>在bean创建完成并且属性赋值完成；来执行初始化方法</li>
<li><code>@PreDestory</code>在容器销毁bean之前通知我们进行清理工作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对象创建并赋值之后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 容器移除对象之前执行这个方法</span></span><br><span class="line">    <span class="meta">@PreDestory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-在Bean的初始化方法调用前-后的预置方法"><a href="#4-在Bean的初始化方法调用前-后的预置方法" class="headerlink" title="4. 在Bean的初始化方法调用前/后的预置方法"></a>4. 在Bean的初始化方法调用前/后的预置方法</h2><p>BeanPostProcessor接口有2个方法需要去实现：</p>
<ol>
<li><code>postProcessBeforeInitialization</code>:在bean初始化之前执行</li>
<li><code>postProcessAfterInitialization</code>:在初始化之后执行<br>对于Bean而言，实现了上面这两个接口，就可以在Bean初始化之前和之后做一些事情.</li>
</ol>
<h1 id="二、扫描包"><a href="#二、扫描包" class="headerlink" title="二、扫描包"></a>二、扫描包</h1><p>扫描包内注解.</p>
<h2 id="1-xml方式扫描"><a href="#1-xml方式扫描" class="headerlink" title="1. xml方式扫描"></a>1. xml方式扫描</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"包"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-注解方式扫描"><a href="#2-注解方式扫描" class="headerlink" title="2. 注解方式扫描"></a>2. 注解方式扫描</h2><h3 id="使用注解类"><a href="#使用注解类" class="headerlink" title="使用注解类"></a>使用注解类</h3><ul>
<li><code>@ComponentScan</code><br>用于通过注解指定spring在创建容器时要扫描的包.我们使用此注解就等同于在xml中配置了:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"czf"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>@Filter</code>通过<code>excludeFilter</code>和<code>includeFilter</code>可以实现在扫描的时候扫描部分或排除部分类.</p>
<h1 id="三、面向切面编程（AOP）"><a href="#三、面向切面编程（AOP）" class="headerlink" title="三、面向切面编程（AOP）"></a>三、面向切面编程（AOP）</h1><h2 id="0-注意"><a href="#0-注意" class="headerlink" title="0. 注意!"></a>0. 注意!</h2><p>使用AOP时，一定要导入aspectj！！！解析切入点表达式需要<code>AspectJ Weaver</code>, 使用环绕通知的ProceedingJoinPoint对象需要<code>AspectJ Runtime</code>!! 不要忘记了！！</p>
<h2 id="1-spring中基于XML的AOP配置步骤"><a href="#1-spring中基于XML的AOP配置步骤" class="headerlink" title="1. spring中基于XML的AOP配置步骤"></a>1. spring中基于XML的AOP配置步骤</h2><ol>
<li><p>把通知Bean也交给spring来管理</p>
</li>
<li><p>使用aop:config标签表明开始AOP的配置</p>
</li>
<li><p>使用aop:aspect标签表明配置切面</p>
<ul>
<li>id属性：是给切面提供一个唯一标识</li>
<li>ref属性：是指定通知类bean的Id。</li>
</ul>
</li>
<li><p>在aop:aspect标签的内部使用对应标签来配置通知的类型</p>
<ul>
<li><p>aop:before：表示配置前置通知</p>
<ul>
<li><p>method属性：用于指定Logger类中哪个方法是前置通知</p>
</li>
<li><p>pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</p>
<ul>
<li><p>切入点表达式的写法：</p>
<ul>
<li><p>关键字：execution(表达式)</p>
</li>
<li><p>表达式：<br>  访问修饰符  返回值  包名.包名.包名…类名.方法名(参数列表)</p>
</li>
<li><p>标准的表达式写法：<br>  public void com.itheima.service.impl.AccountServiceImpl.saveAccount()</p>
</li>
<li><p>访问修饰符可以省略<br>  void com.itheima.service.impl.AccountServiceImpl.saveAccount()</p>
</li>
<li><p>返回值可以使用通配符，表示任意返回值</p>
<ul>
<li>com.itheima.service.impl.AccountServiceImpl.saveAccount()</li>
</ul>
</li>
<li><p>包名可以使用通配符，表示任意包。但是有几级包，就需要写几个<em>.</em>.<em>.</em>.<em>.</em>.AccountServiceImpl.saveAccount())</p>
</li>
<li><p>包名可以使用..表示当前包及其子包* <em>..AccountServiceImpl.saveAccount()<br>类名和方法名都可以使用*来实现通配: * *..</em>.*()</p>
</li>
<li><p>参数列表：</p>
<ul>
<li>可以直接写数据类型：<ul>
<li>基本类型直接写名称<code>int</code></li>
<li>引用类型写包名.类名的方式 <code>java.lang.String</code></li>
</ul>
</li>
<li>可以使用通配符表示任意类型，但是必须有参数:<ul>
<li>可以使用..表示有无参数均可，有参数可以是任意类型</li>
</ul>
</li>
</ul>
</li>
<li><p>全通配写法：</p>
<ul>
<li>* <em>..</em>.*(..)</li>
</ul>
</li>
<li><p>实际开发中切入点表达式的通常写法：</p>
<ul>
<li>切到业务层实现类下的所有方法<ul>
<li>* com.itheima.service.impl.<em>.</em>(..)<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 步骤1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logger"</span> <span class="attr">class</span>=<span class="string">"com.itheima.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--步骤2: 配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--步骤3: 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 步骤4: 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printLog"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重用切入点表达式:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">              此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">              它还可以写在aop:aspect外面，此时就变成了所有切面可用</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置前置通知：在切入点方法执行之前执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"beforePrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span> &gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"afterReturningPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowingPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterPrintLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>环绕切入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">            此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">            它还可以写在aop:aspect外面，此时就变成了所有切面可用</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置环绕通知 详细的注释请看下面的Logger类中--&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"aroundPringLog"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于记录日志的工具类，它里面提供了公共的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ... (前置，后置，异常，最终通知的实现..)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * spring中的环绕通知：</span></span><br><span class="line"><span class="comment">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"前置通知"</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"后置通知"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">"异常通知"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="2-spring中基于注解的AOP配置"><a href="#2-spring中基于注解的AOP配置" class="headerlink" title="2. spring中基于注解的AOP配置"></a>2. spring中基于注解的AOP配置</h2><ol>
<li><p><strong>扫描注解</strong>：</p>
<ul>
<li>在xml中添加<code>&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;</code>来扫描包，或者使用配置类来扫描..</li>
</ul>
</li>
<li><p><strong>开启spring注解的AOP支持</strong>。 </p>
<ul>
<li>在xml中添加<code>&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code> 或者在配置类上加 <code>@EnableAspectJAutoProxy</code> 开启spring注解AOP的支持</li>
</ul>
</li>
<li><p><strong>配置切面</strong></p>
<ul>
<li>在增强类上(如上面的Log类)，加<code>@Aspect</code>注解..表明该类作为切面，用于增强”切入点” </li>
</ul>
</li>
<li><p><strong>配置切入点</strong></p>
<ul>
<li>切入点表达式的写法:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面，pt1()就是切入点表达式"execution(* com.itheima.service.impl.*.*(..))"的id，</span></span><br><span class="line"><span class="comment">// pt1()，函数名加括号，就是id！！ 一个字母都不能少！！</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>配置通知:前置通知，后置通知，异常通知，最终通知</strong></p>
<ul>
<li>在增强方法上，加上注解<code>@Before(&quot;切入点表达式id&quot;), @After(..), @AfterReturning(..), @AfterThrowing(..)</code>这里需要注意的是， 尽量不要使用上面这几个注解来做，因为它们的调用顺序可能会出问题.. 所以尽量还是用xml的方法来做..如果非要使用注解的话，那就用环绕注解来做.</li>
</ul>
</li>
<li><p><strong>配置环绕通知:</strong></p>
<ul>
<li>在增强类中的方法加上<code>@Around(&quot;切入点表达式id&quot;)</code>注解，就说明当前方法是增强方法.</li>
</ul>
</li>
</ol>
<h3 id="先来看一个例子"><a href="#先来看一个例子" class="headerlink" title="先来看一个例子:"></a>先来看一个例子:</h3><h4 id="1-Calculator-java"><a href="#1-Calculator-java" class="headerlink" title="1. Calculator.java"></a>1. Calculator.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> czf.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/27 11:36 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"calculator"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x/y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-LogAspect-java"><a href="#2-LogAspect-java" class="headerlink" title="2. LogAspect.java"></a>2. LogAspect.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> czf.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/27 11:35 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(public int czf.bean.Calculator.*(..))"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span>(<span class="string">"calculator()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BeforeLog</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JoinPoint来获取切入点信息(方法信息)</span></span><br><span class="line">		Object [] args = joinPoint.getArgs();</span><br><span class="line">		System.out.println(<span class="string">"开始执行"</span> + joinPoint.getSignature().getName() + <span class="string">"..."</span>);</span><br><span class="line">		System.out.println(<span class="string">"输入参数为: "</span> + Arrays.asList(args));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@After</span>(<span class="string">"calculator()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterLog</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">		System.out.println(joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AfterReturning</span>(value = <span class="string">"calculator()"</span>, returning = <span class="string">"object"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturningLog</span><span class="params">(JoinPoint joinPoint, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JoinPoint来获取切入点信息(方法信息)</span></span><br><span class="line">        <span class="comment">// 通过指定 returning = "xxx"， xxx为“接”返回值的那个形参的名称</span></span><br><span class="line">        <span class="comment">// 注意！！！ JointPoint必须写在形参的第一个位置，不然会error</span></span><br><span class="line">		System.out.println(<span class="string">"返回值为："</span> + object);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AfterThrowing</span>(value = <span class="string">"calculator()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExceptionLog</span><span class="params">(JoinPoint joinPoint, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过JoinPoint来获取切入点信息(方法信息)</span></span><br><span class="line">        <span class="comment">// 通过指定 throwing = "xxx"， xxx为“接”异常的那个形参的名称</span></span><br><span class="line">        <span class="comment">// 注意！！！ JointPoint必须写在形参的第一个位置，不然会error</span></span><br><span class="line">		System.out.println(joinPoint.getSignature().getName() + <span class="string">"出现异常，异常信息："</span> + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 环绕通知</span></span><br><span class="line"><span class="comment">	 * 问题：</span></span><br><span class="line"><span class="comment">	 *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</span></span><br><span class="line"><span class="comment">	 * 分析：</span></span><br><span class="line"><span class="comment">	 *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。</span></span><br><span class="line"><span class="comment">	 * 解决：</span></span><br><span class="line"><span class="comment">	 *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">	 *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * spring中的环绕通知：</span></span><br><span class="line"><span class="comment">	 *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Around</span>(<span class="string">"calculator()"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">		Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"前置"</span>);</span><br><span class="line"></span><br><span class="line">			rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"后置"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> rtValue;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Throwable t)&#123; <span class="comment">// 这里必须要用Throwable来捕获！！！Exception捕获不到！！</span></span><br><span class="line">			System.out.println(<span class="string">"异常"</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"最终"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后再总结一下AOP的使用："><a href="#最后再总结一下AOP的使用：" class="headerlink" title="最后再总结一下AOP的使用："></a><font color=red>最后再总结一下AOP的使用</font>：</h3><ul>
<li><p>1、导入aop模块；Spring AOP：(spring-aspects)</p>
</li>
<li><p>2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</p>
</li>
<li><p>3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；</p>
<ul>
<li>通知方法：<ul>
<li>前置通知(@Before)：logStart：在目标方法(div)运行之前运行</li>
<li>后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）</li>
<li>返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行</li>
<li>异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行</li>
<li>环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</li>
</ul>
</li>
</ul>
</li>
<li><p>4、给切面类的目标方法标注何时何地运行（通知注解）；</p>
</li>
<li><p>5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</p>
</li>
<li><p>6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)</p>
</li>
<li><p>[7]、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</p>
<ul>
<li>在Spring中很多的 @EnableXXX;</li>
</ul>
<h2 id="AOP三步："><a href="#AOP三步：" class="headerlink" title="AOP三步："></a>AOP三步：</h2></li>
<li><p>a、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）</p>
</li>
<li><p>b、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</p>
</li>
<li><p>c、开启基于注解的aop模式；@EnableAspectJAutoProxy</p>
</li>
</ul>
<h1 id="四、记录一些点"><a href="#四、记录一些点" class="headerlink" title="四、记录一些点"></a>四、记录一些点</h1><h3 id="1-单元测试中使用spring"><a href="#1-单元测试中使用spring" class="headerlink" title="1. 单元测试中使用spring"></a>1. 单元测试中使用spring</h3><p><code>@ContextConfiguration</code>这个注解通常与<code>@RunWith(SpringJUnit4ClassRunner.class</code>)`联合使用用来测试, </p>
<p><code>@RunWith(SpringJUnit4ClassRunner.class)</code>用于替换单元测试类的启动器（本身的启动器无法使用spring的IOC）。 </p>
<p><code>@ContextConfiguration(locations={&quot;aaa.xml&quot;})</code> 或 <code>@ContextConfiguration(classes={&quot;配置类.class&quot;})</code> 进行扫描操作，用于获取装有Bean的容器.</p>
<p>下面看个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= &#123;Config<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">XXXTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"accountService"</span>)</span><br><span class="line">    <span class="keyword">private</span> IAccountService ac = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Account act = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"myjpt"</span>)</span><br><span class="line">    <span class="keyword">private</span> CzfJoinPointer jp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ac.save(act);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jp.helloAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-在使用AOP的时候，需要额外依赖aspectjweaver-别忘记了"><a href="#2-在使用AOP的时候，需要额外依赖aspectjweaver-别忘记了" class="headerlink" title="2. 在使用AOP的时候，需要额外依赖aspectjweaver!!!! 别忘记了!!!"></a>2. 在使用AOP的时候，需要额外依赖aspectjweaver!!!! 别忘记了!!!</h3><h3 id="3-如果配置了AOP，那么只有是从容器里拿到的Bean才是被AOP增强过的，AutoWired等其他途径初始化得到的都是原始的Bean"><a href="#3-如果配置了AOP，那么只有是从容器里拿到的Bean才是被AOP增强过的，AutoWired等其他途径初始化得到的都是原始的Bean" class="headerlink" title="3. 如果配置了AOP，那么只有是从容器里拿到的Bean才是被AOP增强过的，AutoWired等其他途径初始化得到的都是原始的Bean!"></a>3. 如果配置了AOP，那么只有是从容器里拿到的Bean才是被AOP增强过的，AutoWired等其他途径初始化得到的都是原始的Bean!</h3><h3 id="4-从容器中使用getBean获取到的对象-如果是实现了某个接口的类的话，一定要强制转成其接口类"><a href="#4-从容器中使用getBean获取到的对象-如果是实现了某个接口的类的话，一定要强制转成其接口类" class="headerlink" title="4. 从容器中使用getBean获取到的对象, 如果是实现了某个接口的类的话，一定要强制转成其接口类"></a>4. 从容器中使用<code>getBean</code>获取到的对象, 如果是实现了某个接口的类的话，一定要强制转成其接口类</h3><p>因为spring用的是代理类，而不是实际的子类<br>关于代理，百度一下spring 代理，就理解其机制了<br>就是说，虽然你知道你拿到的是UserServiceImpl类型的对象，但实际上，spring存的是一个Proxy对象，该Proxy指向了一个UserServiceImpl对象，你直接对Proxy进行强制转换自然是失败的。</p>
<hr>
<p>最后附上一个<a href="http://www.matools.com/api/spring-zh" target="_blank" rel="noopener">Spring文档</a>:</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc/aop</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux指令学习/JVM指令</title>
    <url>/2020/07/10/Linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0-JVM%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-测试端口是否能连通"><a href="#1-测试端口是否能连通" class="headerlink" title="1. 测试端口是否能连通"></a>1. 测试端口是否能连通</h2><ul>
<li><code>telnet ip port</code> </li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200602180129633.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>ssh -v -p port username@ip</code><br>(-v表示是debug模式)<br><img src="https://img-blog.csdnimg.cn/20200602180352698.png" alt="在这里插入图片描述"></li>
<li><code>curl ip:port</code><br><img src="https://img-blog.csdnimg.cn/2020060218281616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<a id="more"></a>

<h2 id="2-远程登陆会话"><a href="#2-远程登陆会话" class="headerlink" title="2. 远程登陆会话"></a>2. 远程登陆会话</h2><ul>
<li>指令：ssh</li>
<li>SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。<br>远程登陆<code>ssh username@ip</code><h2 id="3-检测本机的端口网络连接情况"><a href="#3-检测本机的端口网络连接情况" class="headerlink" title="3. 检测本机的端口网络连接情况"></a>3. 检测本机的端口网络连接情况</h2></li>
<li>指令：netstat </li>
<li>检测本机的端口连接情况，可以使用netstat<br><code>netstat -ano | grep port</code><h2 id="4-查看某个进程的情况"><a href="#4-查看某个进程的情况" class="headerlink" title="4. 查看某个进程的情况"></a>4. 查看某个进程的情况</h2></li>
<li>指令： ps </li>
<li>查看某个进程的情况<br><code>ps -ef | grep pid</code> <h2 id="5-管道-正则匹配"><a href="#5-管道-正则匹配" class="headerlink" title="5. 管道 + 正则匹配"></a>5. 管道 + 正则匹配</h2></li>
<li>指令： <code>指令</code>  |  grep <code>正则表达式</code></li>
<li><code>grep ‘pattern‘ file</code> pattern为正则匹配字符串,file为输入文件<br>最常用的是配合管道来一起使用，即前一个指令的输出作为输入，然后用正则过滤，例如上面的<code>ps -ef</code> 就列出了所有的进程，然后 使用’|’ 作为管道连接字符，作为grep pid的输入, 就找到了指定pid的进程信息。</li>
</ul>
<h2 id="6-服务器上传-下载文件"><a href="#6-服务器上传-下载文件" class="headerlink" title="6. 服务器上传 / 下载文件"></a>6. 服务器上传 / 下载文件</h2><ul>
<li>指令：scp</li>
<li><code>scp [可选参数] file_source file_target</code></li>
</ul>
<p>从服务器上下载或上传文件.</p>
<p>上传：<br><code>scp ./1.txt root@xx.xx.xx.xx:/usr/local/software/</code><br>下载:<br><code>scp root@xx.xx.xx.xx:/usr/local/software/1.txt .</code> </p>
<h2 id="7-cpu负载很高怎么查看"><a href="#7-cpu负载很高怎么查看" class="headerlink" title="7. cpu负载很高怎么查看"></a>7. cpu负载很高怎么查看</h2><ul>
<li><p>执行top -c ，显示进程运行信息列表</p>
</li>
<li><p>键入P (大写p)，进程按照CPU使用率排序</p>
</li>
</ul>
<h3 id="案例一：CPU利用率100-怎么排查"><a href="#案例一：CPU利用率100-怎么排查" class="headerlink" title="案例一：CPU利用率100%怎么排查"></a>案例一：CPU利用率100%怎么排查</h3><h5 id="第一步：找到最消CPU性能的进程"><a href="#第一步：找到最消CPU性能的进程" class="headerlink" title="第一步：找到最消CPU性能的进程"></a>第一步：找到最消CPU性能的<font color=red>进程</font></h5><ol>
<li>top -c</li>
<li>键入大写P, 进程按照CPU使用率排序<br><img src="https://img-blog.csdnimg.cn/20200629225342216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="第二步：查找进程内最耗CPU的线程"><a href="#第二步：查找进程内最耗CPU的线程" class="headerlink" title="第二步：查找进程内最耗CPU的线程"></a>第二步：查找进程内最耗CPU的线程</h5></li>
<li>top -Hp pid ： 找出进程号为pid的进程中的所有线程</li>
<li>键入大写P，线程按照CPU使用率排序</li>
</ol>
<h5 id="第三步：转换线程ID"><a href="#第三步：转换线程ID" class="headerlink" title="第三步：转换线程ID"></a>第三步：转换线程ID</h5><ol>
<li>printf “%x/n” thread_id<br><img src="https://img-blog.csdnimg.cn/202006292259470.png" alt="在这里插入图片描述"></li>
</ol>
<h5 id="第四步：定位Java进程中cpu占用率高的线程"><a href="#第四步：定位Java进程中cpu占用率高的线程" class="headerlink" title="第四步：定位Java进程中cpu占用率高的线程"></a>第四步：定位Java进程中cpu占用率高的线程</h5><p><code>jstack pid | grep thread_id_hex  -A  需要打印的行数</code><br>下面是查看 14505进程中 “main”线程<br><img src="https://img-blog.csdnimg.cn/20200630003452292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h1 id="Java相关指令"><a href="#Java相关指令" class="headerlink" title="Java相关指令"></a>Java相关指令</h1><h2 id="8-打印出Java正在运行的进程"><a href="#8-打印出Java正在运行的进程" class="headerlink" title="8. 打印出Java正在运行的进程"></a>8. 打印出Java正在运行的进程</h2><ul>
<li>指令：jps</li>
<li>可以知道启动了哪些进程，对应的进程号<br><img src="https://img-blog.csdnimg.cn/20200630001657346.png" alt="在这里插入图片描述"><h2 id="9-图形化查看内存，线程等信息"><a href="#9-图形化查看内存，线程等信息" class="headerlink" title="9. 图形化查看内存，线程等信息"></a>9. 图形化查看内存，线程等信息</h2></li>
<li>指令：jconsole</li>
<li>连接对应的进程：<br><img src="https://img-blog.csdnimg.cn/20200630002304398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>连接后的界面：<br>可以查看内存（GC情况），线程，类，JVM情况和加载的Bean<br><img src="https://img-blog.csdnimg.cn/20200630002239287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="10-查看内存使用状况-jstat"><a href="#10-查看内存使用状况-jstat" class="headerlink" title="10. 查看内存使用状况( jstat )"></a>10. 查看内存使用状况( jstat )</h2></li>
<li>jstat -gc pid </li>
<li>用的比较少，需要用到就百度吧..<h2 id="11-分析Java线程的状况"><a href="#11-分析Java线程的状况" class="headerlink" title="11. 分析Java线程的状况"></a>11. 分析Java线程的状况</h2></li>
<li>指令：jstack thread_id </li>
<li>打印对应线程的运行情况</li>
</ul>
<h2 id="12-把当前java进程的状态给dump下来，或查看内存信息"><a href="#12-把当前java进程的状态给dump下来，或查看内存信息" class="headerlink" title="12. 把当前java进程的状态给dump下来，或查看内存信息"></a>12. 把当前java进程的状态给dump下来，或查看内存信息</h2><h3 id="1-dump下来"><a href="#1-dump下来" class="headerlink" title="1. dump下来"></a>1. dump下来</h3><ul>
<li>指令：jmap -dump:file=xxx pid （xxx是dump的文件名）</li>
<li>dump下来之后，需要用专门的工具来查看这个文件，有专门查看这类文件的可视化工具<br><img src="https://img-blog.csdnimg.cn/20200630004205794.png" alt="在这里插入图片描述"><h3 id="2-查看内存信息"><a href="#2-查看内存信息" class="headerlink" title="2. 查看内存信息"></a>2. 查看内存信息</h3></li>
<li>指令：jmap -heap pid<br><img src="https://img-blog.csdnimg.cn/20200630004556581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="13-强大的监控图形界面"><a href="#13-强大的监控图形界面" class="headerlink" title="13. 强大的监控图形界面"></a>13. 强大的监控图形界面</h2><p>升级版jconsole, 并且能手动GC，并且可以手动直接dump，<strong>可以查看dump出来的dump文件！</strong> 很强大。</p>
<ul>
<li>指令：jvisualvm<br><img src="https://img-blog.csdnimg.cn/20200630004822314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h2 id="一个JVM参数，当出现OOM时，自动进行dump"><a href="#一个JVM参数，当出现OOM时，自动进行dump" class="headerlink" title="一个JVM参数，当出现OOM时，自动进行dump"></a>一个JVM参数，当出现OOM时，自动进行dump</h2><ul>
<li>指令： -XX:+HeapDumpOnOutOfMemoryError</li>
</ul>
<hr>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="a-在指定文件夹下查询指定文件"><a href="#a-在指定文件夹下查询指定文件" class="headerlink" title="a. 在指定文件夹下查询指定文件"></a>a. 在指定文件夹下查询指定文件</h2><p>指令：find base_dir -f file_name<br>这里的file_name是可以使用正则来匹配的，比如  *.txt</p>
<h2 id="b-cut指令"><a href="#b-cut指令" class="headerlink" title="b. cut指令"></a>b. cut指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d ：分隔符，按列分割</span><br><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个列</span><br><span class="line">-c ：以字符为单位取出列。 ( ps: cut -c 7- 表示以自负为单位, 打印从第7列及其之后的字符列</span><br></pre></td></tr></table></figure>

<h3 id="示例-1：last-显示登入者的信息，取出用户名。"><a href="#示例-1：last-显示登入者的信息，取出用户名。" class="headerlink" title="示例 1：last 显示登入者的信息，取出用户名。"></a>示例 1：last 显示登入者的信息，取出用户名。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ last</span><br><span class="line">root pts&#x2F;1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class="line">root pts&#x2F;1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts&#x2F;1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line"></span><br><span class="line">$ last | cut -d &#39; &#39; -f 1</span><br></pre></td></tr></table></figure>

<h3 id="示例-2：将-export-输出的信息，取出第-12-字符以后的所有字符串。"><a href="#示例-2：将-export-输出的信息，取出第-12-字符以后的所有字符串。" class="headerlink" title="示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。"></a>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export</span><br><span class="line">declare -x HISTCONTROL&#x3D;&quot;ignoredups&quot;</span><br><span class="line">declare -x HISTSIZE&#x3D;&quot;1000&quot;</span><br><span class="line">declare -x HOME&#x3D;&quot;&#x2F;home&#x2F;dmtsai&quot;</span><br><span class="line">declare -x HOSTNAME&#x3D;&quot;study.centos.vbird&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"></span><br><span class="line">$ export | cut -c 12-</span><br></pre></td></tr></table></figure>

<h2 id="c-sort指令"><a href="#c-sort指令" class="headerlink" title="c. sort指令"></a>c. sort指令</h2><p>排序指令：<br>sort</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集总结</title>
    <url>/2020/07/10/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><h2 id="1-如何判断一个对象是不是垃圾"><a href="#1-如何判断一个对象是不是垃圾" class="headerlink" title="1. 如何判断一个对象是不是垃圾"></a>1. 如何判断一个对象是不是垃圾</h2><h3 id="1-1-可达性分析"><a href="#1-1-可达性分析" class="headerlink" title="1.1 可达性分析"></a>1.1 可达性分析</h3><p><img src="https://img-blog.csdnimg.cn/20200421175040860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以GC ROOT为起点进行扫描，能够被扫描到的对象，都是存活的对象，而无法被扫描到的对象，就是“垃圾”，需要被回收。GC ROOT一般包括但不限于：</p>
<ul>
<li><font size=4 color=brown>虚拟机栈中局部变量表中引用的对象</font></li>
<li><font size=4 color=brown>本地方法栈中 JNI 中引用的对象</font></li>
<li><font size=4 color=brown>方法区中类静态属性引用的对象</font></li>
<li><font size=4 color=brown>方法区中的常量引用的对象</font></li>
<li><font size=4 color=brown>被同步锁持有的对象</font></li>
</ul>
<h3 id="1-2-对象引用"><a href="#1-2-对象引用" class="headerlink" title="1.2 对象引用"></a>1.2 对象引用</h3><p>可达性分析是通过 <font color=red>“<strong>GC ROOT</strong>”</font> 和<font color=red><strong>对象引用</strong></font>来完成的可达性分析，GC ROOT上面已经说过了，这里主要说说对象引用。 如果对象引用只有 ：被引用 和 没被引用，那么对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。 例如，对于有些对象，我们希望在内存足够多的时候保留，内存吃紧的时候被回收（例如缓存），或是对于有些对象我们希望当仅仅被某个特殊引用引用着时被回收（WeakHashMap）等，仅靠 “被引用”和“未被引用” 这两个状态，显然无法满足一些特殊情况的要求，为此，在JDK1.2之后，Java对引用概念进行了扩充。</p>
<a id="more"></a>

<ul>
<li><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul>
<li>能够被一个或多个线程找到的引用</li>
<li>例如: Object obj = new Object();</li>
<li>GC不收集强引用对象</li>
</ul>
</li>
<li><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><ul>
<li><p>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>使用：<code>SoftReferenc&lt;Type&gt; ref = ...;</code></p>
</li>
<li><p>使用场景:</p>
<ul>
<li>用于缓存. </li>
<li>举例:  在浏览器实现后退这一功能时:<ul>
<li>如果每次后退都再重新请求一次网页，那么时间开销会相对较大，用户体验差;</li>
<li>如果每次后退都将页面缓存起来，那么内存可能会溢出;</li>
<li>那么，如果用软引用来指向缓存的页面的话，当内存不足时，会优先收集它们！ </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><ul>
<li><p>弱引用也是用来描述非必须对象的，他的强度比软引用更弱一些.</p>
</li>
<li><p><code>WeakReference&lt;Type&gt; ref = ...</code>;</p>
</li>
<li><p>在垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收。</p>
</li>
<li><p>弱引用的出现主要是为了解决<strong>过期映射</strong>的收集的, 考虑下面这个场景:</p>
<ul>
<li>在使用HashMap中，如果HashMap里保存了&lt;key0, value0&gt;，且key0永远都不会再出现了，那么显然应该收集掉&lt;key0,value0&gt;. 但是，这个键值对缺被HashMap强引用着，导致无法被回收..</li>
</ul>
</li>
<li><p>问题的解决就是用WeakHashMap, 也就是弱引用的应用了,  使用弱引用，当没有外界对象引用&lt;key0,value0&gt;时，WeakHashMap只是一个弱引用，在GC的时候，就会回收这个需要被收集的对象。</p>
</li>
</ul>
</li>
<li><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><ul>
<li><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例。</p>
</li>
<li><p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。</p>
</li>
<li><p><code>PhantomReference&lt;Type&gt; ref = ... ;</code></p>
</li>
<li><p>应用场景:</p>
<ul>
<li>jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 虚引用必须配合引用队列一起使用，因为上面引用的get操作，也就是`ref.get()` 将返回`null`, (软引用和弱引用对象的get都是返回指向的对象), 所以，必须搭配引用队列一起使用.  
- &lt;font size=5 color=blue&gt;引用队列&lt;/font&gt;

    目前对引用队列的理解：
    - 先捋清楚概念:
        1. 引用对象: 例如`SoftReference&lt;T&gt;`
        2. 被引用对象: 即引用对象指向的对象
        3. 引用队列: 里面保存着引用对象

    - 在创建引用对象的时候，可以将引用队列作为构造参数传入，这样的话，当被指向的对象被GC收集的时候 ( 注意，这里是指对象被GC收集了，但对象所占的内存并没有被释放！！！因为收集完对象之后并不是立即释放内存，而是等一会. [参考](https://www.zhihu.com/question/21663879) )，引用队列会把引用对象Enqueue到队列里去. 引用队列的remove操作如果队列为空的话是阻塞的.

    - 虚引用是通过和引用队列的搭配，来实现在对象被收集时，发出系统通知.
    - 猜测: 1个队列对应1个虚引用，实现了对特定对象的回收时的系统通知！ </code></pre><h2 id="2-对象的生命周期"><a href="#2-对象的生命周期" class="headerlink" title="2. 对象的生命周期"></a>2. 对象的生命周期</h2><p>为了更好的理解垃圾回收，我们来从对象的第一视角来看，一个对象从产生到被回收的过程。</p>
<ul>
<li><h4 id="第一阶段：创建阶段"><a href="#第一阶段：创建阶段" class="headerlink" title="第一阶段：创建阶段"></a>第一阶段：创建阶段</h4><p>  此阶段就是new一个对象的过程，当被初始化结束赋值给某个引用的时候，就进入了应用阶段</p>
</li>
<li><h4 id="第二阶段：应用阶段"><a href="#第二阶段：应用阶段" class="headerlink" title="第二阶段：应用阶段"></a>第二阶段：应用阶段</h4><p>  此阶段对象至少被一个强引用持有着，正在被使用</p>
</li>
<li><h4 id="第三阶段：不可见阶段"><a href="#第三阶段：不可见阶段" class="headerlink" title="第三阶段：不可见阶段"></a>第三阶段：不可见阶段</h4><p><strong>当前程序</strong>找不到对象了, 也就是说, 程序的执行位置超出了对象的作用域;</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(...)&#123;</span><br><span class="line">	Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行到这, 就超出了obj的作用域</span></span><br></pre></td></tr></table></figure>

<p>  但并不是说不存在强引用持有着当前对象！ 尽管无法被当前程序发现，但该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”！</p>
</li>
<li><h4 id="第四阶段：不可达阶段"><a href="#第四阶段：不可达阶段" class="headerlink" title="第四阶段：不可达阶段"></a>第四阶段：不可达阶段</h4><p>  该对象不再被任何强引用所持有。</p>
</li>
<li><h4 id="第五阶段：收集阶段"><a href="#第五阶段：收集阶段" class="headerlink" title="第五阶段：收集阶段"></a>第五阶段：收集阶段</h4><p>  当垃圾回收器发现该对象已经<strong>处于“不可达阶段”</strong> ，那么这个对象会被第一次标记，然后进行判断是否需要执行<code>finalize()</code>，如果这个对象<font color = red>“没有重写finalize()方法”</font> 或者<font color = red>已经执行过finalize()方法了</font> 那么对象就直接进入终结阶段等待被回收。  否则的话，说明该对象需要执行<code>finalize()</code>，那么就将它放到F-Queue队列中等待<code>Finalizer</code>线程来挨个执行这个队列里的对象的<code>finalize()</code>方法。 （ps：这里说的执行仅仅是触发其开始执行，但并不一定会等到它执行结束，因为如果finalize死循环了就把其他的对象给耽误了。）</p>
</li>
<li><h4 id="第六阶段：终结阶段"><a href="#第六阶段：终结阶段" class="headerlink" title="第六阶段：终结阶段"></a>第六阶段：终结阶段</h4><p>  当对象不需要执行finalize()方法  或  执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><h4 id="第七阶段：空间回收阶段"><a href="#第七阶段：空间回收阶段" class="headerlink" title="第七阶段：空间回收阶段"></a>第七阶段：空间回收阶段</h4><p>  垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ul>
<h2 id="3-分代收集预备知识"><a href="#3-分代收集预备知识" class="headerlink" title="3. 分代收集预备知识"></a>3. 分代收集预备知识</h2><p>我们都知道GC堆会被分代进行收集，一般会被划分为新生代和老年代，那么为什么要分代呢？</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ol>
<li><p><font size=5 color=brown>弱分代假说</font></p>
<p> 绝大多数对象都是朝生夕灭的。</p>
</li>
<li><p><font size=5 color=brown>强分代假说</font></p>
<p> 熬过越多次垃圾收集过程的对象就越难以消亡</p>
</li>
<li><p><font size=5 color=brown>跨代引用假说</font></p>
<p>跨代引用相对于同代引用来说仅占极少数</p>
</li>
</ol>
<p>因为跨代引用仅占了极少数，所以我们大可不必为少量的跨代引用对象而去扫描整个老年代，所以就在新生代上使用Remeber Set来记录哪些对象存在老年代的引用，这样就可以不用去扫描整个老年代了，Remeber Set具体如何实现的，到后面再说，这里知道它存在的意义就可以了。</p>
<h3 id="分代收集定义："><a href="#分代收集定义：" class="headerlink" title="分代收集定义："></a>分代收集定义：</h3><ul>
<li><h4 id="Partial-GC"><a href="#Partial-GC" class="headerlink" title="Partial GC"></a>Partial GC</h4><ul>
<li>新生代收集（Young GC/Minor GC）</li>
<li>老年代收集（Old GC/ Major GC）<br>  需要注意的是，对老年代的单独收集实际上只在CMS中存在，其他都不存在只针对老年代的收集，都是在Full GC的时候对老年代收集。</li>
<li>混合收集（Mixed GC）<br>  指的是收集<font size=4 color=red>整个新生代</font>和<font size=4 color=red>部分老年代</font>，目前只在G1收集里有。</li>
</ul>
</li>
<li><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4>  对整个Java堆和方法区的垃圾收集。</li>
</ul>
<h2 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4.  垃圾收集算法"></a>4.  垃圾收集算法</h2><p>注意，这里的垃圾收集算法只是针对“垃圾收集”这一过程，垃圾收集器的工作比较复杂，“垃圾收集”只是其中的一个环节。下面来看看几种常见的垃圾收集算法。</p>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p><img src="https://img-blog.csdnimg.cn/2020042120015099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>标记阶段：<ul>
<li>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</li>
</ul>
</li>
<li>清除阶段：<ul>
<li>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</li>
</ul>
</li>
</ul>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p><strong>不足：</strong></p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p><img src="https://img-blog.csdnimg.cn/20200421200249474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<ul>
<li><p>优点:</p>
<ul>
<li>不会产生内存碎片</li>
</ul>
</li>
<li><p>不足:</p>
<ul>
<li>需要移动大量对象，处理效率比较低。</li>
</ul>
</li>
</ul>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://img-blog.csdnimg.cn/20200421200402307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<p><font size=5 color=blue>新生代使用</font>：</p>
<ul>
<li><font size=5 color=brown>复制算法</font></li>
</ul>
<p><font size=5 color=blue>老年代使用</font>：</p>
<ul>
<li><font size=5 color=brown>标记 - 清除 、 标记 - 整理 </font></li>
</ul>
<h1 id="二、垃圾回收器"><a href="#二、垃圾回收器" class="headerlink" title="二、垃圾回收器"></a>二、垃圾回收器</h1><p><img src="https://img-blog.csdnimg.cn/20200423142410467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Serial-Serial-Old收集器"><a href="#Serial-Serial-Old收集器" class="headerlink" title="Serial / Serial Old收集器"></a>Serial / Serial Old收集器</h2><p><img src="https://img-blog.csdnimg.cn/20200423001928712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>都是串行的垃圾收集器，最古老的GC，都默认工作在JVM的Client模式下；</li>
<li>Serial工作在新生代，Serial工作在老年代</li>
<li>它们的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li>
<li>它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的</li>
</ul>
<h2 id="Parallel-Scanvenge-Parallel-Old"><a href="#Parallel-Scanvenge-Parallel-Old" class="headerlink" title="Parallel Scanvenge / Parallel Old"></a>Parallel Scanvenge / Parallel Old</h2><p><img src="https://img-blog.csdnimg.cn/20200423143701256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>主打吞吐量（ 较短的STW和吞吐量，这两个不能兼得，而 Parallel GC 就是优先考虑吞吐量的GC）</li>
<li><font size=4>$吞吐量= \frac{运行用户代码时间}{运行用户代码时间+垃圾收集时间}$<font></li>
<li>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</li>
</ul>
<h2 id="ParNew-CMS-Serial-Old"><a href="#ParNew-CMS-Serial-Old" class="headerlink" title="ParNew / CMS + Serial Old"></a>ParNew / CMS + Serial Old</h2><p><img src="https://img-blog.csdnimg.cn/20200423002548708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>ParNew 是 Serial 的并行版本，工作在年轻代，工作在JVM的Server模式下,  因为CMS是工作在老年代的多线程GC，而年轻代里的多线程GC，只有ParNew。（虽然Parallel Old也是多线程的，但它是面向吞吐量的，要和Parallel Scanvenge搭配）</li>
<li>CMS是工作在老年代下的，当因为浮游垃圾导致了Concurrent Mode Fail的时候，会触发Full GC， 此时会有后备预案Serial Old 来对老年代进行收集。<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a><font color=red>CMS</font></h3><img src="https://img-blog.csdnimg.cn/20200423153621652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h5>CMS的目标是以缩短STW，减少停顿感，尽管目前已不推荐使用ParNew+CMS，但作为初代考虑 “ 用户线程与GC线程并发执行 ”这一GC还是先来学习一下它的思想。</li>
</ul>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><font size=5 color=brown>初始标记</font></p>
<p>初始标记仅仅只是标记一下GC ROOTs能直接关联到的对象，速度很快，需要停顿。</p>
<p><font size=5 color=brown>并发标记</font></p>
<p>进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，但不需要停顿用户线程，用户线程和GC线程在此阶段可以并发执行。 </p>
<p><font size=5 color=brown>重新标记</font></p>
<p>为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。 举个例子，在使用三色标记法标记的时候，如果在并发标记的过程中， 用户线程做了一个操作，使得已经被标记完的对象指向了一个尚未被扫描的对象，然后指向这个尚未被扫描的对象的引用又被<code>null</code>掉了，这时就会出现空指针的问题，所以会使用 写屏障+SATB 来解决这个问题（具体在“三色标记法”章节中）</p>
<p>而重新标记这个阶段就是为了让这些对象重新标记的，这一阶段需要停顿。</p>
<p><font size=5 color=brown>重新标记</font></p>
<p>并发清除：不需要停顿。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>并发收集，低停顿。<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5></li>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure，触发Full GC。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余足够，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a><font color=red>G1垃圾收集器</font></h2><ul>
<li><h3 id="一、特点与设计目标"><a href="#一、特点与设计目标" class="headerlink" title="一、特点与设计目标"></a>一、特点与设计目标</h3><ul>
<li>软实时、低延时、<strong>可设定STW停顿目标</strong></li>
<li>适用于较大的堆(&gt;4G) （因为可以进行部分扫描）</li>
<li>设计目标就是尽可能少的调优. <ul>
<li>设定最大STW的停顿时间：-XX:MaxGCPauseMillis=N</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="二、G1内部细节"><a href="#二、G1内部细节" class="headerlink" title="二、G1内部细节"></a>二、G1内部细节</h3><ul>
<li>无需回收整个堆，<strong>而是回收一个Collection Set</strong></li>
<li>两种GC：<ul>
<li>Fully young GC</li>
<li>Mixed GC  </li>
</ul>
</li>
<li>估计每个Region中的垃圾比例，优先回收垃圾多的Region！</li>
</ul>
</li>
<li><h3 id="三、Card-Table-amp-Remember-Set"><a href="#三、Card-Table-amp-Remember-Set" class="headerlink" title="三、Card Table &amp; Remember Set"></a>三、Card Table &amp; Remember Set</h3></li>
<li><p>每一个Region都被分成了多个Card（如下图的长条），每一个Region都有一个RSet（Remember Set）， 每一个RSet里记录了引用当前Region的那些<strong>Card</strong>的位置，如此以来，在找跨代引用的时候， 就可以不用进行全堆扫描了，扫描RSet里记录的Card就可以！例如：A.a引用了b对象，于是在b对象所在Region的RSet中记录了A.a所在的Card的位置</p>
<p>   那么随之而来的一个问题就是，当出现引用关系改变的时候会需要去写RSet，那么在多线程环境下，RSet显然就成了临界资源，那么如何高效地写RSet就成了一个问题。  解决方法是通过 dirty queue来做，下面来说。<br><img src="https://img-blog.csdnimg.cn/20200423193348645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="Write-Barrier-Dirty-Queue-来实现对RSet的更新"><a href="#Write-Barrier-Dirty-Queue-来实现对RSet的更新" class="headerlink" title="Write Barrier + Dirty Queue 来实现对RSet的更新"></a>Write Barrier + Dirty Queue 来实现对RSet的更新</h4><p>在进行赋值操作的时候（即引用指针发生变化的时候），JVM注入的一小段代码。<br><code>object.field = &lt;reference&gt;(putfield)</code></p>
<ul>
<li>当更新指针时（例如:<code>A.a = b</code>）：<ul>
<li>将A.a所在的Card置为Dirty</li>
<li>将这个Dirty Card压入Dirty Card Queue</li>
<li>有一个Refinement线程去清空Dirty Card Queue，就是对RSet的更新。</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="四、流程"><a href="#四、流程" class="headerlink" title="四、流程"></a>四、流程</h3></li>
<li><h4 id="fully-young-GC"><a href="#fully-young-GC" class="headerlink" title="fully young GC"></a>fully young GC</h4></li>
<li>Stop The World :<ul>
<li>第一步：构建Collection Set ( Eden+Survivor )</li>
<li>第二步：扫描GC Root：<ul>
<li>扫描与GC Root直联的对象.   这里详细说一下为什么要进行GC Root的扫描，实际上，在进行mixed GC的时候，会先进行一次Young GC，然后！因为fully young gc是stop the world的！！ 所以在这个时间段内趁机进行一次 GC ROOTs的扫描，这也成为“借道（Piggybacking）”</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>        &gt; 事实上，当达到 IHOP 阈值时，G1 并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的 STW 时间段，完成初始标记，这种方式称为借道（Piggybacking）

- 第三步：更新Remember Set：
    - 就是将Dirty Card Queue 排空;  在发生引用的赋值时，例如:`A.a = B.b;`  此时，a对象是对b对象的引用，这时，需要更新b对象的RememberSet，写入`A.a这个对象引用了我`这个信息，具体的操作就是在RSet中写入一个**Entry&lt;a对象所在Region的首地址,  a对象所在的Card在其所处Region的偏移量&gt;**  ( ps: RSet是一个类似HashMap的数据结构 ) ； 但是！ 这个写入操作并不是在赋值时就立刻写入，而是将a对象所在的Card给标记成dirty，然后将这个Card给丢到`Dirty Card Queue`中，如果队列内元素数量不是太多那么一般就不去处理，等到在当前阶段(就是Fully Young GC的更新RSet阶段)进行更新； 但如果数量超过一定的界限，那么就会激活Refinement线程开始更新RS，避免当前STW过久； 如果使用Refinemement线程去更新RS仍然还是有很多DirtyCard，就说明用户线程产生的DirtyCard太快了，那么会让应用线程也参与到更新RS的工作中，以此将队列中的DirtyCard排空；
- 第四步：Process Remember Set：
    - 确定完Card了之后，就去扫描Card，找出老年代中引用了当前对象的那些对象！ （这些对象就是跨代引用的对象，其实最开始的初始标示的集合里 包括了 和GC ROOT直接相连的对象 和 在老年代里引用了（当前Collection Set里的对象）的那些对象！）
- 第五步：对象拷贝 （这里使用的是复制算法）
    - 将Eden和Suvivor中的对象拷贝到另一些Survivor区域中. 
- 第六步：处理引用队列
    - 对软引用，弱引用，虚引用的处理。</code></pre><ul>
<li><h4 id="Old-GC"><a href="#Old-GC" class="headerlink" title="Old GC"></a>Old GC</h4><ul>
<li>第一步：先进行一次 Fully young GC;</li>
<li>第二步：恢复应用线程，使用三色标记法并发标记对象：<ul>
<li>三色标记法：<ul>
<li>黑色表示已经访问完的；</li>
<li>灰色表示正在处理访问的；</li>
<li>白色表示尚未被访问的；</li>
</ul>
</li>
<li>在标记过程中可能会发生两个问题:<ul>
<li>问题一：已经访问过的对象，突然变成了垃圾，这就是浮游垃圾:</li>
<li>解决方法： 浮游垃圾的产生，这些垃圾只能等到下次GC的时候被回收；</li>
<li>问题二：某灰色对象引用了对象A，在并发操作的过程中，断开了灰色对象对对象A的引用，并添加了黑色对象对对象A的引用，此时对象A依然是处于强引用状态，但却永远无法被访问到（因为黑色对象已经被处理过了），因此会被误判成垃圾给释放掉。 </li>
<li>解决方法: 使用Write Barrier实现SATB(Snapshot-At-The-Begining)<ul>
<li>在并发标记的过程中，当对象引用发生<code>null</code>的改变时，例如原本<code>A.a=B.b;</code> , 然后执行了<code>A.a=null;</code> 就发生了<code>null</code>的改变，此时，会将<code>B.b</code>给标记下来。 <strong>简而言之，在并发标记期间给null掉的对象，仍然视为存活的对象，如果被误判了，那么就是浮游垃圾，会在下次GC回收</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三步：STW，重新标记Remark：<ul>
<li>SATB/Reference processing ：保证标记的对象都真的是活对象</li>
<li>CLeanUp：回收需要回收的Region，这里只会回收整个Region为空的Regin，如果一个Region只有部分的空间被利用，将无法被回收。。因此会产生碎片。。解决方法就是<code>Mixed GC</code></li>
</ul>
</li>
</ul>
</li>
<li><p>恢复应用线程</p>
</li>
<li><h3 id="下面是一次G1-Old-GC流程"><a href="#下面是一次G1-Old-GC流程" class="headerlink" title="下面是一次G1 Old GC流程"></a>下面是一次G1 Old GC流程</h3><p><img src="https://img-blog.csdnimg.cn/20200330224935542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><ul>
<li>不一定会立刻发生，而是根据建立的预测模型来进行判断是否需要进行.</li>
<li>选择若干个Region进行回收, 包括：<ul>
<li>默认1/8的Old Region <strong>(优先挑选垃圾最多的Region)</strong><ul>
<li>可用-XX:G!MixedGCCountTarget=N 来设定(默认N=8)</li>
</ul>
</li>
<li>Eden + Survivor Region</li>
<li>STW, Parallel Copying</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Mixed GC主要可以分为两个阶段</strong>：</p>
</li>
</ul>
<ol>
<li><p>全局并发标记（global concurrent marking）<br>全局并发标记又可以进一步细分成下面几个步骤：</p>
<ul>
<li>初始标记（initial mark，STW）。它标记了从GC Root开始直接可达的对象。初始标记阶段借用young GC的暂停，因而没有额外的、单独的暂停阶段。</li>
<li>并发标记（Concurrent Marking）。这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。过程中还会扫描上文中提到的SATB write barrier所记录下的引用。</li>
<li>最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。</li>
<li>清除垃圾（Cleanup，部分STW）。这个阶段如果发现完全没有活对象的region就会将其整体回收到可分配region列表中。 清除空Region。</li>
</ul>
</li>
<li><p>拷贝存活对象（Evacuation）<br>Evacuation阶段是全暂停的。它负责把一部分region里的活对象拷贝到空region里去（并行拷贝），然后回收原本的region的空间。Evacuation阶段可以自由选择任意多个region来独立收集构成收集集合（collection set，简称CSet），CSet集合中Region的选定依赖于上文中提到的停顿预测模型，该阶段并不evacuate所有有活对象的region，只选择收益高的少量region来evacuate，这种暂停的开销就可以（在一定范围内）可控。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码阅读小结</title>
    <url>/2020/07/10/Spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94IOC/</url>
    <content><![CDATA[<h1 id="Bean的生命周期（创建一个Bean的过程）："><a href="#Bean的生命周期（创建一个Bean的过程）：" class="headerlink" title="Bean的生命周期（创建一个Bean的过程）："></a>Bean的生命周期（创建一个Bean的过程）：</h1><ol>
<li>解析配置文件得到BeanDefinition并注册BeanDefinition。<br>根据传入的信息来解析生成BeanDefinition，如果是注解的形式的话，就是解析注解上的信息，如果是配置文件形式的话，ResourceLoader会根据传入的location来去使用不同的Resource接口的实现类来完成对配置文件的加载和解析，这是策略模式的一个应用。  解析之后得到了一个&lt; beanName, beanDefinition &gt;的一个KV对，然后将其注册到底层容器中，其实就是把它们存到一个Map中，底层容器叫DefaultListableBeanFactory.</li>
</ol>
<a id="more"></a>

<ol start="2">
<li>根据BeanDefinition来创建Bean。对于单例非延迟加载的那些bean，会在顶层ApplicaitonContext的构造方法的refrush方法中，被创建出来，并保存到三级缓存中。 创建Bean的流程是：<ol>
<li>如果是单例bean的话，先尝试从缓存中取，如果没取到或者不是单例bean的话，就根据bean的生命周期来调用不同的创建方法</li>
<li>除去判断循环依赖和后置处理器的回调这类逻辑之外，创建bean的核心就是：<ol>
<li>先进行bean的实例化</li>
<li>然后进行属性的填充（例如处理Autowired和Value注解）</li>
<li>调用bean的初始化方法：   <ul>
<li>调用初始化方法中，会先回调Aware接口</li>
<li>然后回调postBeforeXXX</li>
<li>执行初始化</li>
<li>回调postAfterXXX（在这儿进行AOP）</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="AOP原理："><a href="#AOP原理：" class="headerlink" title="AOP原理："></a>AOP原理：</h1><ol>
<li><p>@EnableAspectJAutoProxy这个注解的作用：</p>
<ol>
<li>设置动态代理方式</li>
<li>注册AspectJAutoProxyRegistrar：</li>
</ol>
</li>
<li><p>利用AspectJAutoProxyRegistrar，<br>给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator实现了<br>BeanPostProcessor接口，因此，当Spring加载这个Bean会<br>在实例化前调用其后置处理器实现增强</p>
</li>
<li><p>增强的地方有2个：</p>
<ul>
<li><p>一个是在getEarlyBeanReference那边，</p>
</li>
<li><p>一个是在postAfterInitialization那边，</p>
<p>之所以在两个地方是因为，当单例Bean需要被动态代理但也出现了循环依赖的时候，就需要将这个Bean给提前暴露在外面，而暴露的这个Bean将作为实例保存到其他实例的属性中， 而aop的动态代理，cglib方式实质上是创建了一个新的实例，因此，为了保证注入到其他Bean里的实例依然是被代理的对象，那么就必须在将该实例暴露在外面之前就使用动态代理，</p>
<p>Spring一个巧妙的地方就是，将第三级的缓存设置成一个接口函数，通过get方法来获取<br>Bean实例，之所以这么做是因为要配合getEarlyBeanReference来实现对创建的Bean的一个扩展，所以，如果一个单例Bean满足循环依赖的条件，并且需要进行aop，那么就会在<br>getEarlyBeanReference这里尝试进行动态代理。</p>
<p>而对于没有发生循环依赖的那些bean来说，如果需要进行aop，那么它们实际上实在postAfterInitialization那边进行动态代理的。并且在这边进行代理之前，会先判断这个被代理的bean是否被暴露在外面（暴露在外面的bean都存在一个集合中，看这个bean是否在这个集合中就能判断这个bean是否暴露在外面），只有这个bean没有暴露在外面，才能够在这里尝试进行动态代理.</p>
<p>进行动态代理的入口是调用一个叫wrapIfNecessary的类的，它会先获取作用在当前Bean上的所有切面，并根据Order进行排序，然后再根据EnableAutoProxy标签里的参数来决定是使用cglib来做还是使用jdk proxy来做，当然，如果使用jdk proxy但被代理对象没有实现接口的话，依然是使用cglib来做. </p>
</li>
</ul>
</li>
</ol>
<h1 id="IOC原理的理解"><a href="#IOC原理的理解" class="headerlink" title="IOC原理的理解"></a>IOC原理的理解</h1><p>IOC的实现原理，我认为主要就是通过实现IOC容器来对Bean进行一个管理.</p>
<p>而对Bean的管理，就是Bean的注册和创建，使得之后能够通过beanName获取到自己需要的bean</p>
<p>Bean的注册过程主要就是通过解析配置文件或注解来得到 &lt; beanName, BeanDefinition &gt; 的KV对，然后保存到底层容器中，而Bean的创建过程，主要做的工作就是：一个是bean的合法性检查，就是判断是否出现循环依赖等问题，一个是后置处理器的回调，这一回调出现在Bean真正创建时的各个时期（比如实例化的前后，初始化的前后等），还有一个就是对Bean的真正创建，而对bean真正创建的过程又主要分为3步：</p>
<ul>
<li>第一步是实例化：就是使用合适的构造器或其他方法来实例化bean，</li>
<li>第二步是类型填充主要做的工作就是完成对Autowied，Value这一注解的完成，</li>
<li>第三步是初始化主要做的工作是对Aware接口的回调和初始化方法的调用. </li>
</ul>
<h1 id="读Spring源码学习到的设计模式："><a href="#读Spring源码学习到的设计模式：" class="headerlink" title="读Spring源码学习到的设计模式："></a>读Spring源码学习到的设计模式：</h1><h2 id="1-单例（使用：BeanFactory）"><a href="#1-单例（使用：BeanFactory）" class="headerlink" title="1. 单例（使用：BeanFactory）"></a>1. 单例（使用：BeanFactory）</h2><p>双重锁校验 / 静态内部类 / 枚举</p>
<h2 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h2><h3 id="简单工厂方法"><a href="#简单工厂方法" class="headerlink" title="简单工厂方法"></a>简单工厂方法</h3><p>根据输入来返回需要创建的对象</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是通过继承工厂接口来实现对对象的创建，每一个子类工厂用于创建一种类型的对象</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式就是，一个子类工厂用于创建一种类型的多种对象，举个例子来说的话，如果使用工厂模式来创建鼠标，那么对于创建苹果牌的鼠标，创建苹果牌的键盘，创建华为牌的鼠标都是独立的一个工厂，而对于抽象工厂模式，会有一个创建苹果牌系列产品的工厂，它可以生产苹果牌鼠标，苹果牌键盘，等等..</p>
<h2 id="3-委派"><a href="#3-委派" class="headerlink" title="3. 委派"></a>3. 委派</h2><p>用的很多，在applicationcontext顶层容器里，使用：BeanDefinition注册</p>
<h2 id="4-责任链"><a href="#4-责任链" class="headerlink" title="4. 责任链"></a>4. 责任链</h2><p>BeanPostProcessor里用到、AOP里切面类的调用时使用到 </p>
<h2 id="5-模板模式"><a href="#5-模板模式" class="headerlink" title="5. 模板模式"></a>5. 模板模式</h2><p>源码：refresh里的一些方法是抽象的留给子类去实现</p>
<h2 id="6-策略模式"><a href="#6-策略模式" class="headerlink" title="6. 策略模式"></a>6. 策略模式</h2><p>策略模式在使用配置文件的形式来配置bean的时候，ResourceLoader会根据输入的不同location信息，来使用不同的策略来加载并解析配置文件，其实就是使用不同的实现了Resource接口的类)</p>
<p>发布-订阅，单一责任原则，接口分离原则，依赖倒置原则，开放封闭原则等</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>ioc/aop原理</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP滑动窗口/拥塞控制/流量控制</title>
    <url>/2020/07/10/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><h2 id="1-有连接和无连接"><a href="#1-有连接和无连接" class="headerlink" title="1. 有连接和无连接"></a>1. 有连接和无连接</h2><p><img src="https://img-blog.csdnimg.cn/20200528213311923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="二、UDP一对一-一对多和一对全-，TCP一对一"><a href="#二、UDP一对一-一对多和一对全-，TCP一对一" class="headerlink" title="二、UDP一对一, 一对多和一对全 ，TCP一对一"></a>二、UDP一对一, 一对多和一对全 ，TCP一对一</h2><p><img src="https://img-blog.csdnimg.cn/20200528215917191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="三、UDP面向报文，TCP面向字节流"><a href="#三、UDP面向报文，TCP面向字节流" class="headerlink" title="三、UDP面向报文，TCP面向字节流"></a>三、UDP面向报文，TCP面向字节流</h2><p><img src="https://img-blog.csdnimg.cn/202005282208496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、可靠性"><a href="#四、可靠性" class="headerlink" title="四、可靠性"></a>四、可靠性</h2><p><img src="https://img-blog.csdnimg.cn/20200528221123262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="五、报文头信息"><a href="#五、报文头信息" class="headerlink" title="五、报文头信息"></a>五、报文头信息</h2><p><img src="https://img-blog.csdnimg.cn/20200528221355933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://img-blog.csdnimg.cn/20200528221549152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82?id=tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" target="_blank" rel="noopener">滑动窗口</a></h1><h2 id="1-发送方："><a href="#1-发送方：" class="headerlink" title="1. 发送方："></a>1. 发送方：</h2><p>一个报文的状态：</p>
<ul>
<li><p>已经发送，并且收到确认报文（已结束）<font color=blue>（窗口外）</font></p>
</li>
<li><p>已经发送，但还未收到确认报文（等待ACK） <font color=red>（窗口内）</font></p>
</li>
<li><p>可以发送，但尚未发送（已就绪，等待发送）<font color=red>（窗口内）</font></p>
</li>
<li><p>不可以发送（受窗口限制，不允许发送）<font color=blue> （窗口外）</font><br><img src="https://img-blog.csdnimg.cn/20200528195853562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果出现丢包，那么就会重复对丢包报文前的那个报文进行确认，例如在上图中，如果发送了31，32，33，34，45，其中32丢包，31，33，34，35按序号到达，那么当33到的时候，34到的时候，35到的时候，都是发的对31的确认报文，相当于多发了3次对31的确认报文（当对同一个报文重复确认3次的时候，则会触发快重传）。</p>
<p>  因此，在上图中，31～41一定都是未收到确认的，当31确认收到了以后，那么窗口就会向右滑动，直到最左方的首个元素是“发送了但尚未收到确认报文的” 或者“尚未发送的”。 继续上面这个例子，当31，33，34，35到达，接收方发送了3个对31号报文的ACK，就会触发“快重传”，重新传送32。</p>
</li>
</ul>
<h2 id="2-接收方"><a href="#2-接收方" class="headerlink" title="2. 接收方"></a>2. 接收方</h2><p>接收方窗口左边为已经发送过的确认报文，右边为当前不能接收的报文。</p>
<h3 id="接收方窗口："><a href="#接收方窗口：" class="headerlink" title="接收方窗口："></a>接收方窗口：</h3><ul>
<li>最左边报文一定是尚未收到的报文</li>
<li>如果31没到，32，33先到，就先把32，33缓存在接收缓冲区中，并且会发送2个对30的确认报文，当收到了31的确认报文，那么窗口就继续滑动到34的位置.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200528202534525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82?id=tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">拥塞控制</a></h1><p>在理想情况下，随着请求数的增长，网络的吞吐量也会增长，当用户的请求出超出了网络所能承载的负荷时，吞吐量将保持不变。。</p>
<p>而实际情况是，当用户对网络资源的请求数量超过了网路所能抗住的负荷时，吞吐量会随着请求的增多而减少，直到变为0。<img src="https://img-blog.csdnimg.cn/20200528171821368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 而拥塞控制就是为了防止这一情况的产生，其实现的方式就是，通过调整发送窗口的大小，来控制发送速率，从而起到减少网络流量的作用。  </p>
<p><strong>发送方</strong>需要维护3个变量( 发送窗口(cwnd), 拥塞窗口(swnd), 窗口阈值(ssthresh))：<br><font color=red><strong>实际上，发送方发送窗口大小 = min（拥塞窗口大小（拥塞控制）, 接收方接收窗口大小（流量控制））</strong></font><br><img src="https://img-blog.csdnimg.cn/20200528184230937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>拥塞控制包括了4个算法策略分别是：慢开始，拥塞避免，快重传，快恢复。</p>
<h2 id="慢开始："><a href="#慢开始：" class="headerlink" title="慢开始："></a>慢开始：</h2><p>cwnd = 1, 每发送一轮窗口大小的数据并成功接收到确认报文，就给窗口大小乘2，<br>当窗口大小超过ssthresh时，使用拥塞避免算法。</p>
<h2 id="拥塞避免："><a href="#拥塞避免：" class="headerlink" title="拥塞避免："></a>拥塞避免：</h2><p>每发送一轮窗口大小的数据并成功接收到确认报文，就给窗口大小<font color=red><strong>加1</strong></font>，一旦出现超时重传，则判定网络可能出现了拥堵，<strong>将cwnd置为1</strong>，<strong>ssthresh变为原来的一半</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200528192205692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="快重传："><a href="#快重传：" class="headerlink" title="快重传："></a>快重传：</h2><p>快重传就是：并不是等超时了才再重传，而是<strong>连续收到3个重复的ACK报文时</strong>，就开始重传！</p>
<p><img src="https://img-blog.csdnimg.cn/20200528192030381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><p>快恢复就是：出现了需要重传的情况，并不是把cwnd置为1，而是置成原来大小的一半,（ssthresh也置为原来的一半）。<br><img src="https://img-blog.csdnimg.cn/20200528192239154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200528170429906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><a href="https://www.bilibili.com/video/BV1kJ41177Qd?from=search&seid=15849888663651403541" target="_blank" rel="noopener">流量控制</a></h1><p>流量控制就是，让接收方的发送速率能够匹配上接收方的接收速率，具体实现体现在：控制发送方的发送窗口大小（如果发送的太快了，就把窗口调小点，如果发的太慢了，就把窗口调大点），发送方窗口的大小根据接收方窗口的大小来决定。</p>
<p><font color=red><strong>实际上，发送方发送窗口大小 = min（拥塞窗口大小（拥塞控制）, 接收方接收窗口大小（流量控制））</strong></font></p>
<p>该<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60" target="_blank" rel="noopener">视频</a>的例子讲的非常棒。</p>
<ul>
<li><p>发送方在接收到接收方的确认报文段后，会根据报文中的接收方窗口大小值，来重新调整当前的发送窗口大小。（初始大小在TCP三次握手的时候确定）</p>
</li>
<li><p>发送方窗口可以被设成零。 当发送方窗口大小为0时，会定时发送零窗口探测报文，询问接收方的窗口大小，如果还是0，那么就重置这个定时器，如果不是0就重新调整窗口大小。</p>
</li>
<li><p>TCP规定，接收方接收窗口即使为0，也应接收零窗口探测报文，确认报文段，以及携带紧急数据的报文段。</p>
</li>
</ul>
<hr>
<h1 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h1><p><img src="https://img-blog.csdnimg.cn/20200528145334495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><h2 id="源端口："><a href="#源端口：" class="headerlink" title="源端口："></a>源端口：</h2><ul>
<li>源端口和IP地址的作用是<strong>标识报文的返回地址</strong>。</li>
</ul>
</li>
<li><h2 id="目的端口："><a href="#目的端口：" class="headerlink" title="目的端口："></a>目的端口：</h2><ul>
<li>端口指明接收方计算机上的应用程序接口。</li>
</ul>
</li>
</ul>
<p><font color=red>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接</font></p>
<ul>
<li><h3 id="序号-Seq-和确认号-ACK-："><a href="#序号-Seq-和确认号-ACK-：" class="headerlink" title="序号 (Seq) 和确认号 (ACK) ："></a>序号 (Seq) 和确认号 (ACK) ：</h3><ul>
<li>序号是<strong>本报文段</strong>发送的数据组的第一个字节的序号。<strong>在TCP传送的流中，每一个字节一个序号</strong>。例如：一个报文段的序号为300（Seq=300），此报文段数据部分共有100字节，则下一个报文段的序号为400。所以<strong>序号确保了TCP传输的有序性</strong>。</li>
<li>确认号，即ACK，指<strong>下一个期待收到的字节序号</strong>， <strong>表明该序号之前的所有数据已经正确无误的收到</strong>。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li>
</ul>
</li>
<li><h3 id="数据偏移／首部长度：4bits。"><a href="#数据偏移／首部长度：4bits。" class="headerlink" title="数据偏移／首部长度：4bits。"></a>数据偏移／首部长度：4bits。</h3><ul>
<li>由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li>
</ul>
</li>
<li><h3 id="保留："><a href="#保留：" class="headerlink" title="保留："></a>保留：</h3><ul>
<li>为将来定义新的用途保留，现在一般置0</li>
</ul>
</li>
<li><h3 id="控制位：URG-ACK-PSH-RST-SYN-FIN，共6个，每一个标志位表示一个控制功能。"><a href="#控制位：URG-ACK-PSH-RST-SYN-FIN，共6个，每一个标志位表示一个控制功能。" class="headerlink" title="控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。"></a>控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</h3><ul>
<li><p>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</p>
</li>
<li><p><font color=red><strong>ACK</strong></font>：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</p>
</li>
<li><p>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</p>
</li>
<li><p>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</p>
</li>
<li><p><font color=red> <strong>SYN</strong></font>：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p>
</li>
<li><p><font color=red><strong>FIN</strong></font>：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal学习</title>
    <url>/2020/07/10/ThreadLocal%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、ThreadLocal解决了什么问题"><a href="#一、ThreadLocal解决了什么问题" class="headerlink" title="一、ThreadLocal解决了什么问题"></a>一、ThreadLocal解决了什么问题</h1><p> 在一些情况下，我们希望对于某一个共享变量，对于不同线程来说都是独一无二的，例如：有一个共享变量x，线程A去对其进行写操作，读操作，线程B也对其进行写操作读操作，而线程A和线程B在去读写x时的感觉，就像是读写一个本地变量一样，完全与外界<strong>封闭</strong>， 这就是线程封闭的想法。下面有三种线程封闭的实践：</p>
<ul>
<li><h2 id="Ad-hoc-线程封闭："><a href="#Ad-hoc-线程封闭：" class="headerlink" title="Ad-hoc 线程封闭："></a>Ad-hoc 线程封闭：</h2><ul>
<li>即维护线程封闭性职责交给程序实现，很不推荐使用。</li>
</ul>
</li>
<li><h2 id="栈封闭："><a href="#栈封闭：" class="headerlink" title="栈封闭："></a>栈封闭：</h2><ul>
<li>利用线程的局部变量只有自己可见这一特性，每次都手动将共享变量拷贝一份局部变量的副本。缺点是，只有编写程序的人才知道哪些对象需要封闭，并且还要考虑栈溢出的问题。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><h2 id="ThreadLocal（线程封闭的最佳实践）："><a href="#ThreadLocal（线程封闭的最佳实践）：" class="headerlink" title="ThreadLocal（线程封闭的最佳实践）："></a>ThreadLocal（线程封闭的最佳实践）：</h2><ul>
<li>Java提供给我们线程封闭的实现类，下面我们来学习它</li>
</ul>
</li>
</ul>
<h1 id="二、ThreadLocal学习"><a href="#二、ThreadLocal学习" class="headerlink" title="二、ThreadLocal学习"></a>二、ThreadLocal学习</h1><h2 id="1-quick-start"><a href="#1-quick-start" class="headerlink" title="1. quick start"></a>1. quick start</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Basic</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x看似是一个类共享的静态变量，实际上是线程独占的静态变量！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; x = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="comment">// 延迟加载的初始化，默认为null</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 初始值设为当前线程的id;</span></span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(x.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        System.out.println(x.get());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印结果为：</span></span><br><span class="line"><span class="comment">         *  11</span></span><br><span class="line"><span class="comment">         *  1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        x.set(<span class="number">101l</span>); <span class="comment">// x被赋值为101 ps:x仅为当前main线程可见</span></span><br><span class="line">        x.remove();  <span class="comment">// x变成了初始值 ps:x仅为当前main线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ThreadLocal的常用场景："><a href="#2-ThreadLocal的常用场景：" class="headerlink" title="2. ThreadLocal的常用场景："></a>2. ThreadLocal的常用场景：</h2><ul>
<li><h3 id="场景1-线程资源持有："><a href="#场景1-线程资源持有：" class="headerlink" title="场景1 线程资源持有："></a>场景1 线程资源持有：</h3><p>  <img src="https://img-blog.csdnimg.cn/20200402210358742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Web开发中，处理每一个用户的线程都有一个对应的Session，把取出来的用户数据都存放到同一个ThreadLocal的user中，不同线程的user这样就被隔离开了.</p>
</li>
<li><h3 id="场景2-：JDBC中确保线程资源一致性"><a href="#场景2-：JDBC中确保线程资源一致性" class="headerlink" title="场景2 ：JDBC中确保线程资源一致性"></a>场景2 ：JDBC中确保线程资源一致性</h3></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200402214057678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在一个线程中可能会有多个JDBC操作, 例如一个线程处理一个用户的请求，那么这一线程中可能就会有多次对数据库的访问操作，每一次操作对应上面的<code>part</code></p>
<p>ThreadLocal能够让同一个线程申请到的Connection保证是同一个。之所以这样保证线程获取到Connection的一致性，是因为：JDBC层面要保证<strong>一个事务是在一个线程里维护的</strong>，这样做不仅天然的解决的同步问题，同时也方便回滚的实现，因此，每一个操作所在的那个(事务)线程要和JDBC连接池的线程进行绑定.   这里的ThreadLocalMap是ThreadLocal变量的一个容器。</p>
<p>同时，在Spring的分布式事务里，也是通过ThreadLocal来记录处理事务的上下文.</p>
<ul>
<li><h3 id="场景3-线程安全"><a href="#场景3-线程安全" class="headerlink" title="场景3 线程安全"></a>场景3 线程安全</h3><p><img src="https://img-blog.csdnimg.cn/20200402215854787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>LastError是共享变量，初始是False，当某一线程运行错误时，会将其置为True, 如果是线程A出错，那么在它去将LastError置为True时应该只能被线程A自己看到，而不能被Thread2看到, 此时，ThreadLocal就可以保证上面的实现.</p>
</li>
<li><h3 id="场景4-分布式计算"><a href="#场景4-分布式计算" class="headerlink" title="场景4 分布式计算"></a>场景4 分布式计算</h3><p><img src="https://img-blog.csdnimg.cn/20200402220833433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>某一个巨大的任务被切分成多个线程去跑，而每个子线程运行出的子任务结果就可以保存到ThreadLocal变量中，不同的线程只可见自己的运行结果，最终由Collector完成统一组装。</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>现在有一个任务，x初始为0，通过调用 <code>x = increment(x)</code> 来把x加到10000, <code>increment</code>函数实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Integer increment throw <span class="title">Exception</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	x += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们希望使用100个线程去完成这个任务，一个可行的方法就是，每个线程加100次，然后最后把这100个线程的计算结果给整合到一起. 于是，我们可以建立一个静态HashMap被这个100个线程共享，HashMap中的每一个Entry就是一个&lt;Thread, Integer&gt;的映射， 然后每次在<code>initialValue</code>的时候，把新的Entry给put进去，当在进行结果读取的时候，通过遍历HashMap来获取每一个子任务的结果，最终进行整合.</p>
<p>需要注意的是，上述使用的HashMap在初始化阶段也是在并发环境中的，因此其put操作也必须是原子操作。 其次，真正实现的时候，在构成&lt;Thread, Integer&gt;映射的时，我们希望value是一个引用变量（<code>Val&lt;Integer&gt;</code>）。</p>
<h1 id="三、ThreadLocal的简单实现"><a href="#三、ThreadLocal的简单实现" class="headerlink" title="三、ThreadLocal的简单实现"></a>三、ThreadLocal的简单实现</h1><ol>
<li><p>MyThreadLocal.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/3 10:40 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">// h(x) = 1640531527*x % ( INT_MAX ) , INT_MAX = x^&#123;32&#125; - 1</span></span><br><span class="line">    <span class="comment">// 高德纳提出的算法</span></span><br><span class="line">    Integer threadLocalHash = atomicInteger.getAndAdd(<span class="number">0x61c88647</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 之所以是Entry&lt;Integer, Object&gt;而不是是Entry&lt;MyThreadLocal&lt;?&gt;, Object&gt; </span></span><br><span class="line">	<span class="comment">// 是因为如果使用后者的话，HashMap的引用会导致对应</span></span><br><span class="line">	<span class="comment">// ThreadLocal变量永远不能被GC回收</span></span><br><span class="line">	<span class="comment">// 其实在ThreadLocal的源码里，是一个继承了WeakReference的Entry</span></span><br><span class="line">	<span class="comment">// static class Entry extends WeakReference&lt;ThreadLocal&gt;</span></span><br><span class="line">	<span class="comment">// 这里只是简单实现了一下，因此就用一个唯一哈希的Int来代表唯一的ThreadLocal.</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Thread, HashMap&lt;Integer, Object&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">private</span> HashMap&lt;Integer, Object&gt; <span class="title">getMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> ( !mp.containsKey(<span class="keyword">this</span>) )</span><br><span class="line">            mp.put(thread, <span class="keyword">new</span> HashMap&lt;Integer, Object&gt;());</span><br><span class="line">        <span class="keyword">return</span> mp.get(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Object&gt; map = getMap();</span><br><span class="line">        <span class="keyword">if</span> (map.get(threadLocalHash)==<span class="keyword">null</span>)</span><br><span class="line">            map.put(threadLocalHash, initialValue());</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(threadLocalHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T v)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Object&gt; map = getMap();</span><br><span class="line">        map.put(threadLocalHash, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T v;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/4/3 10:39 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> MyThreadLocal&lt;Long&gt; v = <span class="keyword">new</span> MyThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Long&gt; st = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    st.add(v.get());</span><br><span class="line">                    System.out.println(v.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st.size()!=<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"size="</span>+st.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的主要思路就是，MyThreadLocal类中有一个能被所有MyThreadLocal对象访问到的一个静态HashMap，里面的Entry为 &lt;Thread, 对应该Thread的局部变量Map&gt;.</p>
<p>在<code>对应该Thread的局部变量Map</code>中，Entry为&lt;能够找到这个局部变量的唯一标识符，其Value值&gt;   ； 在源码的实现里，这个唯一标识符就是<code>ThreadLocal</code>变量本身，考虑到其能够被GC回收，源码并没有使用容器里的Map，而是重新实现了一个ThreadLocalMap这个专门存储ThreadLocal变量，其中Entry是继承了WeakReference的一个弱引用，注意，这里只是Key是弱引用，而Value不是。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在上面的粗糙实现中，直接用Hash值（atomicInteger）来作为这个唯一表示。</p>
<h1 id="四、使用ThreadLocal需要注意的："><a href="#四、使用ThreadLocal需要注意的：" class="headerlink" title="四、使用ThreadLocal需要注意的："></a>四、使用ThreadLocal需要注意的：</h1><ul>
<li><p>因为ThreadLocalMap的Entry中，Key是弱引用，但Value不是弱引用，<strong>因此，在调用完<code>set()</code>操作，一定还要调用对应的<code>remove()</code>操作</strong>。如果不这么做的话, 会导致如下问题:</p>
<ul>
<li>如果该线程是运行在线程池里的线程，那么在下一个请求得到这个线程的时候，可能会发生<strong>get到上一次请求set的值</strong></li>
<li>如果Thread实例还在，但是ThreadLocal实例却不在了，则ThreadLocal实例作为key所关联的value无法被外部访问，却还被强引用着，因此出现了内存泄露。</li>
</ul>
</li>
<li><p>ThreadLocalMap实现的HashMap是使用线性探测法来解决冲突的，因此，让一个线程内部的ThreadLocal变量的个数尽可能的小，能够减少冲突次数，保证性能。</p>
</li>
</ul>
<h1 id="五、ThreadLocal原理："><a href="#五、ThreadLocal原理：" class="headerlink" title="五、ThreadLocal原理："></a>五、ThreadLocal原理：</h1><h2 id="1-每一个Thread里都有一个Map-ThreadLocalMap"><a href="#1-每一个Thread里都有一个Map-ThreadLocalMap" class="headerlink" title="1. 每一个Thread里都有一个Map (ThreadLocalMap)"></a>1. 每一个Thread里都有一个Map (ThreadLocalMap)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	 ...</span><br><span class="line">	 <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-ThreadLocal的set操作"><a href="#2-ThreadLocal的set操作" class="headerlink" title="2. ThreadLocal的set操作"></a>2. ThreadLocal的set操作</h2><ol>
<li>先尝试获取map，如果获取不到就创建</li>
<li>得到map后就对其进行set<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// 获取map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);  <span class="comment">// map如果是null就去创建</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-ThreadLocal的get操作"><a href="#3-ThreadLocal的get操作" class="headerlink" title="3. ThreadLocal的get操作"></a>3. ThreadLocal的get操作</h2><ol>
<li>尝试获取map，如果map没有被初始化就返回初始值</li>
<li>如果获取到map就返回对应的值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">// 在setInitialValue方法里面，会对没有初始化的map进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ThreadLocalMap"><a href="#4-ThreadLocalMap" class="headerlink" title="4. ThreadLocalMap"></a>4. ThreadLocalMap</h2><p>ThreadLocalMap是每一个WeakHashMap,  每一个线程都有着这样一个Map，并且从上面的代码中可以看出，这个Map是以懒加载的形式进行初始化的。 </p>
<p>KV对的类型是&lt; ThreadLocal&lt;?&gt; , Object &gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Set the value associated with key.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">     <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">     <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">     <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">     Entry[] tab = table;</span><br><span class="line">     <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">          e != <span class="keyword">null</span>;</span><br><span class="line">          e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">         ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">             e.value = value;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;  <span class="comment">// 在这里，</span></span><br><span class="line">             replaceStaleEntry(key, value, i);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">         rehash();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、哪里用到了"><a href="#六、哪里用到了" class="headerlink" title="六、哪里用到了"></a>六、哪里用到了</h1><p>这个记录一下自己使用ThreadLocal的场合，在仿写Spring轮子的时候， 要在创建<strong>多例</strong>的时候需要判断是否出现了循环依赖，因此，会保存正在创建的对象，如果在创建对象的时候发现这个对象已经处于正在创建的对象的集合中，那么就说明出现了多例bean的循环依赖，需要抛出异常，在这里，这个保存正在创建的对象的集合就是一个ThreadLocal的HashSet， 因为如果不是ThreadLocal的话，在线程A正在创建X的时候，X处于正在创建的状态，此时线程B也去创建X，这时发现X已经处于正在创建的状态了，就会误以为出现了循环依赖，这是不对的，因为其他线程创建X对当前线程不应该有影响… 而这里如果使用了ThreadLocal就能够解决这个问题。（因为必须是在单个线程里出现环才说明出现了循环依赖）</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">ThreadLocal-面试必问深度解析</a><br><a href="https://www.jianshu.com/p/1a5d288bdaee" target="_blank" rel="noopener">ThreadLocal小结-到底会不会引起内存泄露</a></p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>http/https学习</title>
    <url>/2020/07/10/http-https%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="HTTP1-0和HTTP1-1的主要区别"><a href="#HTTP1-0和HTTP1-1的主要区别" class="headerlink" title="HTTP1.0和HTTP1.1的主要区别"></a>HTTP1.0和HTTP1.1的主要区别</h1><h2 id="区别一：短连接和长连接"><a href="#区别一：短连接和长连接" class="headerlink" title="区别一：短连接和长连接"></a>区别一：短连接和长连接</h2><h3 id="一、HTTP1-0使用短连接"><a href="#一、HTTP1-0使用短连接" class="headerlink" title="一、HTTP1.0使用短连接"></a>一、HTTP1.0使用短连接</h3><p>http1.0使用的是短连接，就是每进行一次http请求都要重新建立一次tcp连接。</p>
<h4 id="短连接影响性能的最主要的两个原因"><a href="#短连接影响性能的最主要的两个原因" class="headerlink" title="短连接影响性能的最主要的两个原因"></a>短连接影响性能的最主要的两个原因</h4><h5 id="a-每次都需要握手-挥手-慢启动"><a href="#a-每次都需要握手-挥手-慢启动" class="headerlink" title="a. 每次都需要握手/挥手/慢启动"></a>a. 每次都需要握手/挥手/慢启动</h5><p>tcp连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大</p>
<h5 id="b-tcp连接数过多而被阻塞"><a href="#b-tcp连接数过多而被阻塞" class="headerlink" title="b. tcp连接数过多而被阻塞"></a>b. tcp连接数过多而被阻塞</h5><p>一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个，因此，在短连接的场景下，频繁的建立TCP连接可能会因为无法创建新的连接而被阻塞住。</p>
<a id="more"></a>

<h4 id="二、HTTP1-1支持长连接-并且默认是长连接"><a href="#二、HTTP1-1支持长连接-并且默认是长连接" class="headerlink" title="二、HTTP1.1支持长连接( 并且默认是长连接 )"></a>二、HTTP1.1支持长连接( 并且默认是长连接 )</h4><p>而http1.1支持长连接，并且默认是长连接, 即在tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。但是在这里需要注意的是，这里的tcp复用必须是对同一个tcp连接的复用（废话），即是对同一个socket的复用（例如请求同一个网页上的文字，图片等资源，是可以复用的，但如果是不同的连接上的资源（例如其他网站），那么肯定就无法复用了）。  Connection请求头的值为Keep-Alive 表示为长连接</p>
<p>PS: 在http2.0中，使用长连接+IO多路复用模型进一步优化【针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞】这一问题。</p>
<h2 id="区别二：HTTP1-0更节约带宽"><a href="#区别二：HTTP1-0更节约带宽" class="headerlink" title="区别二：HTTP1.0更节约带宽"></a>区别二：HTTP1.0更节约带宽</h2><p>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。 </p>
<p>而HTTP1.1种在请求消息中增加了range头域，它允许只请求资源的某个部分。</p>
<h3 id="对于请求报文"><a href="#对于请求报文" class="headerlink" title="对于请求报文"></a>对于请求报文</h3><p>在请求报文中添加 <font color=red><strong>Range</strong></font> 首部字段指定请求的范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;z4d4kWk.jpg HTTP&#x2F;1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes&#x3D;0-1023</span><br></pre></td></tr></table></figure>

<h3 id="对于响应报文"><a href="#对于响应报文" class="headerlink" title="对于响应报文"></a>对于响应报文</h3><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 </p>
<p>在响应报文中，由<font color=red><strong>Content-Range和Content-Length</strong> </font>字段 来告知传输情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023&#x2F;146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure>

<h2 id="区别三：HTTP1-1多了Host域"><a href="#区别三：HTTP1-1多了Host域" class="headerlink" title="区别三：HTTP1.1多了Host域"></a>区别三：HTTP1.1多了Host域</h2><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，<strong>因此，请求消息中的URL并没有传递主机名（hostname）</strong>。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p>
<p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。</p>
<p>（PS：补充一下这个host的意思，若多个域名对应同一个ip，那么当根据不同的域名访问到同一个ip的时候，服务端不知道该响应哪一种服务，而如果有host，服务端就知道这个请求是从哪个域名访问来的，就可以提供对应的服务啦）</p>
<h2 id="区别四：HTTP1-1支持分块传输"><a href="#区别四：HTTP1-1支持分块传输" class="headerlink" title="区别四：HTTP1.1支持分块传输"></a>区别四：HTTP1.1支持分块传输</h2><p>发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载，同时也能让浏览器逐步显示页面，提高页面的响应速度。</p>
<h2 id="区别五：HTTP1-1引入了新的状态码100"><a href="#区别五：HTTP1-1引入了新的状态码100" class="headerlink" title="区别五：HTTP1.1引入了新的状态码100"></a>区别五：HTTP1.1引入了新的状态码100</h2><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><p>该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。在服务器发送了 100 Continue 状态码之后，如果收到客户端的请求，则必须进行响应。</p>
<p>这个状态码实际上是对如下场景的一种优化：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。实际操作为客户端发送一条特殊的请求报文，报文的头部应包含</p>
<p><code>Expect: 100-continue</code></p>
<p>此时，如果服务器愿意接受，就会返回 100 Continue 状态码，反之则返回 417 Expectation Failed 状态码。对于客户端而言，如果客户端没有发送实际请求的打算，则不应该发送包含 100 Continue Expect 的报文，因为这样会让服务器误以为客户端将要发送一个请求。</p>
<h2 id="区别六：HTTP1-1支持流水线"><a href="#区别六：HTTP1-1支持流水线" class="headerlink" title="区别六：HTTP1.1支持流水线"></a>区别六：HTTP1.1支持流水线</h2><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在<strong>同一条长连接</strong>上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h2 id="区别七：引入max-age指令"><a href="#区别七：引入max-age指令" class="headerlink" title="区别七：引入max-age指令"></a>区别七：引入max-age指令</h2><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br></pre></td></tr></table></figure>
<p>http1.0里 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h1 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%E4%B9%9D%E3%80%81get-%E5%92%8C-post-%E6%AF%94%E8%BE%83" target="_blank" rel="noopener">Get 和 Post 的区别</a></h1><ul>
<li><p>GET是安全的，而POST是不安全的。</p>
<p>  安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
</li>
<li><p>GET请求会被浏览器主动cache，而POST默认不会缓存（除非手动设置）。</p>
</li>
<li><p>GET请求在URL中传送的参数是有长度限制的（实际上是没限制的，但是因为参数是放到url里，浏览器对url的最大长度是有限制的，所以GET请求传输参数就有限制的了..），而POST没有（实际是有的，尽管http协议没限制，但是在服务器配置中会有限制，例如：在 Tomcat 环境中，server.xml 文件有个 maxPostSize 字段来限制 POST 上传大小，默认貌似是 2M。） 因此，<font color=red>GET 和 POST 是没有长度限制的，真正限制的是浏览器和服务器。</font> 但就算这样，POST能够上传的数据大小依然比GET要多.. </p>
<p>  <a href="https://www.jianshu.com/p/ddab44726e11" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p>
</li>
<li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
</li>
<li><p>GET参数通过URL传递，POST放在Request body中</p>
</li>
</ul>
<hr>
<h1 id="一个url请求的流程"><a href="#一个url请求的流程" class="headerlink" title="一个url请求的流程"></a>一个url请求的流程</h1><h2 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h2><p>域名解析就是根据url来获取对应的ip的过程。</p>
<ol>
<li>浏览器 会首先会去搜索浏览器自身的DNS缓存 ， 如果找到了url对应的ip就直接返回</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</li>
<li>如果在OS的DNS缓存里也没找到，那么尝试读取hosts文件（在linux和mac下，hosts在/etc/hosts里）</li>
<li>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是运营商提供的）发起域名解析请求。</li>
<li>DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。</li>
<li>如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（假如url=<a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a></li>
<li>根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求</li>
<li>com域这台服务器告诉运营商的DNS我不知道<a href="http://www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址发起请求" target="_blank" rel="noopener">www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址发起请求</a></li>
<li>然后在baidu.com这个域名的DNS服务器中找到了我们想要的<a href="http://www.baidu.com的ip，然后将ip层层返回，并刷新到缓存中。" target="_blank" rel="noopener">www.baidu.com的ip，然后将ip层层返回，并刷新到缓存中。</a><h2 id="2-发起TCP的3次握手"><a href="#2-发起TCP的3次握手" class="headerlink" title="2. 发起TCP的3次握手"></a>2. 发起TCP的3次握手</h2>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024 &lt; 端口 &lt; 65535）根据获取的ip ，向服务器的WEB程序80端口发起TCP的连接请求。<br>（然后开始三次握手）<h2 id="3-建立TCP连接后发起http请求"><a href="#3-建立TCP连接后发起http请求" class="headerlink" title="3. 建立TCP连接后发起http请求"></a>3. 建立TCP连接后发起http请求</h2>进过TCP3次握手之后，浏览器发起了http的请求<h2 id="4-服务器响应http请求，浏览器得到html代码"><a href="#4-服务器响应http请求，浏览器得到html代码" class="headerlink" title="4. 服务器响应http请求，浏览器得到html代码"></a>4. 服务器响应http请求，浏览器得到html代码</h2><h2 id="5-浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）"><a href="#5-浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）" class="headerlink" title="5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）"></a>5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</h2><h2 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6. 浏览器对页面进行渲染呈现给用户"></a>6. 浏览器对页面进行渲染呈现给用户</h2><h2 id="7-当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。"><a href="#7-当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。" class="headerlink" title="7.当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。"></a>7.当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。</h2></li>
</ol>
<hr>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><ol>
<li>HTTP监听80端口，HTTPS监听443端口</li>
<li>HTTP的报文没有进行加密，而HTTPS使用了SSL或TSL进行了加密，其实质是通过非对称加密+CA认证来得到对称加密的密钥，然后开始使用对称加密进行传输，下面是HTTPS的一个主要流程。</li>
</ol>
<h1 id="HTTPS流程"><a href="#HTTPS流程" class="headerlink" title="HTTPS流程"></a>HTTPS流程</h1><h2 id="1-根据非对称加密-CA-确定对称加密的密钥K"><a href="#1-根据非对称加密-CA-确定对称加密的密钥K" class="headerlink" title="1. 根据非对称加密 + CA 确定对称加密的密钥K"></a>1. 根据非对称加密 + CA 确定对称加密的密钥K</h2><ol>
<li><p>客户端 =&gt; 服务端:</p>
<ul>
<li>在请求报文中携带的信息主要有：<ul>
<li>支持的SSL版本</li>
<li>支持的非对称加密算法</li>
<li><font color=red>随机数1</font></li>
</ul>
</li>
</ul>
</li>
<li><p>服务端向CA请求证书：（这一步需要付费）</p>
<ol>
<li>服务端向CA发送: &lt; 服务端的相关信息、公钥（PK） &gt;</li>
<li>CA将获取到的 &lt; 服务端的相关信息、公钥 &gt; 打包在一起放到数字证书里。</li>
<li>使用 <strong>CA 端的密钥（CSK）</strong> 对 &lt; 服务端的相关信息、公钥 &gt; 进行加密，生成<strong>数字签名</strong> , 然后也放到数字证书里面。</li>
<li>CA将数字证书发送给A。 数字证书中主要包含了 ( 服务端的公钥（PK）和经CSK加密过的PK )</li>
</ol>
</li>
<li><p>服务端 =&gt; 客户端:</p>
<ul>
<li>服务端发送给客户端响应报文，其中包含了：<ul>
<li>对SSL版本号的确认</li>
<li>对称加密算法</li>
<li><font color =red>随机数2</font></li>
<li><font color=blue>数字证书</font></li>
</ul>
</li>
</ul>
</li>
<li><p>客户端会对接收到的数字证书做一个认证：</p>
<ul>
<li>将数字证书中的<strong>数字签名取出</strong>，并使用CA的公钥（CPK）进行解密，将解密后的信息和数字证书中预存的信息做一个对比，若相同，则说明这个请求确实是从服务端发来的，可以信任里面的信息的。若不同则会认为被黑客篡改了，会抛出告警信息，即证书不安全的提示。 若验证通过，则从证书种能够获得服务端的公钥，用它来进行一个加密。</li>
</ul>
</li>
<li><p>客户端 =&gt; 服务端 （假设证书合法，继续往下走）</p>
<ul>
<li>在请求报文中主要包括的信息：<ul>
<li>将前两次通信的报文数据做一个哈希加密，得到一个加密结果（假设为X）</li>
<li><font color=red>随机数3</font></li>
</ul>
</li>
</ul>
</li>
<li><p>服务端进行验证</p>
<ul>
<li>服务端也根据前两次通信的报文数据以相同的加密算法来进行一个加密，并和客户端传输来的X进行一个比较，若相同则合法，否则就非法。</li>
<li>如果合法的话，就根据前面传输的 &lt;随机数1，随机数2，随机数3 &gt; 来用一个特殊的加密算法生成一个数字，这个数字将作为对称加密的密钥，假设它为K</li>
</ul>
</li>
<li><p>服务端 =&gt; 客户端 </p>
<ul>
<li>服务端向客户端发送的数据主要是：<ul>
<li>K</li>
<li>将前三次的通信报文数据来做一个哈希加密，得到的加密结果（假设为Z）</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端进行验证：</p>
<ul>
<li>根据前三次的通信报文用相同的算法进行加密，得到结果，并和服务端传来的Z进行比较，若相同则合法。</li>
<li>若合法的话，也根据&lt;随机数1， 随机数2， 随机数3 &gt;来用和服务端相同的加密算法来生成对称加密的密钥K</li>
</ul>
</li>
</ol>
<h2 id="2-以K作为密钥，开始使用对称加密进行传输"><a href="#2-以K作为密钥，开始使用对称加密进行传输" class="headerlink" title="2. 以K作为密钥，开始使用对称加密进行传输"></a>2. 以K作为密钥，开始使用对称加密进行传输</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习小结</title>
    <url>/2020/07/10/mysql%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h1><h2 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h2><p>提高查询效率，避免全表扫描;</p>
<h2 id="2-如何定位并优化慢sql"><a href="#2-如何定位并优化慢sql" class="headerlink" title="2. 如何定位并优化慢sql"></a>2. 如何定位并优化慢sql</h2><p>先说步骤：</p>
<ul>
<li><h3 id="第一步：根据慢日志定位慢查询sql"><a href="#第一步：根据慢日志定位慢查询sql" class="headerlink" title="第一步：根据慢日志定位慢查询sql"></a>第一步：根据慢日志定位慢查询sql</h3><ul>
<li><h4 id="根据慢查询日志确定慢sql："><a href="#根据慢查询日志确定慢sql：" class="headerlink" title="根据慢查询日志确定慢sql："></a>根据慢查询日志确定慢sql：</h4><ul>
<li>使用<code>show variables like &#39;%quer%&#39;;</code>可以看到一些变量（可以使用<code>set global xx=..;</code>, 也可以在<code>my.cnf</code>配置文件里修改，是mysql server的启动配置），其中:<ol>
<li><code>slow_query_log</code> 表示满查询日志是否开启；</li>
<li><code>long_query_time</code> 超过了这个时间的将被视为慢查询（一般超过1秒就被视为慢查询, 修改完需要重新获取connection）</li>
<li><code>slow_query_log_file:</code> 慢查询日志保存位置</li>
</ol>
</li>
<li>系统状态：<ul>
<li>使用<code>show status like &#39;%slow_queries%&#39; ;</code> 查询下面这个变量</li>
<li><code>Slow_queries</code>: 慢查询的数量 ( 客户端重新连接时，这个数据会被清0 )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><h3 id="第二步：使用explain等工具分析sql"><a href="#第二步：使用explain等工具分析sql" class="headerlink" title="第二步：使用explain等工具分析sql"></a>第二步：使用explain等工具分析sql</h3><ul>
<li><p>使用<code>explain</code>去分析这个慢sql，这里只介绍常用的关键字段，更多字段<a href="https://www.cnblogs.com/xiaoboluo768/p/5400990.html" target="_blank" rel="noopener">参考这里</a>.</p>
<ul>
<li><p><strong>type：</strong> 表示sql找到数据行的方式, 其取值范围如下（性能递减，越往下，性能越差）:</p>
<ul>
<li><p><strong>system</strong>:</p>
<ul>
<li>只有一条数据的系统表，或者派生表只有一条数据自查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.name</span><br><span class="line"><span class="keyword">from</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> teacher t <span class="keyword">where</span> t.id = <span class="number">1</span> ) a ;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><font color=red><strong>const</strong></font>:</p>
<ul>
<li>查询的结果“只有一条记录” 的sql，用于主键索引或唯一索引,  <font color=dark_red>如果where中使用的条件列上没有主键 或者 唯一索引，那么就一定不是const.</font></li>
</ul>
</li>
<li><p><font color=red><strong>eq_ref</strong></font>：</p>
<ul>
<li><p>唯一性索引，对于每个键的查询，返回匹配唯一行数据</p>
<p>  <font size=5 color=brown><strong>const和eq_ref的区别是：</strong></font></p>
</li>
<li><p>简单地说是const是直接按主键或唯一键读取，eq_ref用于联表查询的情况，<strong>按联表的主键或唯一键联合查询</strong>。</p>
</li>
</ul>
<p>  <strong>例如下面这个例子是单表中的，所以是const</strong>：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>  <strong>而下面这个是对多个表的联合查询，所以是eq_ref:</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> t1, t2 </span><br><span class="line"><span class="keyword">where</span> t1.user_id = t2.id;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=red><strong>ref</strong></font>:</p>
<ul>
<li>非唯一索引访问(只有普通索引，唯一索引和非唯一索引的区别见附录)</li>
</ul>
</li>
<li><p>fulltext</p>
</li>
<li><p>ref_or_null</p>
</li>
<li><p>index_merge</p>
</li>
<li><p>unique_subquery</p>
</li>
<li><p>index_subquery</p>
</li>
<li><p>range：</p>
<ul>
<li>range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，<font color=red>需要记住的是出现了range，则一定是基于索引的。</font>同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。</li>
</ul>
</li>
<li><p><font color=red><strong>index</strong>：<strong>另外一种形式的全表扫描，只不过它的扫描顺序是按照索引的顺序</strong></font></p>
</li>
<li><p><font color=red><strong>all</strong>：<strong>全表扫描，需要优化！</strong></font></p>
</li>
</ul>
</li>
<li><p><strong>extra：</strong> 获取更为详细的信息，辅助了解sql的执行方式：</p>
<ul>
<li>Using filesort：<ul>
<li>表示Mysql会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上排序。MYSQL中无法利用索引完成的排序操作称为“文件排序”。<strong>一句话来说就是：mysql的索引无法起到排序的作用，而是需要通过外部的文件排序来完成，会很慢！需要优化！！</strong></li>
</ul>
</li>
<li>Using temporary：<ul>
<li>表示MYSQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by。<strong>使用临时表来完成排序，也很慢！！需要优化了！！</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="第三步：修改sql或者让sql尽量走索引"><a href="#第三步：修改sql或者让sql尽量走索引" class="headerlink" title="第三步：修改sql或者让sql尽量走索引"></a>第三步：修改sql或者让sql尽量走索引</h3><ul>
<li>修改sql 或 让sql走索引</li>
</ul>
</li>
</ul>
<h2 id="2-最左前缀匹配"><a href="#2-最左前缀匹配" class="headerlink" title="2. 最左前缀匹配"></a>2. 最左前缀匹配</h2><p>个人理解是这样的：</p>
<ul>
<li>Innodb使用B+树实现了索引，当建立联合索引的时候，假设<code>index(col1, col2)</code>，叶子结点也是递增有序的，这种排序方式是先根据看col1的key进行排序，如果col1相等，再根据col2进行排序，以此类推； 因此，在where条件中如果有对col1的筛选条件，那么就能用到B+树的有序性，在logN复杂度下找到首个匹配的col1的位置，同时，如果不仅有col1，还有col2的话，还可以继续这样进行索引下推的去匹配… 但是，如果在where的条件中没有col1，只有col2，那将无法使用到这个索引，因为，整体上来看col2实际上是无序的（只有在col1相等所有情况中col2才是有序的）。</li>
<li>看懂了上面的机制之后，也就明白为什么：如果在联合索引的第 i 个位置命中了范围查询，那么 i 之后的列就无法使用到索引了。</li>
<li>另外，where条件中的列匹配的顺序并不一样非要按照索引的顺序排列才能生效，Innodb内部会帮我们按照尽量按照能命中索引的方式进行排序.</li>
</ul>
<h2 id="3-索引建立的越多越好吗？"><a href="#3-索引建立的越多越好吗？" class="headerlink" title="3. 索引建立的越多越好吗？"></a>3. 索引建立的越多越好吗？</h2><ul>
<li>数据量小的表不需要建立所以，建立会增加额外开销；</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着也需要更多的空间</li>
</ul>
<h1 id="二、日志"><a href="#二、日志" class="headerlink" title="二、日志"></a>二、日志</h1><h2 id="1、redo-Log-和-bin-log的区别"><a href="#1、redo-Log-和-bin-log的区别" class="headerlink" title="1、redo Log 和 bin log的区别"></a>1、redo Log 和 bin log的区别</h2><ul>
<li>redo log是Innodb引擎独有的，是引擎层面的。而bin log是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log的作用是实现crack-safe；binlog主要用于数据归档和数据恢复，实现 <strong>“让数据库恢复到半个月内任意一秒的状态”</strong>；</li>
<li>redo log记录的是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”</li>
<li>redo log是循环写的，空间固定会用完（[checkpoint, writepos] 是已写数据）。<img src="https://img-blog.csdnimg.cn/20200416152602887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ul>
<h2 id="2、两段式提交"><a href="#2、两段式提交" class="headerlink" title="2、两段式提交"></a>2、两段式提交</h2><h3 id="2-1-Innodb引擎执行一条update的流程："><a href="#2-1-Innodb引擎执行一条update的流程：" class="headerlink" title="2.1 Innodb引擎执行一条update的流程："></a>2.1 Innodb引擎执行一条update的流程：</h3><ol>
<li><p>执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200417152358590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述过程中，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h3 id="2-2-为什么要两段式提交？"><a href="#2-2-为什么要两段式提交？" class="headerlink" title="2.2 为什么要两段式提交？"></a>2.2 为什么要两段式提交？</h3><p>redo log 和 bin log的操作必须要保证其原子性，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序，这两种情况均无法保证原子性！</p>
<ul>
<li>先写redo log后写binlog：<ul>
<li>写完redo log，系统就挂了。。在恢复的时候发现redo log已经commit了，因此就继续执行，但此时bin log缺没有被记录。下次在恢复数据的时候，就会出现错误；</li>
</ul>
</li>
<li>先写bin log 再写redo log:<ul>
<li>写完bin log，系统就挂了。。在恢复的时候发现redo log还没写，因此就重新执行这个事务，但此时binlog里已经写过了，然后会再次记录这条记录，就会多一次操作记录，下次再恢复的时候依然会出现错误！</li>
</ul>
</li>
</ul>
<p>因此，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<h3 id="2-3-在两阶段提交的不同时刻MySQL出现异常，重启后会出现什么情况"><a href="#2-3-在两阶段提交的不同时刻MySQL出现异常，重启后会出现什么情况" class="headerlink" title="2.3 在两阶段提交的不同时刻MySQL出现异常，重启后会出现什么情况"></a>2.3 在两阶段提交的不同时刻MySQL出现异常，重启后会出现什么情况</h3><ul>
<li><p><strong>在崩溃恢复时，MySQL会做以下判断规则：</strong></p>
<ul>
<li>如果redo log里面的事务是完整的，也就是已经有了commit标识，则直接提交；（这种情况就是commit完成之后发生了crack）</li>
<li>如果redo log里面的事务只有完整的prepare，则判断对应的事务binlog是否存在并完整；    <ul>
<li>如果binlog已经写完，则进行commit。</li>
<li>如果binlog未写或没有写完整，则进行回滚。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>MySQL怎么知道binlog是完整的？</strong></p>
<ul>
<li>tatement格式的binlog，最后会有COMMIT；</li>
<li>row格式的binlog，最后会有一个XID event。</li>
<li>另外，在MySQL 5.6.2版本以后，还引入了binlog-checksum参数，用来验证binlog内容和正确性，对于binlog日志由于磁盘的原因，可能会在日志中间出错的情况，MySQL可以通过校验checksum的结果来发现，所以，MySQL还是有办法验证事务binlog的完整性的。</li>
</ul>
</li>
<li><p><strong>redo log和binlog是怎么关联起来的？</strong></p>
<ul>
<li>他们都有一个共同的数据字段，叫XID。奔溃恢复的时候，会被顺序扫描redo log：<ul>
<li>如果碰到既有prepare，又有commit的redo log，就直接提交。</li>
<li>如果碰到只有prepare，没有commit的redo log，就拿着XID去binlog找对应的事情。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://blog.csdn.net/anying5823/article/details/104675987/" target="_blank" rel="noopener">参考</a></p>
<h3 id="2-4-binlog的三种模式"><a href="#2-4-binlog的三种模式" class="headerlink" title="2.4 binlog的三种模式"></a>2.4 binlog的三种模式</h3><h4 id="1-STATMENT模式："><a href="#1-STATMENT模式：" class="headerlink" title="1. STATMENT模式："></a>1. STATMENT模式：</h4><p>基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。</p>
<ul>
<li>优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。</li>
<li>缺点：在某些情况下会导致master-slave中的数据不一致（例如插入时间为当前时间，就会导致插入数据不一致）。</li>
</ul>
<h4 id="2-ROW模式"><a href="#2-ROW模式" class="headerlink" title="2. ROW模式"></a>2. ROW模式</h4><p>基于行的复制(row-based replication, RBR)格式：不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。</p>
<ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li>
</ul>
<h4 id="3-Mixed模式"><a href="#3-Mixed模式" class="headerlink" title="3. Mixed模式"></a>3. Mixed模式</h4><p>前两种模式的组合；根据sql语句来采用不同的模式； </p>
<h1 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h1><h2 id="3-1-事务的四大特性"><a href="#3-1-事务的四大特性" class="headerlink" title="3.1 事务的四大特性"></a>3.1 事务的四大特性</h2><ul>
<li><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>  将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</p>
</li>
<li><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>  事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100。 并发一致性问题：</p>
<ul>
<li><strong>丢失修改</strong>：<ul>
<li>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</li>
<li><img src="https://img-blog.csdnimg.cn/20200417131647373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><strong>读脏数据</strong>：<ul>
<li>T1 修改一个数据，T2 随后读取这个数据。<strong>如果 T1 撤销了这次修改</strong>，那么 T2 读取的数据是脏数据。</li>
<li><img src="https://img-blog.csdnimg.cn/20200417131740202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><strong>不可重复读</strong>：<ul>
<li>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</li>
</ul>
</li>
<li><strong>幻影读</strong>：<ul>
<li>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。如果说不可重复读是读取同一数据的结果不一样的话，幻读就是存在性的结果的不一致。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>　　<br>　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　</p>
</li>
<li><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>  如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离，换句话说，对于事务本身来说，它所感知的数据库，应该只有它自己在操作。</p>
</li>
</ul>
<pre><code>然而多个事务执行时，如果严格遵守上面的要求，那么执行效率就会低下. 因此提出了四个隔离级别。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200417144414834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70)
- #### 未提交读
    - 一个事务还没提交时，它做的变更就能被别的事务看到

- #### 提交读
    - 一个事务提交之后，它做的变更才会被其他事务看到

- #### 可重复读：
    - 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- #### 可串行化：
    - 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。
    - 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</code></pre><h2 id="3-2-多版本并发控制-MVCC"><a href="#3-2-多版本并发控制-MVCC" class="headerlink" title="3.2 多版本并发控制( MVCC )"></a>3.2 多版本并发控制( MVCC )</h2><p>Mysql中的Innodb引擎，对<strong>读提交</strong>和<strong>可重复读</strong>这两个隔离级别的具体实现是通过MVCC(多版本并发控制)实现的。</p>
<h3 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h3><ul>
<li><p>解决了读写隔离性的问题（读提交，可重复读）。</p>
</li>
<li><p>在实际场景中读操作往往多于写操作，而读写操作又需要加锁来进行互斥完成，这不仅使得加大了锁带来的额外开销，还加大了死锁的风险。 因此就使用&lt;多版本&gt;的思想来使得读写操作不再互斥.</p>
</li>
<li><p>MVCC的实现的主要思想是：保存多版本的快照，使得每条记录的不同版本对不同事务而言，可见性不一样.</p>
</li>
</ul>
<h3 id="2-版本号"><a href="#2-版本号" class="headerlink" title="2. 版本号"></a>2. 版本号</h3><ul>
<li><p>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p>
</li>
<li><p>事务版本号 TRX_ID ：事务开始时的系统版本号（在一个事务中，首次进行增删改操作的时候，才会生成这个系统版本号！）。</p>
<ul>
<li>严格递增的事务版本号起到了”时间戳”的作用，从而能够辨别对某一行记录的操作相对于当前事务是提交前还是未提交还是未操作。</li>
</ul>
</li>
</ul>
<h3 id="3-Undo-日志"><a href="#3-Undo-日志" class="headerlink" title="3. Undo 日志"></a>3. Undo 日志</h3><ul>
<li><p>Innodb引擎会对每一条记录多增加三个属性用于mvcc，这三个属性分别是：</p>
<ul>
<li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引。</li>
<li>DB_TRX_ID：最近修改（更新/删除/插入）该记录的事务ID。</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本。</li>
<li></li>
</ul>
</li>
<li><p>MVCC 的多版本指的是多个版本的快照，每对一条记录进行增删改操作，就会生成一个快照存储到 Undo 日志中，在进行修改完值之后，还会修改其<code>DB_TRX_ID</code>属性为执行这条操作的事务ID，并修改<code>DB_ROLL_PTR</code>字段指向Undo log中刚刚保存的那条最新的旧记录，用于日后回滚（就是链表的头插法，每一个节点就是一个历史记录快照）。</p>
</li>
<li><p>MVCC通过db_roll_ptr来得到每一条记录在不同时期的历史版本，根据read_view来去对一行记录的每一个版本的trx_id字段进行可见性分析！！因此read_view决定了当前事务能够访问到哪个时期的这条记录！！ ！这也是实现<code>可重复读</code>和<code>读已提交</code>的不同之处的关键！！ 读已提交就是每次在执行select语句时，都会去主动获取最新的read_view，而可重复读则是在事务未结束之前都去使用最初获得的那个read_view！！<br>  <img src="https://img-blog.csdnimg.cn/20200417150322314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="4-read-view"><a href="#4-read-view" class="headerlink" title="4. read_view"></a>4. read_view</h3><p>执行查询sql时，会生成一个一致性视图read-view（一定要注意，只有在查询语句开始执行的时候，才会生成这个read-view！！执行任何查询语句都会产生！！），根据read_view来去遍历指定的记录每一个时期的版本，由此来决定应该选择哪一个时期的版本。</p>
<ul>
<li><h4 id="read-view维护的内容"><a href="#read-view维护的内容" class="headerlink" title="read_view维护的内容:"></a>read_view维护的内容:</h4><ul>
<li>当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}</li>
<li>TRX_ID_MIN: 未提交事务列表中的最小事务版本号</li>
<li>TRX_ID_MAX: 已创建的事务的最大事务版本号</li>
</ul>
</li>
<li><h4 id="可见性算法"><a href="#可见性算法" class="headerlink" title="可见性算法:"></a>可见性算法:</h4><ul>
<li><p>找出这一条记录对于当前事务而言的最新可见版本的方法（假设：对于某一条记录的版本A,  他的事务版本号为idx）：</p>
<ul>
<li>idx&lt;TRX_ID_MIN:<pre><code>**&lt;font color=red&gt;说明此版本对于当前事务来说是已经commit过的了.. 因此可见.&lt;/font&gt;**</code></pre></li>
<li>idx&gt;TRX_ID_MAX:<br>  <strong><font color=red>属于尚未进行的事务，不可见。</font></strong></li>
<li>TRX_ID_MIN&lt;=idx&lt;=TRX_ID_MAX:<br>  <strong><font color=red>如果idx不等于当前版本号且 idx在{尚未提交}的事务列表中，那么不可见;否则，可见.</font></strong></li>
</ul>
</li>
<li><h4 id="读提交"><a href="#读提交" class="headerlink" title="读提交:"></a>读提交:</h4><p>  每一次操作，都获取最新的read_view。</p>
</li>
<li><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读:"></a>可重复读:</h4><p>  在第一次操作时，获取read_view, 之后每次操作都使用这个read_view。</p>
</li>
<li><h4 id="删除的情况："><a href="#删除的情况：" class="headerlink" title="删除的情况："></a>删除的情况：</h4><ul>
<li>对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将其DB_TRX_ID修改成执行删除操作的事务ID，同时在该条记录的头信息里的deleted flag标记为true, 意味着该记录已经被删除。（在查询遍历时，如果发现delete flag为true，那么就意味着数据已被删除，则不返回数据）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-快照读-当前读"><a href="#5-快照读-当前读" class="headerlink" title="5. 快照读/当前读"></a>5. 快照读/当前读</h3><ul>
<li><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读:"></a>快照读:</h4>  上面介绍的这种mvcc通过read-view来进行的机制就是快照读。</li>
</ul>
<p><code>SELECT * FROM table ...;</code></p>
<ul>
<li><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读:"></a>当前读:</h4><ul>
<li>当前读是基于 临键锁（next-Key Lock）（行锁 Record Locks + 间歇锁 Gap Locks）来实现的，适用于 insert，update，delete， select … for update， select … lock in share mode 语句，以及加锁了的 select 语句。</li>
<li>更新数据时，都是先读后写，而这个读，就是当前读。读取数据时，读取该条数据的已经提交的最新的事务，生成的 readView。</li>
<li>例如事务 A 有2个 sql 语句，事务开始时生成 readView（id = n），第一个 sql 操作一条数据时读当前的 readView（id = n） 。此时开始事务B生成 readView（id = n + 1），并且对该条数据做了操作（非简单 select 操作）。事务A的第2个 sql 语句当前读该数据时，就会读取该数据的最新事务视图 readView (id =n + 1) 的值。</li>
<li>而假如事务A的第二个 sql 语句操作数据时，事务B还未提交（非简单 select 操作），那么该条数据此时被事务B的写锁锁住。事务A的第二个 sql 语句操作数据（非简单 select 操作），那么也要获取该条数据的锁。而此时锁被事务B持有，事务A就会阻塞，等待事务B释放锁。</li>
</ul>
</li>
</ul>
<h3 id="6-MVCC无法解决幻读"><a href="#6-MVCC无法解决幻读" class="headerlink" title="6. MVCC无法解决幻读"></a>6. MVCC无法解决幻读</h3><h4 id="1-举个例子："><a href="#1-举个例子：" class="headerlink" title="1. 举个例子："></a>1. 举个例子：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t Session A                  Session B</span><br><span class="line">|</span><br><span class="line">| START TRANSACTION;         START TRANSACTION;</span><br><span class="line">|</span><br><span class="line">| SELECT * FROM t_bitfly;</span><br><span class="line">| empty set</span><br><span class="line">|                            INSERT INTO t_bitfly</span><br><span class="line">|                            VALUES (1, &#39;a&#39;);</span><br><span class="line">|</span><br><span class="line">| SELECT * FROM t_bitfly;</span><br><span class="line">| empty set</span><br><span class="line">|                            COMMIT;</span><br><span class="line">|</span><br><span class="line">| SELECT * FROM t_bitfly;</span><br><span class="line">| empty set</span><br><span class="line">|</span><br><span class="line">| INSERT INTO t_bitfly VALUES (1, &#39;a&#39;);</span><br><span class="line">| ERROR 1062 (23000):</span><br><span class="line">| Duplicate entry &#39;1&#39; for key 1</span><br><span class="line">v (shit, 刚刚明明告诉我没有这条记录的)</span><br></pre></td></tr></table></figure>
<p>就是SessionA看不到B的提交，就没查出id=1的记录，于是再提交时就error了。</p>
<h4 id="2-Next-Key-Locks"><a href="#2-Next-Key-Locks" class="headerlink" title="2.  Next-Key Locks"></a>2.  Next-Key Locks</h4><ul>
<li><p><strong>Record Locks</strong> </p>
<ul>
<li>锁定一个记录上的索引，而不是记录本身。<br>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</li>
</ul>
</li>
<li><p><strong>Gap Locks</strong></p>
<ul>
<li>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</li>
</ul>
</li>
<li><p><strong>Next-Key Locks</strong></p>
<ul>
<li>它是Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，</li>
</ul>
</li>
</ul>
<h4 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h4><ul>
<li><p>屏蔽其他事务的提交影响是保证可重复读的关键； 但同时又是幻读产生的原因。</p>
</li>
<li><p>因此，mysql的innoDB提供的策略是：</p>
<ul>
<li>普通的读，会得到一致性的结果（屏蔽了其他事务的commit）;</li>
<li>如果使用了加锁的读，就会读到“最新的”“提交”读的结果；<br>结论：</li>
</ul>
</li>
<li><p>结论：MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。</p>
</li>
</ul>
<p><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h1><p>关于索引，<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=countdownlatch" target="_blank" rel="noopener">cs-note</a>其实总结的就非常好. 接下来我再补充一些.</p>
<h2 id="1-使用索引的注意事项？"><a href="#1-使用索引的注意事项？" class="headerlink" title="1. 使用索引的注意事项？"></a>1. 使用索引的注意事项？</h2><ol>
<li>在经常搜索的列上、经常出现在where中的列、经常需要排序的列上建立索引。</li>
<li>表非常非常大和表很小的情况下，不适合建索引，前者需要较大的维护开销，后者没有必要建立索引</li>
<li>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度； </li>
<li>在使用InnoDB时，应该使用与业务无关的自增主键作为主键索引，而不要使用业务主键。 因为，如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。</li>
<li>limit offset 查询比较慢的时候，也可以借助索引提高性能</li>
</ol>
<h2 id="2-创建索引需要注意什么？"><a href="#2-创建索引需要注意什么？" class="headerlink" title="2. 创建索引需要注意什么？"></a>2. 创建索引需要注意什么？</h2><ul>
<li><font color=brown><strong>选择合适的字段</strong></font><br>被频繁使用的非NULL字段，例如：被作为查询条件，被作为查询的列，被频繁用于连接的字段等等</li>
<li><font color=brown><strong>最左前缀原则</strong></font><br>创建联合索引的时候，尽量保证从左到右使用频率递减的顺序去创建.  因为创建了一个&lt;a,b,c&gt;的联合索引，相当于创建了&lt; a &gt;,  &lt;a,b&gt; , &lt;a,b,c&gt;这三个索引…  尽量保证 &lt; a &gt; ，&lt;a,b&gt; , &lt;a,b,c&gt;的使用频率都尽量的高。</li>
<li><font color=brown><strong>尽可能创建联合索引，而不是单列索引</strong></font></li>
</ul>
<p><strong>能创建联合索引，尽量创建联合索引，少创建单列索引</strong>，这是因为一个联合索引相当于创建了多个索引且对应一棵B+树，相比单个索引对应一颗B+树，对空间的利用率更高，间接的节省空间。</p>
<ul>
<li><font color=brown><strong>不适合创建索引的字段</strong></font><ul>
<li>频繁进行更新的字段 (因为索引的维护成本也是不小的)</li>
<li>不被经常查询的字段</li>
</ul>
</li>
<li><font color=brown><strong>避免冗余索引</strong></font><br>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</li>
</ul>
<h2 id="3-B树和B-树的区别"><a href="#3-B树和B-树的区别" class="headerlink" title="3. B树和B+树的区别"></a>3. B树和B+树的区别</h2><ol>
<li>B树的所有节点既存key，又存数据(data); 而B+树只有叶子节点存key和数据，非叶子节点只存key。</li>
<li>因为1的特性，B树在查找的时候在非叶子节点处就能够查找到想要的值，而B+树则是每次一定查找到叶子节点上。 </li>
<li>B树的叶子节点都是独立的，而B+树的叶子节点有一条引用链指向它相邻的叶子节点。</li>
</ol>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="唯一索引和非唯一索引的区别"><a href="#唯一索引和非唯一索引的区别" class="headerlink" title="唯一索引和非唯一索引的区别"></a>唯一索引和非唯一索引的区别</h2><p>非聚集索引又分唯一非聚集索引和非唯一两种，这同样是依据业务逻辑而定的，唯一非聚集索引指的是一个由多个业务字段组成的索引，在业务逻辑上是唯一的，反之就是非唯一的非聚集索引。比如“中国+身份证号”，这就是一个唯一索引，因为中国的每个身份证号理论上都是唯一的。而“中国+姓名”则是一个非聚集索引，因为中国又很多重名的人。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>由mysql的默认隔离级别引出的几个问题</title>
    <url>/2020/07/10/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>讲讲mysql有几个隔离级别？</li>
<li>mysql的默认隔离级别是哪个？</li>
<li>你们项目中选了哪个隔离级别，为什么？</li>
</ul>
<p>这上面三个问题是面美团的时候被问到的。。前两个还好。。第三个让我有点摸不着头脑。。查了些资料之后就记录一下这个问题吧</p>
<a id="more"></a>

<h1 id="Q1-MySQL有几个隔离级别"><a href="#Q1-MySQL有几个隔离级别" class="headerlink" title="Q1: MySQL有几个隔离级别"></a>Q1: MySQL有几个隔离级别</h1><p>送分题… 读未提交，读提交，可重复读，串行化</p>
<h1 id="Q2-Mysql的默认隔离级别是哪个？"><a href="#Q2-Mysql的默认隔离级别是哪个？" class="headerlink" title="Q2: Mysql的默认隔离级别是哪个？"></a>Q2: Mysql的默认隔离级别是哪个？</h1><p>送分题… mysql默认是可重复读，但oracle等其他的几个默认好像都是读提交…</p>
<p>而mysql默认是可重复也是有历史原因的，mysql的主从一致性是会通过binlog来做，而早期的mysql的binlog仅支持statement模式，因为保存的是执行的命令，在RC级别下可能会导致主从不一致，而这一问题在RR级别下就能够得到解决，所以就一直默认的使用RR级别</p>
<p><a href="https://www.cnblogs.com/shoshana-kong/p/10516404.html" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="Q3-你们项目中选了哪个隔离级别，为什么？"><a href="#Q3-你们项目中选了哪个隔离级别，为什么？" class="headerlink" title="Q3: 你们项目中选了哪个隔离级别，为什么？"></a>Q3: 你们项目中选了哪个隔离级别，为什么？</h1><p>= = 作为一个零项目的蒟蒻，虽然答不上来自己的项目里使用了哪个隔离级别，但可以说一下一般会使用哪个隔离级别。。</p>
<p>如果没有RR（可重复读）的需求的话，能使用RC还是使用RC（读提交）。。</p>
<p>有以下几个原因：</p>
<h2 id="原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多"><a href="#原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多" class="headerlink" title="原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多"></a><font color=red><em>原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多</em></font></h2><p>这里说一个间隙锁导致死锁的例子：</p>
<ol>
<li>事务A使用间隙锁锁住了Id为(1,5)的索引， 然后插入一条id=8的记录</li>
<li>然后在尝试插入一条id=8的记录前发生了调度，轮到事务B去执行</li>
<li>事务B锁住了id为(6,10)的索引，然后尝试插入一条id=3的记录，然因为被事务A锁住了，所以等待</li>
<li>事务A又获得了执行权，开始执行插入id=8的记录，但因为id属于(6,10)的这个区间被事务B锁住了，所以等待事务B</li>
<li>事务B等事务A，事务A等事务B，死锁发生了..</li>
</ol>
<p><strong>而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！</strong></p>
<p><strong>ps:在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！</strong></p>
<h2 id="原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行"><a href="#原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行" class="headerlink" title="原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行"></a><font color=red><em>原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</em></font></h2><p>在RC隔离级别下，如果走聚簇索引进行全表扫描的时候，实际操作中，MySQL进行了改进，在进行过滤条件时，<strong>发现不满足条件后，会调用 unlock_row 方法，把不满足条件的记录放锁</strong> ， 即<strong>锁的粒度是行锁</strong>！</p>
<p>但是！！在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，锁的粒度是<strong>表级锁</strong>！！</p>
<p><a href="https://www.csdn.net/gather_2b/MtTaEg5sMzM4Ny1ibG9n.html" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="原因三：在RC隔离级别下，半一致性读-semi-consistent-特性增加了update操作的并发性"><a href="#原因三：在RC隔离级别下，半一致性读-semi-consistent-特性增加了update操作的并发性" class="headerlink" title="*原因三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性"></a><font color=red><em>*原因三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性</em></font></h2><p>在RC隔离级别或者innodb_locks_unsafe_for_binlog被设置为true，并发时，如果update的记录发生锁等待，那么返回该记录的prev 版本（在返回前会将锁等待的这个lock从trx中删除掉），到mysql层进行where判断，是否满足条件。如果满足where条件，那么再次进入innodb层，真正加锁或者发生锁等待。</p>
<p>这样做的好处是：减少同一行记录的锁冲突及锁等待；无并发冲突时，直接读取最新版本加锁，有冲突时，不加锁，读取prev版本不需要锁等待。</p>
<p>缺点：非冲突串行话策略，对于binlog来说是不安全的。只能发生在RC隔离级别和innodb_lock_unsafe_for_binlog下。</p>
<p><a href="https://blog.51cto.com/yanzongshuai/2106100" target="_blank" rel="noopener">参考链接</a></p>
<hr>
<p><strong>其实Q3感觉说前两个原因就行了，第三个原因了解下吧.. 因为并不是在RC级别下特有的，设置innodb_locks_unsafe_for_binlog=true好像也可..</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>new一个对象的过程</title>
    <url>/2020/07/10/new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><h2 id="1-JVM运行时数据区域"><a href="#1-JVM运行时数据区域" class="headerlink" title="1. JVM运行时数据区域"></a>1. JVM运行时数据区域</h2><p><img src="https://img-blog.csdnimg.cn/20200420230040176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200420230058849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-1-方法区"><a href="#1-1-方法区" class="headerlink" title="1.1 方法区"></a>1.1 方法区</h3><h4 id="方法区存放了什么？"><a href="#方法区存放了什么？" class="headerlink" title="方法区存放了什么？"></a>方法区存放了什么？</h4><p>方法区主要存放的内容有：</p>
<ul>
<li><font color=blue>常量池</font></li>
<li><font color=blue>被虚拟机加载的类的信息</font>，比如方法名字，类的名字，父类、接口以及一些静态变量，静态方法等。</li>
<li>一些即时编译器编译的代码数据、常量。</li>
</ul>
<h4 id="方法区的实现"><a href="#方法区的实现" class="headerlink" title="方法区的实现"></a>方法区的实现</h4><ul>
<li><p>jdk1.6及之前，方法区是完全由永久代实现的；</p>
</li>
<li><p>在jdk1.7时，将方法区的常量池放到了堆中进行实现；</p>
</li>
<li><p>在jdk1.8时，引入了元空间（MetaSpace）进行实现；运行时常量池和静态变量都存储到了堆中，MetaSpace存储类的元数据，MetaSpace直接申请在本地内存中（Native memory）,这样类的元数据分配只受本地内存大小的限制,OOM问题就不存在了。<font color=red>元空间的出现就是为了解决突出的类和类加载器元数据过多导致的OOM问题</font>，而从jdk7中开始永久代经过对方法区的分裂后已经几乎只存储类和类加载器的元数据信息了，到了jdk8，元空间中也是存储这些信息</p>
</li>
</ul>
<h3 id="1-2-堆"><a href="#1-2-堆" class="headerlink" title="1.2 堆"></a>1.2 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放<font color=red>对象实例</font>，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。<br><code>java -Xms1M -Xmx2M HackTheJava</code></p>
<h3 id="1-3-虚拟机栈"><a href="#1-3-虚拟机栈" class="headerlink" title="1.3 虚拟机栈"></a>1.3 虚拟机栈</h3><p><img src="https://img-blog.csdnimg.cn/20200420234500766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚拟机栈是线程私有的区域。它的生命周期和线程相同，<strong>描述的是 Java 方法执行的内存模型</strong>，每次方法调用的数据都是通过栈传递的。 其主要由栈桢构成，栈桢中主要包括:</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>出口信息等</li>
</ul>
<p>如果栈桢的深度过深的话，会抛出<code>StackOverFlowError</code>  在调用Java方法时，会压入一个栈祯，当方法结束时，会弹出一个栈祯；方法结束的形式：</p>
<ul>
<li>return</li>
<li>throw异常</li>
</ul>
<h3 id="1-4-本地方法栈"><a href="#1-4-本地方法栈" class="headerlink" title="1.4 本地方法栈"></a>1.4 本地方法栈</h3><p>本地方法栈也是线程私有的区域。功能和虚拟机栈类似，不过本地方法栈主要用于服务<code>native</code>方法。本地方法栈也有栈祯，存储的内容与虚拟机栈的栈祯类似。</p>
<h3 id="1-5-程序计数器"><a href="#1-5-程序计数器" class="headerlink" title="1.5 程序计数器"></a>1.5 程序计数器</h3><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h2 id="2-对象实例在内存中的存在形式"><a href="#2-对象实例在内存中的存在形式" class="headerlink" title="2. 对象实例在内存中的存在形式"></a>2. 对象实例在内存中的存在形式</h2><p>在堆中的对象实例主要由三部分构成：</p>
<h3 id="第一部分：对象头："><a href="#第一部分：对象头：" class="headerlink" title="第一部分：对象头："></a>第一部分：对象头：</h3><ul>
<li>Mark Word：<br>  <img src="https://img-blog.csdnimg.cn/20200420235636690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>指向对象的引用指针</li>
<li>如果是数组类型的话，还有一个数组长度字段</li>
</ul>
<h3 id="第二部分：对象实例数据"><a href="#第二部分：对象实例数据" class="headerlink" title="第二部分：对象实例数据"></a>第二部分：对象实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<h3 id="第三部分：对齐填充"><a href="#第三部分：对齐填充" class="headerlink" title="第三部分：对齐填充"></a>第三部分：对齐填充</h3><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<hr>
<h1 id="二、new一个对象的过程"><a href="#二、new一个对象的过程" class="headerlink" title="二、new一个对象的过程"></a>二、new一个对象的过程</h1><h2 id="第一步：-类加载"><a href="#第一步：-类加载" class="headerlink" title="第一步： 类加载"></a><font color=red>第一步： 类加载<font></h2><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<strong>下面为一个类的加载过程。</strong></p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.  加载"></a>1.  加载</h3><ul>
<li>找字节流<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
</ul>
</li>
<li>创建类<ul>
<li>将该字节流表示的静态存储结构 转换为 方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。注意，这个对象是在堆区的！</li>
</ul>
</li>
</ul>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2.  链接"></a>2.  链接</h3><ul>
<li><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>用于确保加载类能够满足java虚拟机的约束条件</li>
</ul>
</li>
<li><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li>为类中的static变量分配内存，并清空这块内存（即尚未尽心给初始化），使用的是方法区的内存。</li>
</ul>
</li>
<li><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ul>
<li><p>符号引用转换成实际引用，如果符号引用指向的类未被加载，则加载这个类( 但未必进行类的链接及初始化 )</p>
</li>
<li><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定</p>
<ul>
<li><p><font size=5><strong>静态绑定</strong></font>：</p>
<ul>
<li><p>在类加载的解析阶段，会把符号引用转换成直接引用.</p>
</li>
<li><p>类A中调用讲台方法B.f()的转换过程为:</p>
<ul>
<li><p><code>1.invokestatic #index</code></p>
<p>  index是一个数字, 指在类的A的常量池中第index个索引的常量表( 这个常量表表述了B.f()的信息 )，得到符号引用。</p>
</li>
<li><p>2.然后根据这个常量表找到对应类(这里是类B), 如果该类未被加载，则加载, 链接, 初始化该类</p>
</li>
<li><p>3.找到目标方法后，将这个直接地址（B.f()的直接地址）记录到类A的常量池索引为index的常量表中。这个过程叫常量池解析 ，以后再次调用B.f()时，将直接找到 f（）方法的字节码。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font size=5><strong><a href="http://hxraid.iteye.com/blog/428891" target="_blank" rel="noopener">动态绑定</a></strong></font>：</p>
<ul>
<li><p>对于非静态非私有非final的方法, 则采用动态绑定.</p>
</li>
<li><p>如果说静态绑定是一劳永逸，那么动态绑定则是在运行时，每一次的方法调用都动态的去寻找目标方法位置.  </p>
</li>
<li><p>在JVM加载类的同时，会在方法区中为这个类存放很多信息。其中就有一个数据结构叫方法表。它以数组的形式记录了当前类及其所有超类的可见方法字节码在内存中的直接地址 。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>下面来根据例子来讲一下过程，假设 Father是个接口，Son实现了Father，`Father father = new Son();` 然后再调用`father.f()` 的时候， 这一调用发生在类C中.

- 动态绑定的过程:
    - `invokevirtual #index`
    - 这个index是`f()`在当前调用类(这里是类C) 的常量池中对应的第index个常量表（这个常量表描述了调用方法），然后根据起描述内容，就能找到Father类，然后去Father类里找到`f()`在方法表里的偏移量#offset, 得到偏移量之后，再去`Son`的方法表里用相同的#offset去找，就能够调用方法`f()`了, 原因是: 
        1.  子类方法表中继承了父类的方法
        2.  相同的方法(相同的方法签名：方法名和参数列表)在所有类的方法表中的索引相同。比如Father方法表中的f1()和Son方法表中的f1()都位于各自方法表的第11项中。（Son继承了Father）
 - 然后就完成了动态绑定.

 - 这里小结一下, #index找到类符号引用，然后找到了`Father`类，然后去`Father`类里找到了对应方法在方法表里的偏移量，然后在这个对象真正的类的方法表里去用这个偏移量来查方法!  

 - 动态绑定-&gt; 相同的方法偏移量，不同的方法表

 - 动态绑定: 保存方法偏移量, 然后去方法表里找. 静态绑定: 保存方法地址，直接访问到方法, 不需要查表. 

 - 往往在invokevirtual #index之前，都会有预先根据这个对象在堆里的信息，来得到这个对象的真正类！然后就得到了这个真正的类的方法表!

 - 正是因为上面两条，再加上运行时动态翻译符号引用，就实现了多态.(目前的理解)</code></pre><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h3><p>注意，此时还是类加载阶段，并不涉及到对象，因此这里进行的初始化的，都是类里的static变量!  都是在方法区里的！</p>
<ul>
<li><h4 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h4><p>在静态字段中，如果被final修饰的字段被赋值，并且它的类型是基本类型或Stiring类型时，那么该字段会被Java编译器标记成常量值，其初始化直接由Java虚拟机完成！</p>
</li>
<li><h4 id="非常量的初始化"><a href="#非常量的初始化" class="headerlink" title="非常量的初始化"></a>非常量的初始化</h4><p>所有非常量初始化的赋值操作，会被统一放到<code>&lt;clinit&gt;</code> 方法的方法体中，然后统一执行。。Java虚拟机会通过加锁来保证<code>&lt;clinit&gt;()</code>只执行一次. </p>
</li>
<li><h4 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h4><ul>
<li><p><font size=5 color=brown>主动引用</font></p>
<ul>
<li>虚拟机启动时，初始化用户指定的主类(Main)</li>
<li>遇到new</li>
<li>遇到调用静态方法 或 访问静态字段, 则初始化对应静态方法/字段所在的类</li>
<li>子类的初始化触发父类的初始化</li>
<li>假设一个接口A定义了<code>default</code>方法，如果类B实现了该接口，且类B初始化了，那么会触发接口A的初始化</li>
<li>使用反射API对某个类进行反射调用，则初始化这个类</li>
<li><strong>初次调用</strong> <code>MethodHandle</code>实例时，初始化该<code>MethodHandle</code>指向的方法所在类.<br/></li>
</ul>
</li>
<li><p><font size=5 color=brown>被动引用</font></p>
<ul>
<li><p><strong>被动引用不会触发初始化!</strong></p>
</li>
<li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二步：-为对象分配内存空间"><a href="#第二步：-为对象分配内存空间" class="headerlink" title="第二步： 为对象分配内存空间"></a><font color=red>第二步： 为对象分配内存空间<font></h2><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p>
<h2 id="第三步：初始化0值"><a href="#第三步：初始化0值" class="headerlink" title="第三步：初始化0值"></a><font color=red>第三步：初始化0值<font></h2><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</p>
<h2 id="第四步：设置对象头"><a href="#第四步：设置对象头" class="headerlink" title="第四步：设置对象头"></a><font color=red>第四步：设置对象头<font></h2><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h2 id="第五步：执行-lt-init-gt"><a href="#第五步：执行-lt-init-gt" class="headerlink" title="第五步：执行&lt;init&gt;"></a><font color=red>第五步：执行<code>&lt;init&gt;</code><font></h2><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<hr>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://www.jianshu.com/p/576fdfa1e39b" target="_blank" rel="noopener">史上最详细Java内存区域讲解</a></p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载/多态原理/对象创建</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>redis主从同步学习</title>
    <url>/2020/07/10/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="单机Redis的瓶颈"><a href="#单机Redis的瓶颈" class="headerlink" title="单机Redis的瓶颈"></a>单机Redis的瓶颈</h1><ul>
<li>容量瓶颈( 单台Redis提供的容量有限 )</li>
<li>QPS瓶颈( 单台Redis能提供的有限 )</li>
<li>机械故障( 单台redis无法保证高可用 )</li>
</ul>
<h1 id="主从复制的约定"><a href="#主从复制的约定" class="headerlink" title="主从复制的约定"></a>主从复制的约定</h1><ul>
<li>一个master可以有多个slave</li>
<li>一个slave只能用一个master</li>
<li>数据流向是<strong>单向</strong>的，master到slave （所以要求一般slave是read-only的，不然就无法保证主从一致性了）</li>
</ul>
<a id="more"></a>

<h1 id="主从配置的两种方式"><a href="#主从配置的两种方式" class="headerlink" title="主从配置的两种方式"></a>主从配置的两种方式</h1><h2 id="slaveof命令（运行中执行）"><a href="#slaveof命令（运行中执行）" class="headerlink" title="slaveof命令（运行中执行）"></a>slaveof命令（运行中执行）</h2><p>例如，机器A的ip为ipA, 机器B的ip为ipB，机器A上的redis作为slave，机器B的redis作为master，如果希望机器A对机器B的redis进行一个主从配置/复制同步的话，那么就在机器A上执行： <code>slaveof ipB:port</code> （机器A的redis执行完该命令之后，会对机器A的redis进行一个清楚，然后进行数据同步）</p>
<p>如果不再让机器A作为机器B的slave的话，可以执行 <code>slaveof no one</code>来断开主从关系(即使断开了主从关系，过去同步的数据依然不会清楚)</p>
<h2 id="配置（启动执行）"><a href="#配置（启动执行）" class="headerlink" title="配置（启动执行）"></a>配置（启动执行）</h2><p>可以在配置文件中加入如下命令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">slaveof ip port <span class="comment">// 表示作为哪一个节点的从节点</span></span><br><span class="line">slave-<span class="built_in">read</span>-only yes <span class="comment">// 表示当前从节点是read-only的</span></span><br><span class="line">masterauth [password]  <span class="comment">// 如果master有密码的话，那么需要设置master的密码</span></span><br></pre></td></tr></table></figure>

<p>(ps：在master的配置文件中，requirepass [password] 来设置密码)<br>(pps: 在redis中，auth password 用于验证身份， info replication查看主从状态)</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>命令</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>无需重启</td>
<td>统一配置,方便管理</td>
</tr>
<tr>
<td>缺点</td>
<td>不方便管理</td>
<td>需要重启</td>
</tr>
</tbody></table>
<hr>
<h1 id="Redis主从模式下的几个问题"><a href="#Redis主从模式下的几个问题" class="headerlink" title="*Redis主从模式下的几个问题"></a>*Redis主从模式下的几个问题</h1><h2 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h2><ul>
<li><p>读写分离：读流量分摊到从节点<br><img src="https://img-blog.csdnimg.cn/20200615153811154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="读写分离的问题："><a href="#读写分离的问题：" class="headerlink" title="读写分离的问题："></a>读写分离的问题：</h3></li>
<li><p><strong>复制数据延迟</strong>（解决延迟代价很高）</p>
</li>
<li><p><strong>读到过期的数据</strong></p>
<p>  redis在清理过期数据时，有一个方式是懒惰删除，即在获取这个key的时候检查是否过期，若过期则删除，而又由于从节点无法主动删除数据（read-only）, 所以如果master没有及时把过期数据告诉slave的话可能会造成脏读，redis3.2之后解决了这个问题。</p>
</li>
<li><p><strong>从节点故障</strong></p>
<p>  将从节点上的客户端进行迁移，成本较高。</p>
<h2 id="2-主从配置不一致"><a href="#2-主从配置不一致" class="headerlink" title="2. 主从配置不一致"></a>2. 主从配置不一致</h2></li>
<li><p><strong>例如maxmemory不一致，导致主从不一致</strong></p>
<h2 id="3-规避全量复制"><a href="#3-规避全量复制" class="headerlink" title="3. 规避全量复制"></a>3. 规避全量复制</h2></li>
</ul>
<ol>
<li><p><strong>第一次全量复制</strong></p>
<p> 第一次全量复制不可能避免（减少分片maxmemory,  在低峰的时候进行）</p>
</li>
<li><p><strong>节点运行ID不匹配</strong></p>
<p> redis每次启动时，会有一个run_id，slave会保存master的run_id, 如果master的run_id发生了变化的话，那么就会触发一个全量复制。</p>
</li>
<li><p><strong>复制积压缓冲区不足</strong></p>
<h2 id="4-规避复制风暴"><a href="#4-规避复制风暴" class="headerlink" title="4. 规避复制风暴"></a>4. 规避复制风暴</h2></li>
</ol>
<hr>
<h1 id="主从复制流程"><a href="#主从复制流程" class="headerlink" title="主从复制流程"></a>主从复制流程</h1><h2 id="run-id-："><a href="#run-id-：" class="headerlink" title="run_id ："></a><strong>run_id</strong> ：</h2><p>Redis每次启动时，都有一个随机ID来标识Redis,这个随机ID就是上面通过info命令查看得到的run_id， 查看master节点上的run_id和偏移量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# redis-cli info server | grep run_id</span><br><span class="line">run_id:7e366f6029d3525177392e98604ceb5195980518</span><br><span class="line">[root@localhost ~]# redis-cli info | grep master_repl_offset</span><br><span class="line">master_repl_offset:0</span><br></pre></td></tr></table></figure>
<h2 id="offset"><a href="#offset" class="headerlink" title="offset:"></a>offset:</h2><p>偏移量(offset)就是数据写入量的字节数。</p>
<p>在master节点的Redis上写入数据时，master就会记录写了多少数据，并记录在偏移量中。</p>
<p>在master上的操作，会同步到salve机器上，slave上的Redis也会记录偏移量。</p>
<p>当两台机器上的偏移量相同时，代表数据同步完成</p>
<p>偏移量是部分复制很重要的依据</p>
<p>查看Redis的偏移量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication    # 查看复制信息</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;192.168.81.101,port&#x3D;6379,state&#x3D;online,offset&#x3D;8602,lag&#x3D;0</span><br><span class="line">master_repl_offset:8602             # 此时192.168.81.100上的偏移量是8602</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:8601</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication    # 查看复制信息</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;192.168.81.101,port&#x3D;6379,state&#x3D;online,offset&#x3D;8759,lag&#x3D;1</span><br><span class="line">master_repl_offset:8759             # 写入数据后192.168.81.100上的偏移量是8759</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:8758</span><br></pre></td></tr></table></figure>

<p><font color=red>master的run_id的改变会触发全量复制</font></p>
<p><font color=red>主从的offset相等则说明一致</font></p>
<h2 id="psync-run-id-offset"><a href="#psync-run-id-offset" class="headerlink" title="psync [run_id] [offset]"></a>psync [run_id] [offset]</h2><p>表示需要让run_id的redis将offset之后的数据同步给当前节点..</p>
<h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ul>
<li>master的全部数据同步到slave</li>
<li>master在进行同步期间写的数据也同步到slave</li>
</ul>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><p><strong>1. slave -&gt; master:</strong></p>
<p>slave向master发送一个<code>psync ？ -1</code>的命令， 因为第一次不知道master节点的run_id和offset，所以传的是？和-1 </p>
<p><strong>2. master -&gt; slave:</strong></p>
<p>返回 master 的 run_id 和 offset</p>
<p><strong>3. slave保存master传来的信息</strong></p>
<p><strong>4. master 进行一个bgsave，生成RDB文件</strong></p>
<p><strong>5. master -&gt; slave:</strong></p>
<p><strong>传输RDB文件</strong>（全量备份），传输期间会把“write”的信息存到一个buffer中（repl_back_buffer），这部分就是在传输期间会导致不一致的数据，在传输完RDB之后会传输这部分消息</p>
<p><strong>6. master -&gt; slave:</strong></p>
<p><strong>传输buffer中的数据</strong>（增量备份）</p>
<p><strong>7. salve清除旧的数据，写入新数据</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200615164603150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="全量复制的开销"><a href="#全量复制的开销" class="headerlink" title="全量复制的开销"></a>全量复制的开销</h3><ol>
<li>bgsave的开销 （master）</li>
<li>RDB文件进行网络传输的时间 （master）</li>
<li>slave清空数据（slave）</li>
<li>slave加载RDB数据（slave）</li>
<li>可能的AOF重写时间 （slave加载完RDB之后，如果开启了AOF，那么会进行一个AOF重写）</li>
</ol>
<h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p>全量复制开销太大， 在没有必要使用全量复制的时候就可以使用部分复制来做.</p>
<p>部分复制其实还是<code>psync [run_id] [offset]</code> , 通知run_id对应的redis把offset之后的数据都同步过来。。master节点在收到这个指令之后，会去查看能否响应这个offset之后的数据（看这个offset是否在维护的范围内），如果可以响应，那么就将offset后的部分数据同步给slave..</p>
<p><img src="https://img-blog.csdnimg.cn/20200615170210883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis主从</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础学习</title>
    <url>/2020/07/10/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="redis的数据结构以及使用场景分析"><a href="#redis的数据结构以及使用场景分析" class="headerlink" title="redis的数据结构以及使用场景分析"></a>redis的数据结构以及使用场景分析</h1><h2 id="1-string"><a href="#1-string" class="headerlink" title="1. string"></a>1. string</h2><h3 id="a-底层结构"><a href="#a-底层结构" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>string的数据结构存储的是key-value类型, value不仅可以是string，也可以是数字。</p>
<p>redis中的String是可以修改的，称为动态字符串（SDS），其实就是维护了一个预分配的字节数组，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&#123;</span></span><br><span class="line">	T capacity;       <span class="comment">//数组容量</span></span><br><span class="line">  	T len;            <span class="comment">//实际长度</span></span><br><span class="line">  	<span class="keyword">byte</span> flages;  <span class="comment">//标志位,低三位表示类型</span></span><br><span class="line">  	<span class="keyword">byte</span>[] content;   <span class="comment">//数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="b-常用命令"><a href="#b-常用命令" class="headerlink" title="b. 常用命令"></a>b. 常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set   [key]  [value]   给指定key设置值（set 可覆盖老的值）</span><br><span class="line"> </span><br><span class="line">get  [key]   获取指定key 的值</span><br><span class="line"> </span><br><span class="line">del  [key]   删除指定key</span><br><span class="line"> </span><br><span class="line">exists  [key]  判断是否存在指定key</span><br><span class="line"> </span><br><span class="line">mset  [key1]  [value1]  [key2]  [value2] ...... 批量存键值对</span><br><span class="line"> </span><br><span class="line">mget  [key1]  [key2] ......   批量取key</span><br><span class="line"> </span><br><span class="line">expire [key]  [time]    给指定key 设置过期时间  单位秒</span><br><span class="line"> </span><br><span class="line">setex    [key]  [time]  [value]  等价于 set + expire 命令组合</span><br><span class="line"> </span><br><span class="line">setnx  [key]  [value]   如果key不存在则set 创建，否则返回0</span><br><span class="line"> </span><br><span class="line">incr   [key]           如果value为整数 可用 incr命令每次自增1</span><br><span class="line"> </span><br><span class="line">incrby  [key] [number]  使用incrby命令对整数值 进行增加 number</span><br></pre></td></tr></table></figure>


<h3 id="c-使用场景举例"><a href="#c-使用场景举例" class="headerlink" title="c. 使用场景举例"></a>c. <strong>使用场景举例</strong></h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>简单key-value存储</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>setnx key value，当key不存在时，将 key 的值设为 value ，返回1</p>
<p>若给定的 key 已经存在，则setnx不做任何动作，返回0。</p>
<p>当setnx返回1时，表示获取锁，做完操作以后del key，表示释放锁，如果setnx返回0表示获取锁失败，整体思路大概就是这样</p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>如知乎每个问题的被浏览器次数</p>
<h4 id="全局标志位"><a href="#全局标志位" class="headerlink" title="全局标志位"></a>全局标志位</h4><p>例如售罄标志，防止超卖</p>
<h2 id="2-hash"><a href="#2-hash" class="headerlink" title="2. hash"></a>2. hash</h2><h3 id="a-底层结构-1"><a href="#a-底层结构-1" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的Hash和 <strong>Java的HashMap更加相似</strong>，都是<font color=red><strong>数组+链表</strong></font>的结构，当发生 hash 碰撞时将会把元素追加到链表上，下面是hash存储的一个KV结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key&#x3D;JavaUser293847</span><br><span class="line">value&#x3D;&#123;</span><br><span class="line">  “id”: 1,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: 22,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（可以看作是 map&lt; key, map&lt;key, value&gt; &gt;）</p>
<h3 id="b-常用指令"><a href="#b-常用指令" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hset  [key]  [field] [value]    新建字段信息</span><br><span class="line"> </span><br><span class="line">hget  [key]  [field]    获取字段信息</span><br><span class="line"> </span><br><span class="line">hdel [key] [field]  删除字段</span><br><span class="line"> </span><br><span class="line">hlen  [key]   保存的字段个数</span><br><span class="line"> </span><br><span class="line">hgetall  [key]  获取指定key 字典里的所有字段和值 （字段信息过多,会导致慢查询 慎用：亲身经历 曾经用过这个这个指令导致线上服务故障）</span><br><span class="line"> </span><br><span class="line">hmset  [key]  [field1] [value1] [field2] [value2] ......   批量创建</span><br><span class="line"> </span><br><span class="line">hincr  [key] [field]   对字段值自增</span><br><span class="line"> </span><br><span class="line">hincrby [key] [field] [number] 对字段值增加number</span><br></pre></td></tr></table></figure>

<h3 id="c-应用场景"><a href="#c-应用场景" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>可以存储对象（ (对象名，成员变量名，值) ）</p>
<h2 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h2><h3 id="a-底层结构-2"><a href="#a-底层结构-2" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的list和Java中的LinkedList很像，底层都是一种链表结构，list的插入和删除操作非常快，时间复杂度为 0(1)，不像数组结构插入、删除操作需要移动数据。</p>
<p>像归像，但是redis中的list底层可不是一个双向链表那么简单。</p>
<p>在redis3.2版本之前，对list的实现是：</p>
<ul>
<li>当数据量较少的时候它的底层存储结构为一块连续内存，称之为ziplist(压缩列表)，它将所有的元素紧挨着一起存储，分配的是一块连续的内存；(保存的是entry数组)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">    int32 zlbytes;            <span class="comment">//压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset;    <span class="comment">//最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength;            <span class="comment">//元素个数</span></span><br><span class="line">    T[] entries;            <span class="comment">//元素内容</span></span><br><span class="line">    int8 zlend;                <span class="comment">//结束位 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>当数据量较多的时候，它的底层结构是使用linkedlist来做的，是离散的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表长度</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>


<p>重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。<br>quicklist其实就是又对linkedlist和ziplist进行了一层抽象，变为quicklistnode, 它可以指向压缩后的list，也可以指向未压缩的list, 如下图<br><img src="https://img-blog.csdnimg.cn/20200612103952646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;        <span class="comment">// 指向quicklist的头部</span></span><br><span class="line">    quicklistNode *tail;        <span class="comment">// 指向quicklist的尾部</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">// 列表中所有数据项的个数总和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">// quicklist节点的个数，即ziplist的个数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : <span class="number">16</span>;              <span class="comment">// ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">// 节点压缩深度设置，由list-compress-depth给定</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向上一个ziplist节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个ziplist节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// 表示指向ziplist结构的总长度(内存占用长度)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// 表示ziplist中的数据项个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 编码方式，1--ziplist，2--quicklistLZF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// 预留字段，存放数据的方式，1--NONE，2--ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试相关</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">// 扩展字段，暂时没用</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<h3 id="b-常用指令-1"><a href="#b-常用指令-1" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpush  [key] [value1] [value2] ......    链表右侧插入</span><br><span class="line"> </span><br><span class="line">rpop    [key]  移除右侧列表头元素，并返回该元素</span><br><span class="line"> </span><br><span class="line">lpop   [key]    移除左侧列表头元素，并返回该元素</span><br><span class="line"> </span><br><span class="line">llen  [key]     返回该列表的元素个数</span><br><span class="line"> </span><br><span class="line">lrem [key] [count] [value]  删除列表中与value相等的元素，count是删除的个数。 count&gt;0 表示从左侧开始查找，删除count个元素，count&lt;0 表示从右侧开始查找，删除count个相同元素，count&#x3D;0 表示删除全部相同的元素</span><br><span class="line"> </span><br><span class="line">(PS:   index 代表元素下标，index 可以为负数， index&#x3D; 表示倒数第一个元素，同理 index&#x3D;-2 表示倒数第二 个元素。)</span><br><span class="line"> </span><br><span class="line">lindex [key] [index]  获取list指定下标的元素 （需要遍历，时间复杂度为O(n)）</span><br><span class="line"> </span><br><span class="line">lrange [key]  [start_index] [end_index]   获取list 区间内的所有元素 （时间复杂度为 O（n））</span><br><span class="line"> </span><br><span class="line">ltrim  [key]  [start_index] [end_index]   保留区间内的元素，其他元素删除（时间复杂度为 O（n））</span><br></pre></td></tr></table></figure>

<h3 id="c-应用场景-1"><a href="#c-应用场景-1" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>由于list它是一个按照插入顺序排序的列表，所以应用场景相对还较多的，例如：</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能<br><img src="https://img-blog.csdnimg.cn/20200612112455562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="朋友圈用户消息列表"><a href="#朋友圈用户消息列表" class="headerlink" title="朋友圈用户消息列表"></a>朋友圈用户消息列表</h4><p>例如想拿最近发得10条动态，就可以使用 lrange 来拿</p>
<h2 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. set</h2><h3 id="a-底层结构-3"><a href="#a-底层结构-3" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的set和Java中的HashSet有些类似，它内部的键值对是<strong>无序的、唯一</strong> 的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值 NULL。当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。</p>
<h3 id="b-常用指令-2"><a href="#b-常用指令-2" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd  [key]  [value]  向指定key的set中添加元素</span><br><span class="line"> </span><br><span class="line">smembers [key]    获取指定key 集合中的所有元素</span><br><span class="line"> </span><br><span class="line">sismember [key] [value]   判断集合中是否存在某个value</span><br><span class="line"> </span><br><span class="line">scard [key]    获取集合的长度</span><br><span class="line"> </span><br><span class="line">spop  [key]   弹出一个元素</span><br><span class="line"> </span><br><span class="line">srem [key] [value]  删除指定元素</span><br><span class="line"></span><br><span class="line">sinterstore key1 key2 key3     将交集存在key1内</span><br></pre></td></tr></table></figure>

<h4 id="d-高频指令"><a href="#d-高频指令" class="headerlink" title="d. 高频指令"></a>d. 高频指令</h4><p>求交集：<code>sinterstore key1 key2 key3</code>   将交集存在key1内</p>
<h3 id="c-应用场景-2"><a href="#c-应用场景-2" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好、共同好友等功能。这个过程也就是求交集的过程。<br>（关键字：共同）</p>
<h2 id="5-zset-sorted-set"><a href="#5-zset-sorted-set" class="headerlink" title="5. zset ( sorted set )"></a>5. zset ( sorted set )</h2><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</p>
<h3 id="a-底层结构-4"><a href="#a-底层结构-4" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>zset是基于skiplist(<a href="https://www.jianshu.com/p/cc379427ef9d" target="_blank" rel="noopener">跳表</a>)实现的。</p>
<h3 id="b-常用指令-3"><a href="#b-常用指令-3" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd [key] [score] [value] 向指定key的集合中增加元素</span><br><span class="line"> </span><br><span class="line">zrange [key] [start_index] [end_index] 获取下标范围内的元素列表，按score 排序输出</span><br><span class="line"> </span><br><span class="line">zrevrange [key] [start_index] [end_index]  获取范围内的元素列表 ，按score排序 逆序输出</span><br><span class="line"> </span><br><span class="line">zcard [key]  获取集合列表的元素个数</span><br><span class="line"> </span><br><span class="line">zrank [key] [value]  获取元素再集合中的排名</span><br><span class="line"> </span><br><span class="line">zrangebyscore [key] [score1] [score2]  输出score范围内的元素列表</span><br><span class="line"> </span><br><span class="line">zrem [key] [value]  删除元素</span><br><span class="line"> </span><br><span class="line">zscore [key] [value] 获取元素的score</span><br></pre></td></tr></table></figure>

<h3 id="c-应用场景-3"><a href="#c-应用场景-3" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>zset可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</p>
<p>zset还可以用来存储学生的成绩，value值是学生的 ID,score是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。<br>（关键字：排行榜）<br><img src="https://img-blog.csdnimg.cn/20200612112945534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="d-高频指令-1"><a href="#d-高频指令-1" class="headerlink" title="d. 高频指令"></a>d. 高频指令</h3><ul>
<li>求名次为[a,b]的分数的玩家  ： <code>zrevrange [key] [start_index] [end_index]</code>  ps： zrange是升序，zrevrange是降序</li>
<li>求某一个玩家的排名  ： <code>zrank</code> </li>
<li>求分数为[a,b]的玩家  ： <code>zrangebyscore [key] [score1] [score2]</code> </li>
<li>求某一个玩家的分数 ： <code>zscore [key] [value]</code> ( zscore player_set czf )</li>
</ul>
<hr>
<h1 id="Redis缓存雪崩-穿透-击穿-无底洞问题"><a href="#Redis缓存雪崩-穿透-击穿-无底洞问题" class="headerlink" title="Redis缓存雪崩/穿透/击穿/无底洞问题"></a>Redis缓存雪崩/穿透/击穿/无底洞问题</h1><h2 id="缓存穿透-大量请求不命中"><a href="#缓存穿透-大量请求不命中" class="headerlink" title="缓存穿透 - 大量请求不命中"></a><font color=red>缓存穿透</font> - 大量请求不命中</h2><p><img src="https://img-blog.csdnimg.cn/20200529200256342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>当请求到来时，会先去查缓存，缓存中没有，然后才会“穿过”缓存层访问数据库，如果数据库中存有请求的结果，那么会将结果数据写到缓存中。 但如果访问的是数据库中也没有的记录，那么缓存中也不会存储。 当有大量请求访问数据库中不存在的数据时，那么缓存也就形同虚设，大量的并发直接落在了数据库上。</p>
<h3 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h3><h4 id="1-业务代码自身的问题"><a href="#1-业务代码自身的问题" class="headerlink" title="1. 业务代码自身的问题"></a>1. 业务代码自身的问题</h4><p>例如对于一些不合理的查询请求在业务代码层面上没有过滤掉等。</p>
<h4 id="2-恶意攻击、爬虫等"><a href="#2-恶意攻击、爬虫等" class="headerlink" title="2. 恶意攻击、爬虫等"></a>2. 恶意攻击、爬虫等</h4><h3 id="如何发现："><a href="#如何发现：" class="headerlink" title="如何发现："></a>如何发现：</h3><h4 id="1-业务的响应时间"><a href="#1-业务的响应时间" class="headerlink" title="1. 业务的响应时间"></a>1. 业务的响应时间</h4><p>如果出现了穿透，请求打到了存储层上，响应时间一定会收到影响。</p>
<h4 id="2-采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数"><a href="#2-采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数" class="headerlink" title="2. 采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数"></a>2. 采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数</h4><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="方法一：把查询空结果也给缓存起来"><a href="#方法一：把查询空结果也给缓存起来" class="headerlink" title="方法一：把查询空结果也给缓存起来"></a>方法一：把查询空结果也给缓存起来</h4><ul>
<li>但这样会出现两个问题：<ol>
<li>对于恶意攻击来说，他们可以通过组合不同的键来查询空结果，所以穿透依然无法避免。</li>
<li>如果在查询某个关键的key的时候，查询接口因为一些意外原因（如网络延迟过大）而导致了查询到了空结果，在把这个空结果给缓存了之后，在其失效之前，对于这个key的查询得到的结果总是空的，但这个期间，有可能查询接口又恢复正常了（但却因为缓存缓存了空结果，所以还是查询不到）。 </li>
</ol>
</li>
</ul>
<h4 id="方法二-布隆过滤器拦截"><a href="#方法二-布隆过滤器拦截" class="headerlink" title="方法二: 布隆过滤器拦截"></a>方法二: <a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="noopener">布隆过滤器</a>拦截</h4><blockquote>
<p>布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data<br>structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200529200412695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此，在查询的时候，先去布隆过滤器查询，只有对于通过了布隆过滤器的查询，才会真正的去执行查询.  但这并不能100%的过滤掉所有空查询，因为布隆过滤器可以保证不通过的一定不存在，但不能保证通过的一定存在。</p>
<blockquote>
<p>缓存穿透应该是<br>当数据库中没有某个key对应的value时，缓存中也不会有该value的缓存。所以大量的对该value的查询该的请求会绕过缓存，直接查询数据库。</p>
<p>缓存中一般存的是 key+value ,但是布隆过滤器却可以告诉你 key<br>对应的value在数据库中存不存在，如果不存在就不用查询数据库了。</p>
<p>拿redis为例子： 请注意，用 redis 也可以做到判断 key 对应的value<br>在数据库中存不在，那就是把数据库里的所有value对应的key都储存在redis<br>中,而value可以为空，然后判断下key.IsExists()就可以了，但是这无疑会浪费大量空间，因为存储了数据库中所有的key。而且这也不符合缓存的初衷：咱不能暴力的把所有key都存下来，而是查询了啥key，我们缓存啥key。</p>
<p>而布隆过滤器是一种非常高效的数据结构，把所有数据库的value对应的key<br>存储到布隆过滤器里，几乎不消耗什么空间，而且查询也是相当的快！但是请注意，它只能判断 key 是否存在（而且会有一定的误差）。</p>
<p>所以一个查询先通过布隆顾虑器判断key是否存在(key 对应的value是否存在数据库中)，如果不存在直接返回空就好了。</p>
<p>那么布隆过滤器是怎么做到几乎不消耗空间来储存所有的key,并快速判断特定的key是否存在呢？</p>
<p>其实原理很简单，布隆过滤器 只是一个 byte数组，再加上几个映射函数。</p>
<p>每个key 都通过一系列映射函数，得到一系列的的值k，然后在这个byte数组上的把k下标的值变成1。</p>
<p>当要判断key是否存在时，通过映射函数映射得到的一系列k，查看byte数组相应下标k对应的值是否为1，如果有一个不为1，那么一定不存在。如果都是1<br>，那么可能存在。为什么可能而不是一定呢？因为这是一个误差问题，有可能别的key把某个k的位置变成了1，key越多时，误差越大。但是放心不会很大的，这是可以控制的，byte数组越长，误差越小。</p>
</blockquote>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font color=red>缓存雪崩</font></h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>一般情况下，缓存层将接受大量的服务请求，存储层只接受比较少的服务请求，但当缓存层发生异常/脱机（总之暂时无法工作）或是是指在某一个时间段，缓存集中过期失效，那么流量直接压向后端组件（例如数据库，或第三方API），造成级联故障。</p>
<blockquote>
<p>级联故障的解释：<br>网络中，一个或少数几个节点或连线的失效会通过节点之间的耦合关系引发其他节点也发生失效，进而产生级联效应，最终导致相当一部分节点甚至整个网络的崩溃，这种现象就称为级联失效，有时也形象称之为“雪崩” 。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200529200451927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="保证缓存的高可用性"><a href="#保证缓存的高可用性" class="headerlink" title="保证缓存的高可用性"></a>保证缓存的高可用性</h4><p>例如 Redis的主从机制，主机挂了从机上.</p>
<ul>
<li>Redis Sentinel</li>
<li>Redis Cluster</li>
<li>主从漂移</li>
</ul>
<h4 id="依赖隔离组件为后端限流"><a href="#依赖隔离组件为后端限流" class="headerlink" title="依赖隔离组件为后端限流"></a>依赖隔离组件为后端<font color=red>限流</font></h4><ul>
<li>Hystrix这种隔离组件</li>
<li>使用线程池/信号量隔离组件</li>
<li>使用Guava提供的限流API（令牌桶，漏桶）<h4 id="提前演练：例如压力测试"><a href="#提前演练：例如压力测试" class="headerlink" title="提前演练：例如压力测试"></a>提前演练：例如压力测试</h4><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>一个超级热点数据如果因为超时失效或其他原因而从redis中被删除，那么短期大量的流量就会打到数据库上.</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><ul>
<li>对于热点数据不设置失效时间</li>
<li>提前将热点数据预存到redis中</li>
<li>使用第三方缓存或本地缓存（例如Guava的Cache），如果是热点数据的话，频繁被访问的情况话就不会被置换出去</li>
<li>限流（线程池、信号量、RateLimiter。。。）熔断（to study）</li>
</ul>
<h2 id="无底洞问题优化"><a href="#无底洞问题优化" class="headerlink" title="无底洞问题优化*"></a>无底洞问题优化*</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>加机器之后，性能不但没有提升，反而下降了。（因为加的机器多了，网络请求次数也多了，开销也大了）</p>
<p><img src="https://img-blog.csdnimg.cn/20200529200327517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="优化IO的几种方法"><a href="#优化IO的几种方法" class="headerlink" title="优化IO的几种方法"></a>优化IO的几种方法</h3><ol>
<li>命令本身优化：例如慢查询keys、hgetall bigkey</li>
<li>减少网络通信次数（无底洞问题主要优化的位置）</li>
<li>降低接入成本：例如客户端长连接/连接池、NIO等</li>
</ol>
<h3 id="四种批量优化的方法"><a href="#四种批量优化的方法" class="headerlink" title="四种批量优化的方法"></a>四种批量优化的方法</h3><ol>
<li>串行meget</li>
<li>串行io</li>
<li>并行io</li>
<li>hash_tag<br><img src="https://img-blog.csdnimg.cn/2020052920051222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<hr>
<h1 id="Redis对过期key的删除策略"><a href="#Redis对过期key的删除策略" class="headerlink" title="Redis对过期key的删除策略"></a>Redis对过期key的删除策略</h1><p>如果假设你设置了一批 key 只能存活 1 个小时，那么接下来 1 小时后，redis 是怎么对这批 key 进行删除的？</p>
<p><strong>定期删除 + 惰性删除</strong></p>
<ul>
<li><p><font size=4><strong>定期删除</strong></font>:</p>
<p>  redis是默认每隔100ms就<strong>随机抽取一些设置了过期时间的key</strong>，检查是否过期，如果过期就删除。注意！这里是<strong>随机抽取</strong>， 这样即使在redis中存储了很多数据的情况下，依然能够保证性能.</p>
</li>
<li><p><font size=4><strong>惰性删除</strong></font>:</p>
<p>  懒惰删除就如字面意思，每次在获取key的时候，会排查这个key是否过期，如果过期了就删除。</p>
</li>
<li><p><font size=4><strong>Redis内存淘汰机制</strong></font>:</p>
<p>  考虑一下这种场景，定期删除漏掉了许多过期的key，同时也没有去及时去排查，也就没触发惰性删除，这时，大量的过期key就会堆积在内存里，导致redis内存块耗尽…… 而解决这个问题的办法就是redis内存淘汰机制。</p>
<p>  <font size=3 color=brown><strong>Redis提供6种数据淘汰策略</strong></font></p>
<ul>
<li><p><strong>volatile-lru</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>最近最少使用</strong></font>的数据淘汰    </p>
</li>
<li><p><strong>volatile-ttl</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>即将过期的</strong></font>的数据淘汰    </p>
</li>
<li><p><strong>volatile-random</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>随机挑选</strong></font>数据淘汰    </p>
</li>
<li><p><strong>allkeys-lru</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>最近最少使用</strong></font>的数据淘汰 <strong>（最常用）</strong></p>
</li>
<li><p><strong>allkeys-random</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>随机挑选</strong></font>数据淘汰 </p>
</li>
<li><p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p>
<br>

<p><font size=3 color=brown><strong>4.0版本之后增加了以下两种：</strong></font></p>
<ul>
<li><strong>volatile-lfu</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>最不经常使用</strong></font>的数据淘汰    </li>
</ul>
</li>
<li><p><strong>allkeys-lfu</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>最不经常使用</strong></font>的数据淘汰    </p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis的事务其实就是<font color=brown size=4><strong>将一组命令打包，然后一次性执行完，期间不允许被打断，执行完毕后才能去执行其他客户端的命令</strong></font>。</p>
<p>所以Redis的事务满足：</p>
<ul>
<li><strong>不支持回滚</strong>的原子性</li>
<li>一致性</li>
<li>隔离性（因为是串行的）</li>
</ul>
<p>如果运行在特性的持久化模式下，也会具有一定程度的持久性。</p>
<blockquote>
<p>redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。（<a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener">来自issue:关于 Redis 事务不是原子性问题</a> ）</p>
</blockquote>
<hr>
<h1 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h1><h2 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h2><p><code>kyes pattern: 查找所有符合给定模式pattern的key</code></p>
<ul>
<li>一次性返回所有匹配的key</li>
<li>键的数量过大会使服务卡顿</li>
</ul>
<p>可以使用<code>scan cursor [Match pattern][COUNT count]</code> ：</p>
<ul>
<li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程。</li>
<li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历。</li>
<li>不保证每次执行都返回给定数量的元素（count数大于key总数的时候）一次返回数量不可控，只能是大概率符合count。</li>
<li>支持模糊查询，即能够返回满足pattern匹配的key</li>
</ul>
<p>例如：<code>scan 0 match k1* count 10</code> ，注意，返回的值有可能的是重复的！ 因此需要去重！（例如写程序的时候用hashset）</p>
<p><code>blpop</code></p>
<h2 id="通过Redis实现分布式锁"><a href="#通过Redis实现分布式锁" class="headerlink" title="通过Redis实现分布式锁"></a>通过Redis实现分布式锁</h2><p>即分布式系统中，访问共同资源时的一种锁的实现。</p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，setnx key val 就是如果不存在key的话，那么就设置key为val。设置成功返回1， 失败返回0</p>
<p><code>SET lock_key random_value NX PX 5000</code> </p>
<p><strong>一定要放到一个语句里，保证“获取锁”和“设置超时时间”的原子性。如果设置完setnx以后，程序就挂掉了，那么这个key（锁）就一直被占用！</strong></p>
<h2 id="使用Redis做异步队列"><a href="#使用Redis做异步队列" class="headerlink" title="使用Redis做异步队列"></a>使用Redis做异步队列</h2><p>除了使用list的rpush, lpop, blpop 以外，可以用pub/sub:主题订阅者模式，来做。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><ul>
<li>订阅一个频道：<ul>
<li>redis-cli1:  <code>subscribe myTopic</code>   ,之后进入监听状态</li>
<li>redis-cli2:  <code>subscribe myTopic</code>   ,之后进入监听状态</li>
<li>redis-cli3:  <code>subscribe myTopic</code>   ,之后进入监听状态</li>
<li>redis-cli4:  <code>publish myTopic &quot;hello!!&quot;</code> ：<br>这条消息发送出去之后，监听myTopic的3个客户端都收到了“hello!!”这个字符串。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong>：<br>但需要注意的是，消息的发布是无状态的，也就是无法保证可达。对于发布者来说，消息是即发即失的。 若想解决这个问题，需要用专业的消息队列，如kafka，rocketmq等。</p>
<h1 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h1><h2 id="RDB-快照-持久化：保存某一个时间点的全数据快照"><a href="#RDB-快照-持久化：保存某一个时间点的全数据快照" class="headerlink" title="RDB ( 快照 ) 持久化：保存某一个时间点的全数据快照."></a><a href="https://www.cnblogs.com/javazhiyin/p/12985656.html" target="_blank" rel="noopener">RDB ( 快照 ) 持久化</a>：保存某一个时间点的全数据快照.</h2><p>redis服务器加载时，会启用reids.conf文件中的配置信息，里面的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">save 900 1   # 就是900秒内如果有1条是写入指令，那么就触发一次快照</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">stop-writes-on-bgsave-error yes #当设置成yes，</span><br><span class="line"># 就是备份进程若出错了，则主进程就停止</span><br><span class="line"># 接受新的写入操作, 这是为了保证数据一致性！</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><strong>可以根据不同的情况来合理配置。 <code>src</code>目录下的<code>dump.rdb</code>文件，就是redis系统定期备份的rdb文件. 它是一个二进制文件。</strong></p>
<h3 id="生成RDB备份文件的方式"><a href="#生成RDB备份文件的方式" class="headerlink" title="生成RDB备份文件的方式:"></a>生成RDB备份文件的方式:</h3><ul>
<li><h4 id="主动生成"><a href="#主动生成" class="headerlink" title="主动生成"></a>主动生成</h4><ul>
<li>SAVE: 阻塞Redis的服务器进程，直到RDB文件被创建完毕。 很少被使用，因为占用了主线程！！ 主线程是用来处理client的请求的！！</li>
<li>BGSAVE：Fork一个子进程创建RBD文件，不阻塞服务器进程！此时，主进程依然继续工作，子进程将内存中的数据写入临时文件中，因为copy-on-write的机制，父子进程此时会共享相同的物理页面，当(主)父进程处理写请求时，os会为父进程要写的页面创建一个副本（这个副本用于备份），而不是写入共享的页面！ RDB文件的载入，一般情况下是自动的，redis服务器启动时，若检测到rdb文件的存在，那么会载入这个文件<br><img src="https://img-blog.csdnimg.cn/20200412162246617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在fork时，子进程和父进程共享同一块资源空间，只有当父进程对此空间进行修改时，才会触发给子进程的资源复制，这一机制为copy-on-write. ，juc的copyOnWriteArrayList也是使用的这一原理。</li>
</ul>
</li>
<li><h4 id="被动生成"><a href="#被动生成" class="headerlink" title="被动生成"></a>被动生成</h4><ul>
<li>根据redis.conf里的save m n 定时触发 (用的是BGSAVE)</li>
<li>主从复制时，主节点自动触发（主节点发送rdb文件给从结点，这时，主节点会触发一次！）</li>
<li>执行debug reload</li>
<li>执行shutdown且没有开启AOF持久化，那么会触发一次RDB持久化</li>
</ul>
</li>
</ul>
<h3 id="RDB持久化的缺点"><a href="#RDB持久化的缺点" class="headerlink" title="RDB持久化的缺点:"></a>RDB持久化的缺点:</h3><ul>
<li>内存数据的<strong>全部同步</strong>！ 数据量大的时候会因为IO而严重影响性能！</li>
<li>可能会因为redis挂掉而丢失从当前到最近一次备份期间的所有数据！</li>
</ul>
<h2 id="AOF-Append-Only-File-持久化：保存写状态"><a href="#AOF-Append-Only-File-持久化：保存写状态" class="headerlink" title="AOF ( Append-Only-File )持久化：保存写状态"></a><a href="https://blog.csdn.net/liangd8888/article/details/89322605" target="_blank" rel="noopener">AOF ( Append-Only-File )</a>持久化：保存写状态</h2><ul>
<li>记录下除了查询以外的所有变更数据库状态的指令</li>
<li>以append的形式追加保存到AOF文件中</li>
<li>AOF持久化默认是关闭的，可以修改redis.conf来让其生效：            <ul>
<li>appendonly yes # 启动 aof</li>
<li>appendfsync everysec/always/no：<ul>
<li>always:  一旦缓存区发生改变，就立刻将内容写到文件中！</li>
<li>everysec: 每隔1s，写入一次</li>
<li>no: 什么时候写交给os判断, 一般是等缓存区写满了就写入一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志重写解决AOF文件大小不断增大的问题（例如100条incr-可以用一条add-100实现）-其原理如下："><a href="#日志重写解决AOF文件大小不断增大的问题（例如100条incr-可以用一条add-100实现）-其原理如下：" class="headerlink" title="日志重写解决AOF文件大小不断增大的问题（例如100条incr 可以用一条add 100实现）, 其原理如下："></a>日志重写解决AOF文件大小不断增大的问题（例如100条incr 可以用一条add 100实现）, 其原理如下：</h3><ul>
<li>调用fork(), 创建一个子进程。</li>
<li>子进程把新的AOF写到一个临时文件里，新的AOF是根据内存数据生成对应的命令，并不需要区依赖原来的AOF文件。</li>
<li>主进程持续将新的变动写到内存中，并更新到“旧”的AOF文件里。</li>
<li>重写结束之后，会给主进程一个信号，然后把内存的buff追加到新生成的AOF文件。</li>
<li>用新的AOF替换掉旧的AOF。</li>
</ul>
<h2 id="从Redis中恢复数据"><a href="#从Redis中恢复数据" class="headerlink" title="从Redis中恢复数据"></a>从Redis中恢复数据</h2><p>其实只要重启就可以了。。</p>
<ul>
<li>检查AOF是否存在，若存在则直接加载AOF，不再去找RDB</li>
<li>若不存在AOF，则尝试加载RDB</li>
</ul>
<h2 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h2><ul>
<li><p>RDB优点：创建RDB那一瞬间的全部内存数据快照，文件小，恢复快</p>
</li>
<li><p>RDB缺点：无法保存最近一次快照之后的数据</p>
</li>
<li><p>AOF优点：可读性高，适合保存增量数据，数据不易丢失</p>
</li>
<li><p>AOF缺点：文件体积大，恢复时间长</p>
</li>
</ul>
<h2 id="redis-4-0之后的备份就是混合模式，即RDB-AOF"><a href="#redis-4-0之后的备份就是混合模式，即RDB-AOF" class="headerlink" title="redis 4.0之后的备份就是混合模式，即RDB-AOF."></a>redis 4.0之后的备份就是混合模式，即RDB-AOF.</h2><p>rdb用于全量备份，aof用于增量备份，为redis4.0之后的默认备份方式。</p>
<p>bgsave做全量持久化，aof做增量持久化</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis基础</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ学习</title>
    <url>/2020/07/10/rocketmq%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、消息队列能用来干什么？"><a href="#一、消息队列能用来干什么？" class="headerlink" title="一、消息队列能用来干什么？"></a>一、消息队列能用来干什么？</h1><p>异步，解耦，削峰。</p>
<h2 id="1-异步："><a href="#1-异步：" class="headerlink" title="1. 异步："></a>1. 异步：</h2><p>比如在电商的业务场景下，下单成功后要调用短信模块，邮件模块提醒买家下单成功的信息，而下单和发短信,发邮件使用消息队列来异步执行可以提高响应速度，增强用户体验。</p>
<h2 id="2-解耦"><a href="#2-解耦" class="headerlink" title="2. 解耦"></a>2. 解耦</h2><p>如果不用消息队列的话，对不同功能模块的调用是要写死在业务代码里的，也就是调用方在调用逻辑还耦合了”调用哪一个服务”这一层逻辑在里面逻辑，日后增加功能或删掉功能的时候，修改业务代码成本会比较大… 而使用消息队列的topic在中间进行一层解耦就能减轻这种问题，发送方只负责发送消息，消费方只负责消费消息，服务的类型被抽象成topic，由消息队列来管理。</p>
<h2 id="3-削峰"><a href="#3-削峰" class="headerlink" title="3. 削峰"></a>3. 削峰</h2><p>如果上游请求规模超出了下游服务的负载的话，使用消息队列可以起到一个缓冲的作用，即将请求先存起来然后让下游服务尽自己所能的去消费，保护了下游服务系统。</p>
<a id="more"></a>

<h1 id="二、-RocketMQ的架构组成"><a href="#二、-RocketMQ的架构组成" class="headerlink" title="二、 RocketMQ的架构组成"></a>二、 RocketMQ的架构组成</h1><p><img src="https://img-blog.csdnimg.cn/20200614215010509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>NameServer</strong>： 主要是对Broker进行管理，主要包括对消息的路由的管理。</li>
</ul>
<blockquote>
<p>被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群</p>
</blockquote>
<blockquote>
<p>每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</p>
</blockquote>
<ul>
<li><strong>Broker</strong>：主要负责对消息的存储，消息的转发</li>
</ul>
<blockquote>
<p>Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于Netty实现的。</p>
</blockquote>
<blockquote>
<p>Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。</p>
</blockquote>
<ul>
<li><strong>Producer</strong>： 消息生产者，负责产生消息，一般由业务系统负责产生消息。<blockquote>
<p>RocketMQ 提供了三种方式发送消息：同步、异步和单向</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p>
</blockquote>
<blockquote>
<p>异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p>
</blockquote>
<blockquote>
<p>单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p>
</blockquote>
<ul>
<li><strong>Consumer</strong>：消息消费者，负责消费消息，一般是后台系统负责异步消费。</li>
</ul>
<blockquote>
<p>Consumer也由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制。</p>
</blockquote>
<blockquote>
<p><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</p>
</blockquote>
<blockquote>
<p>Push：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</p>
</blockquote>
<h1 id="三、消息的发送与消费"><a href="#三、消息的发送与消费" class="headerlink" title="三、消息的发送与消费"></a>三、消息的发送与消费</h1><h2 id="a-消息的三种发送方式"><a href="#a-消息的三种发送方式" class="headerlink" title=" a. 消息的三种发送方式"></a><font color=red> a. 消息的三种发送方式</font></h2><h3 id="1-发送同步消息"><a href="#1-发送同步消息" class="headerlink" title="1. 发送同步消息"></a>1. 发送同步消息</h3><p>特点：发送完阻塞，直到发送成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    	producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    	    <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">    	    Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">        	<span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        	(<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-发送异步消息"><a href="#2-发送异步消息" class="headerlink" title="2. 发送异步消息"></a>2. 发送异步消息</h3><p>特点：消息发送完之后不会阻塞，传入一个回调方法，当消息发送成功时会对回调方法进行调用。 适合对响应时间比较敏感的业务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      	              System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">      	              e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            	&#125;);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-单向发送消息"><a href="#3-单向发送消息" class="headerlink" title="3. 单向发送消息"></a>3. 单向发送消息</h4><p>不关心发送结果，发送完也不管是否发送成功，可靠性不高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	<span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    	<span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    	<span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        	<span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        	Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        	);</span><br><span class="line">        	<span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        	producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    	producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="b-消息的类型"><a href="#b-消息的类型" class="headerlink" title="b. 消息的类型"></a><font color=red>b. 消息的类型</font></h2><h3 id="1-顺序消息"><a href="#1-顺序消息" class="headerlink" title="1. 顺序消息"></a>1. 顺序消息</h3><p>就是按照消息的发送顺序来进行消费.</p>
<h3 id="2-延时消息"><a href="#2-延时消息" class="headerlink" title="2.  延时消息"></a>2.  延时消息</h3><p>在指定时间之后发送一个消息。例如在 10s钟之后发送一个消息，使用限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-事务消息"><a href="#3-事务消息" class="headerlink" title="3. 事务消息"></a><font color=brown size=5>3. 事务消息</font></h3><p><img src="https://img-blog.csdnimg.cn/20200630200614744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="消息的发送和提交"><a href="#消息的发送和提交" class="headerlink" title="消息的发送和提交"></a>消息的发送和提交</h4><p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果去执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h4 id="补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）"><a href="#补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）" class="headerlink" title="补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）"></a>补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<h4 id="部分原理"><a href="#部分原理" class="headerlink" title="部分原理"></a>部分原理</h4><h5 id="半消息如何对消费端不可见"><a href="#半消息如何对消费端不可见" class="headerlink" title="半消息如何对消费端不可见"></a>半消息如何对消费端不可见</h5><p>发送出去的半消息会把消息的Topic和Queue等属性给存储到消息中，然后再对这两个属性进行替换，然后这个半消息就被存到一个消费者不可见的Queue中了（QueueId是0）。  当进行二段提交的时候，会将预先存在该消息里的原本消息的topic和queue再替换回去，然后发送出去，就能被消费者看到了…</p>
<h5 id="如何确定消息的最终状态"><a href="#如何确定消息的最终状态" class="headerlink" title="如何确定消息的最终状态"></a>如何确定消息的最终状态</h5><p>RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息是否状态已经确定（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。</p>
<p>这个Op消息也是被存储在一个单独的队列里面的，消费者不可见。</p>
<h5 id="如何处理二阶段失败的消息"><a href="#如何处理二阶段失败的消息" class="headerlink" title="如何处理二阶段失败的消息"></a>如何处理二阶段失败的消息</h5><p>如果在二阶段提交的时候失败了，比如在Commit的时候出现了网络问题导致Commit失败，那么这条消息还是处于unknown状态，为了解决这一问题，rocketmq的使用的方法就是“回查”。</p>
<p><strong>Broker端</strong>对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。</p>
<p><a href="https://www.cnblogs.com/hzmark/p/rocket_txn.html" target="_blank" rel="noopener">参考 RocketMQ事务消息实现分析</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>select/poll/epoll学习</title>
    <url>/2020/07/10/select-poll-epoll%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>一次网络IO会涉及两个系统对象:</p>
<ol>
<li>等待数据准备好</li>
<li>将数据从内核空间的buffer拷贝到用户空间进程的buffer<br>而这五种IO模型的特点就在于以怎样的方式来处理这两个系统对象和两个阶段.</li>
</ol>
<h2 id="Unix-有五种-I-O-模型："><a href="#Unix-有五种-I-O-模型：" class="headerlink" title="Unix 有五种 I/O 模型："></a>Unix 有五种 I/O 模型：</h2><ol>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ol>
<a id="more"></a>

<h2 id="1-阻塞式IO"><a href="#1-阻塞式IO" class="headerlink" title="1. 阻塞式IO"></a>1. 阻塞式IO</h2><p>应用进程被阻塞，直到<strong>数据从内核buffer复制到应用进程buffer中</strong>才返回。</p>
<p>特点：</p>
<ul>
<li>在准备数据阶段：被阻塞</li>
<li>数据从内核buffer复制到用户态buffer阶段：被阻塞</li>
<li><code>recvfrom</code>执行结束之后才能之后后面的程序<br><img src="https://img-blog.csdnimg.cn/20200605141204458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="2-非阻塞式IO"><a href="#2-非阻塞式IO" class="headerlink" title="2. 非阻塞式IO"></a>2. 非阻塞式IO</h2>用户态程序执行IO调用后，无论IO是否完成，都会立刻返回结果，应用程序需要不断的执行这个系统调用去获知IO是否完成。（注意，这里会返回IO是否已经完成的状态，而不是数据是否准备好）</li>
</ul>
<p>特点：</p>
<ul>
<li>在数据准备阶段：非阻塞式（会立刻返回一个错误码）</li>
<li>数据从内核buffer复制到用户态buffer阶段：阻塞式</li>
<li><code>recvfrom</code>会立刻返回结果，一般会用一个循环来不停的去判断IO是否完成。</li>
<li>实时性会比较好，但CPU利用率比较低<br><img src="https://img-blog.csdnimg.cn/20200605142017590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="3-IO复用"><a href="#3-IO复用" class="headerlink" title="3. IO复用"></a>3. IO复用</h2>让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</li>
</ul>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<p>特点：</p>
<ul>
<li>数据准备阶段：阻塞，并会返回一个“事件已经发生的信号”（这里的事件就是数据已经准备好了）</li>
<li>数据从内核buffer复制到用户态buffer阶段：阻塞</li>
</ul>
<p>IO复用的实现有select/poll/epoll，后面会详细说<br><img src="https://img-blog.csdnimg.cn/20200605142242540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-信号驱动-I-O"><a href="#4-信号驱动-I-O" class="headerlink" title="4. 信号驱动 I/O"></a>4. 信号驱动 I/O</h2><p>个人理解 信号驱动IO = 事件驱动机制 + 非阻塞式IO</p>
<p>信号驱动IO是指：进程预先告知内核，使得 当某个socketfd有events（事件）发生时，内核使用信号通知相关进程。 </p>
<p>因此通知完了之后，并不会被阻塞。 </p>
<p>当内核通知相关进程，它感兴趣的事件发生了的时候（这里就是数据已经准备好了），然后再去做recvfrom，将数据从内核态复制到用户态。</p>
<p>特点：</p>
<ul>
<li>数据准备阶段：非阻塞式。（因为只是向OS发送一个通知，立刻就返回了）</li>
<li>数据从内核buffer复制到用户态buffer阶段：阻塞式。</li>
<li>相比于前面的非阻塞式IO的轮询，信号驱动IO的CPU利用率更高</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200605142951404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5. 异步IO"></a>5. 异步IO</h2><p>理解异步IO，先要理解异步，通俗来说就是，只要我触发了一IO调用，那么这个IO在这之后的任何一个时刻完成对我的程序都不会有影响，因此我就没必要非等你IO完了才继续往下执行，而是利用“委派”的思想，让内核去帮我完成.</p>
<p>因此，在调用完异步IO的系统调用（例如aio_read）之后，应用进程可以继续执行，不会被阻塞，内核会在<strong>所有操作完成之后</strong>向应用进程发送信号。</p>
<p>注意，异步IO也是 “事件驱动 + 非阻塞” ， 但它和信号驱动IO的区别是， 异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<p>特点：</p>
<ul>
<li>数据准备阶段：非阻塞</li>
<li>数据从内核buffer复制到用户态buffer阶段：非阻塞</li>
<li>相当于把IO操作给委派出去了，所以自己完全不会被阻塞<br><img src="https://img-blog.csdnimg.cn/2020060514341991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h1 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h1><ul>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I/O：第二阶段应用进程不会阻塞。</li>
</ul>
<p><font color=red size=5>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，</font></p>
<p><font color=red size=5>它们的主要区别在第一个阶段。</font></p>
<p><font color=red size=5>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</font><br><img src="https://img-blog.csdnimg.cn/20200605143505407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="IO复用——select-poll-epoll"><a href="#IO复用——select-poll-epoll" class="headerlink" title="IO复用——select/poll/epoll"></a>IO复用——select/poll/epoll</h1><p>这三种对IO复用的实现方式的区别主要在于：</p>
<ul>
<li>对socketfd的存储方式</li>
<li>以怎样的方式去通知用户级进程去获取已经发生的事件（或者说用户级进程用怎样的方式去获取已经放发生的事件）</li>
</ul>
<h2 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">buffer</span>[MAXBUF];</span><br><span class="line">  <span class="keyword">int</span> fds[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">  <span class="keyword">int</span> addrlen, n,i,<span class="built_in">max</span>=<span class="number">0</span>;;</span><br><span class="line">  <span class="keyword">int</span> sockfd, commfd;</span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">  		child_process();</span><br><span class="line">  		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">  <span class="built_in">listen</span> (sockfd, <span class="number">5</span>); </span><br><span class="line">  <span class="comment">// ==================从这里开始=====================</span></span><br><span class="line">  <span class="comment">// 初始化rset(32个长整型 = 一个1024的bitmap)</span></span><br><span class="line">  <span class="comment">// 主要目的是获取最大的文件描述符</span></span><br><span class="line">  <span class="comment">// 将打开的文件描述符fds_i对应的位置为1（linux默认最多打开1024个文件，因此这个文件描述符小于1024）</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">    	<span class="built_in">max</span> = fds[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始监听事件</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  		FD_SET(fds[i],&amp;rset);</span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line">   	<span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">   	<span class="comment">// 在这里会阻塞，当有事件发生时，会修改rset的值，</span></span><br><span class="line">   	<span class="comment">// 即发生事件的对应bit会被置位1，其他都被置为0</span></span><br><span class="line">   	<span class="comment">// 因此，每循环一轮都要对rset重新初始化一次</span></span><br><span class="line">	select(<span class="built_in">max</span>+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">// 遍历所有监听的文件描述符，若被置位了，那么就去进行IO</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">			<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(fds[i], <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>每个操作系统都实现了select模式，可移植性较强</li>
<li>在一些监听事件个数比较少的情况下，也比较优秀</li>
</ol>
<p>缺点：</p>
<ol>
<li>因为对文件描述符的存储是一个1024的bitmap, 所以一个进程最多监听的事件个数被限制。 </li>
<li>因为select每次都会对传入的readset进行一个修改，所以在每次轮询的时候，都要重新进行一次初始化，这也是比较低效的</li>
<li>事件监听的种类是通过传入fd_set类型的参数来进行的，因此不太好扩展.</li>
<li>每次都需要遍历所有的文件描述符才能知道事件发生的是哪一个socket，如果监听的事件比较多，且只有一个事件发生，那么也需要遍历全部，这样显然是很低效的。</li>
<li>在进行IO的时候，需要将<font color=red><strong>存储文件描述符状态信息的bitmap</strong></font>从内核态复制到用户态，这一复制过程开销也比较大.</li>
</ol>
<h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2. poll"></a>2. poll</h2><p>poll的实现大体上和select类似，只是改变了对事件的存储形式，不再使用fd_set, 而是使用一个结构体来保存.  这个结构体中保存的数据主要有：</p>
<ul>
<li>对应的文件描述符</li>
<li>被监听的事件类型</li>
<li>事件是否发生的一个标志位<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd; <span class="comment">// 对应的文件描述符</span></span><br><span class="line">      short events; <span class="comment">// 被监听的事件类型</span></span><br><span class="line">      short revents; <span class="comment">// 事件是否发生的一个标志位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="comment">// 这儿不再需要每次都初始化了</span></span><br><span class="line">  	<span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">	poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">			pollfds[i].revents = <span class="number">0</span>; <span class="comment">// 事件得到处理，标志为复原</span></span><br><span class="line">			<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">			<span class="built_in">read</span>(pollfds[i].fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>解决了select的监听事件个数存在上限问题，和每处理一轮请求需要重新初始化的问题。</li>
</ul>
<p>缺点：</p>
<ul>
<li>并不是所有系统都实现了poll模型，因此跨平台性较差</li>
<li>依然存在遍历所有事件 和 内核态数据复制到用户态的问题（用户态到内核态复制的数据，之前在select里面是一个bitmap，而在poll里面，是一个结构体数组）</li>
</ul>
<h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h2><h3 id="3-1-epoll-create"><a href="#3-1-epoll-create" class="headerlink" title="3.1 epoll_create"></a>3.1 epoll_create</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>epoll_create() 该 函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。</p>
<h3 id="3-1-epoll-ctl"><a href="#3-1-epoll-ctl" class="headerlink" title="3.1 epoll_ctl"></a>3.1 epoll_ctl</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br></pre></td></tr></table></figure>
<p>epoll_ctl() ⽤于向内核注册新的描述符或者是改变某个文件描述符的状态。</p>
<h3 id="3-1-epoll-wait"><a href="#3-1-epoll-wait" class="headerlink" title="3.1 epoll_wait"></a>3.1 epoll_wait</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>已注册的描述符在内核中会被维护在 ⼀棵红⿊树上，通过回调函数内核会将 I/O 准备好的描述符加入到⼀个链表中管理（这个链表就是传入的第二个指针参数events），进程调⽤ epoll_wait() 便可 以得到事件完成的描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"> <span class="comment">// epfd是一个文件描述符，指向一个内核中的文件区域</span></span><br><span class="line"> <span class="comment">// 这块区域是用户态和内核态共享的</span></span><br><span class="line"> <span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   ev.events = EPOLLIN;</span><br><span class="line">   <span class="comment">// 向epfd指向的那块区域中添加( EPOLL_CTL_ADD )一条 监听记录信息:</span></span><br><span class="line">   <span class="comment">// 		&lt; 需要被监听的文件描述符 (ev.data.fd), 正在监听的事件(ev) &gt;</span></span><br><span class="line">   <span class="comment">// 直接把需要监听的sockfd的信息写到了上面申请的那块内存区域中...</span></span><br><span class="line">   <span class="comment">// 因为上面的那块内存区域是内核态和用户态共享的，所以省去了 用户态到内核态的复制开销！！！！</span></span><br><span class="line">   <span class="comment">// ps: 这里多说两句，这里的epoll_ctl实际上是“注册新的描述符或者是改变某个文件描述符的状态”</span></span><br><span class="line">   <span class="comment">// 已经注册过的描述符以红黑树的形式被存储维护起来， 当有数据准备好时，会通过硬中断进行一个回调，</span></span><br><span class="line">   <span class="comment">// 把准备好了数据对应的那个socketfd给加入到一个链表中， </span></span><br><span class="line">   <span class="comment">// 然后后面进行epoll_wait的时候，实际上就是获取这个链表，因为这个链表存储的就是已经准备好的数据的socketfd</span></span><br><span class="line">   epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> 	<span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"> 	<span class="comment">// 等待正在监听的事件发生</span></span><br><span class="line"> 	<span class="comment">// 若返回-1，则说明在监听时出现了中断或错误</span></span><br><span class="line"> 	<span class="comment">// 若返回0，则说明超时，没有事件发生</span></span><br><span class="line"> 	<span class="comment">// 若大于0，则表示正在监听的所有事件中，发生了的事件个数，并且会把发生了的事件放到</span></span><br><span class="line"> 	<span class="comment">// 		传入的这个events数组中</span></span><br><span class="line"> 	<span class="comment">// ps: 这里的监听-复制，是使用硬中断来做的</span></span><br><span class="line"> 	nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取events数组里的数据，然后进行处理</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">		<span class="built_in">read</span>(events[i].data.fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>不需要每次遍历所有监听的events，而只用去遍历已经发生的events</li>
<li>因为申请的内存是内核态用户态共享的一块内存，所以在注册需要监听的socketfd信息的时候，省去了一次用户态-&gt;内核态的开销</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>只有linux上实现了epoll</p>
</li>
<li><h2 id="epoll小结"><a href="#epoll小结" class="headerlink" title="epoll小结"></a><font color=red>epoll小结</font></h2></li>
</ul>
<ol>
<li>使用epoll_create申请一块用户态和用户态共享的一块内存</li>
<li>使用epoll_ctl来注册一个socket文件描述符，或是更改一个socket文件描述的状态，注册的文件描述符信息保存在epoll_create申请的那块内存中，并且文件描述符是被维护在一个红黑树上。因为这块内存是用户态和内核态共享的，所以才能够省去一次用户态复制到内核态的开销。</li>
<li>socket文件描述符被注册到了共享内存中了之后，当事件来临时，例如数据已经准备完毕了，会触发一个中断，会将这个已经发生了的事件（数据已经准备好了）对应的socketfd给加入到一个链表中尽心管理</li>
<li>在调用epoll_wait的时候，实际上就是从这个链表中，获取事件完成的描述符。 因此，epoll_wait将返回事件完成的个数(假设为k， k&gt;0)，并且传入的events数组的前k个就是事件已经发生了的对应的描述符，因此能够减少O(N)的遍历，从而变成O(K)的遍历.</li>
</ol>
<hr>
<h2 id="select-poll-epoll的应用场景"><a href="#select-poll-epoll的应用场景" class="headerlink" title="select/poll/epoll的应用场景"></a>select/poll/epoll的应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h3 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h3><ol>
<li><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
</li>
<li><p>select 可移植性更好，几乎被所有主流平台所支持。</p>
</li>
</ol>
<h3 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h3 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h3><ol>
<li><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
</li>
<li><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
</li>
<li><p><strong>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。</strong> 因为 epoll 中的所有描述符都存储在内核中，造成<font color=red><strong>每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用</strong></font>，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
</li>
</ol>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&seid=6751505418841311165" target="_blank" rel="noopener">IO多路复用select/poll/epoll介绍</a><br><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll" target="_blank" rel="noopener">CS-Note</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2" target="_blank" rel="noopener">讲解nio,epoll,多路复用</a></p>
]]></content>
      <categories>
        <category>io模型</category>
        <category>io多路复用</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/07/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FQ/</url>
    <content><![CDATA[<h1 id="Q1-进程间的通信方式"><a href="#Q1-进程间的通信方式" class="headerlink" title="Q1: 进程间的通信方式"></a>Q1: 进程间的通信方式</h1><h2 id="1-匿名管道"><a href="#1-匿名管道" class="headerlink" title="1. 匿名管道"></a>1. 匿名管道</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure>

<p><font size=4><strong>存在形式</strong>:</font><br>无名管道：只存在于内存中的文件</p>
<p><font size=4><strong>使用限制</strong>:</font></p>
<ul>
<li>只支持半双工（单向交替传输）</li>
<li>只能在父子进程或兄弟进程中使用<br><img src="https://img-blog.csdnimg.cn/20200616143952244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<a id="more"></a>

<h2 id="2-命名管道"><a href="#2-命名管道" class="headerlink" title="2. 命名管道"></a>2. 命名管道</h2><p>解决了匿名管道的只能在父子进程中使用的限制。</p>
<p><font size=4><strong>存在形式</strong>:</font><br>命名管道：存在于实际的磁盘介质或者文件系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkfifo(const char *path, mode_t mode);</span><br><span class="line">int mkfifoat(int fd, const char *path, mode_t mode);</span><br></pre></td></tr></table></figure>

<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<p><font size=4><strong>管道的实现机制</strong>:</font></p>
<p>管道是由内核管理的一个缓冲区，这个缓冲区被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。</p>
<h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h2><p>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。 进程控制块（PCB）中有对应的字段会保存对应消息队列的标识符. </p>
<p><font size=4><strong>存在形式</strong>:</font></p>
<p>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>
<p><font size=4><strong>消息队列的优点</strong>:</font></p>
<ul>
<li>可以对消息随机读取，而不是像管道那样只能FIFO</li>
<li>比起管道, 消息队列能存储的信息更多更丰富</li>
</ul>
<h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h2><p>信号量可以理解成一个计数器，用于解决多个进程访问共享资源时的同步问题。</p>
<h2 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5. 共享内存"></a>5. 共享内存</h2><p>使多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。 这种方式需要依靠某种同步操作，例如：互斥锁和信号量等。 </p>
<h2 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h2><p>此方法主要用于不在同一台机器上的进程间的通信，例如客户端的一个进程和服务端的一个进程进行通信。</p>
<hr>
<h1 id="Q2-线程间的同步方式有哪些"><a href="#Q2-线程间的同步方式有哪些" class="headerlink" title="Q2: 线程间的同步方式有哪些"></a>Q2: 线程间的同步方式有哪些</h1><h2 id="1-互斥量-mutex-抢占式同步"><a href="#1-互斥量-mutex-抢占式同步" class="headerlink" title="1. 互斥量(mutex) (抢占式同步)"></a>1. 互斥量(mutex) (抢占式同步)</h2><p>就是上锁，在java中主要就是 synchronized 和 各种Lock. </p>
<h2 id="2-信号量-Semphore-非抢占式同步"><a href="#2-信号量-Semphore-非抢占式同步" class="headerlink" title="2. 信号量(Semphore) (非抢占式同步)"></a>2. 信号量(Semphore) (非抢占式同步)</h2><p>允许多个线程访问同一个资源，但需要控制同一时刻访问此资源的最大线程数量</p>
<h2 id="3-Java对管程的实现-wait-notify"><a href="#3-Java对管程的实现-wait-notify" class="headerlink" title="3. Java对管程的实现( wait / notify )"></a>3. Java对管程的实现( wait / notify )</h2><p>通过wait和notify来实现同步</p>
<hr>
<h1 id="Q3：死锁产生的条件"><a href="#Q3：死锁产生的条件" class="headerlink" title="Q3：死锁产生的条件"></a>Q3：死锁产生的条件</h1><h2 id="1-互斥"><a href="#1-互斥" class="headerlink" title="1. 互斥"></a>1. 互斥</h2><p>每一个资源只能分给一个进程.</p>
<h2 id="2-占用和等待"><a href="#2-占用和等待" class="headerlink" title="2. 占用和等待"></a>2. 占用和等待</h2><p>已经得到了某个资源的进程可以再请求新的资源. 并且可以在持有一些资源的状态下去等待暂时无法获取的资源</p>
<h2 id="3-不可抢占"><a href="#3-不可抢占" class="headerlink" title="3. 不可抢占"></a>3. 不可抢占</h2><p>已经分配给一个进程的资源，在这个进程没有使用完或主动释放之前，都不能被其他进程获取.</p>
<h2 id="4-环路等待"><a href="#4-环路等待" class="headerlink" title="4. 环路等待"></a>4. 环路等待</h2><p><img src="https://img-blog.csdnimg.cn/202006161521355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<h1 id="Q4-解决死锁的策略："><a href="#Q4-解决死锁的策略：" class="headerlink" title="Q4: 解决死锁的策略："></a>Q4: 解决死锁的策略：</h1><h2 id="1-鸵鸟策略（解决策略就是不去解决）"><a href="#1-鸵鸟策略（解决策略就是不去解决）" class="headerlink" title="1. 鸵鸟策略（解决策略就是不去解决）"></a>1. 鸵鸟策略（解决策略就是不去解决）</h2><p>因为解决死锁的代价会比较大，且死锁发生的概率又比较小，并且死锁也不会对用户造成致命影响的话，那么就忽略它好了..</p>
<h2 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生的时候，采取一些措施进行一个恢复</p>
<p><font color=brown size=4><strong>检测到死锁后的恢复策略：</strong></font></p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<p>其实就是破坏死锁的必要条件中的一个就行了..</p>
<h2 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h2><p><font color=red><strong>在程序运行之前</strong></font>就预防发生死锁，就是破坏死锁产生的必要条件中的一个就行。</p>
<p>例如：</p>
<ul>
<li>给资源统一编号，进程只能按编号顺序来请求资源，破坏了环路等待； </li>
<li>分配资源时，一次性把所有资源都分配出去， 破坏了占有并等待；</li>
</ul>
<h2 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h2><p><font color=red><strong>在程序运行时</strong></font>，避免发生死锁。 使用银行家算法，保证在资源分配后依然能让系统处于安全状态.. 如果不安全的话就拒绝分配.</p>
<hr>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池学习小结</title>
    <url>/2020/07/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、为什么使用线程池"><a href="#一、为什么使用线程池" class="headerlink" title="一、为什么使用线程池"></a>一、为什么使用线程池</h1><h2 id="1-能够减少线程切换带来的开销"><a href="#1-能够减少线程切换带来的开销" class="headerlink" title="1. 能够减少线程切换带来的开销"></a>1. 能够减少线程切换带来的开销</h2><p>如果有大量执行时间很短的任务，那么上下文切换带来的时间开销甚至会超过任务执行的时间，这显然是不合理的。而使用线程池就能降低线程创建和销毁造成的损耗。</p>
<h2 id="2-能够提高响应速度"><a href="#2-能够提高响应速度" class="headerlink" title="2. 能够提高响应速度"></a>2. 能够提高响应速度</h2><p>任务到达时，无需等待线程创建即可立即执行。</p>
<h2 id="3-提高线程的可管理性"><a href="#3-提高线程的可管理性" class="headerlink" title="3. 提高线程的可管理性"></a>3. 提高线程的可管理性</h2><p>线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</p>
<a id="more"></a>

<h1 id="二、线程池的生命周期"><a href="#二、线程池的生命周期" class="headerlink" title="二、线程池的生命周期"></a>二、线程池的生命周期</h1><p>线程池有5种状态：<br><img src="https://img-blog.csdnimg.cn/20200601173458887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其生命周期转换如下入所示：<br><img src="https://img-blog.csdnimg.cn/20200601173510245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="三、线程池的工作原理"><a href="#三、线程池的工作原理" class="headerlink" title="三、线程池的工作原理"></a>三、线程池的工作原理</h1><p>线程池的3个重要参数：核心线程数，最大线程数和阻塞队列容量。</p>
<p>线程池将任务提交和任务执行进行了解耦，用户只需要负责提交，而不用去关心任务执行。 在提交一个任务的时候，会根据线程池目前的状态来触发不同的操作：</p>
<ol>
<li>如果当前线程池中正在运行的线程 &lt; 核心线程数： 直接创建线程给任务执行</li>
<li>如果当前线程池中正在运行的线程 &gt;= 核心线程数:<ul>
<li>阻塞队列没满：把任务放进阻塞队列中，正在运行的线程执行完之后会从阻塞队列中拿任务执行，没任务就阻塞（生产者消费者）</li>
<li>阻塞队列满了：<ul>
<li>如果当前正在工作的线程数 &lt; 最大线程数，就创建线程去执行任务</li>
<li>如果当前正在工作的线程数 &gt;= 最大线程数，就触发拒绝策略：</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略是一个接口，其设计如下：<br><img src="https://img-blog.csdnimg.cn/20200601175343997.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200601175249670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="四、线程池使用场景"><a href="#四、线程池使用场景" class="headerlink" title="四、线程池使用场景"></a>四、线程池使用场景</h1><h2 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a>场景1：快速响应用户请求</h2><p>描述：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>
<p>分析：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该<strong>不设置队列去缓冲并发任务</strong>，<strong>调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601180213236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h2><p>描述：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>
<p>分析：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，<strong>调整合适的corePoolSize去设置处理任务的线程数</strong>。在这里，<strong>设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200601180237988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">[Reference]</a></p>
<h1 id="五、线程池的几种类型"><a href="#五、线程池的几种类型" class="headerlink" title="五、线程池的几种类型"></a>五、线程池的几种类型</h1><h2 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h2><h3 id="a-特点"><a href="#a-特点" class="headerlink" title="a. 特点"></a>a. 特点</h3><p>FixedThreadPool 中创建了固定个数的线程，其 <strong>核心线程数 == 最大线程数</strong>，且<strong>阻塞队列长度为Integer.MAX_VALUE（就是一个LinkedBlockingQueue）</strong>.</p>
<h3 id="b-创建方法"><a href="#b-创建方法" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-使用须知"><a href="#c-使用须知" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><ul>
<li>因为阻塞队列是LinkedBlockingQueue, 因此，所以几乎不会触发拒绝策略，如果提交任务数过多的话，可能会导致OOM.</li>
</ul>
<h2 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. SingleThreadExecutor</h2><h3 id="a-特点-1"><a href="#a-特点-1" class="headerlink" title="a. 特点"></a>a. 特点</h3><p>线程池中只有1个线程，并保证恒有一个线程（就是这个线程如果挂了，还会创建1个，保证线程池中有1个线程） <strong>核心线程数 == 最大线程数 == 1</strong> ，其他参数和FixedThreadPool相同</p>
<h3 id="b-创建方法-1"><a href="#b-创建方法-1" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-使用须知-1"><a href="#c-使用须知-1" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><p>和FixedThreadPool相同，可能会导致OOM</p>
<h2 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2. CachedThreadPool"></a>2. CachedThreadPool</h2><h3 id="a-特点-2"><a href="#a-特点-2" class="headerlink" title="a. 特点"></a>a. 特点</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。 什么叫根据需要，其实就是，如果一个线程一段时间没有使用的话，就给销毁掉..  它的实现方法其实就是 <strong>核心线程数 == 0, 最大线程数 == Integer.MAX_VALUE</strong>,</p>
<p>keepAliveTime是线程池中空闲线程等待工作的超时时间。</p>
<p>当线程池中线程数量大于corePoolSize（核心线程数量）或设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</p>
<p>因此，如果核心线程数为0的话，只要创建的线程空闲了keepAliveTime，就会被销毁..</p>
<h3 id="b-创建方法-2"><a href="#b-创建方法-2" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p>
<h3 id="c-使用须知-2"><a href="#c-使用须知-2" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><p>因为最大线程数没有上线，因此极端情况也会OOM</p>
<h2 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3. ScheduledThreadPoolExecutor"></a>3. ScheduledThreadPoolExecutor</h2><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong></p>
<h1 id="六、确定线程池大小"><a href="#六、确定线程池大小" class="headerlink" title="六、确定线程池大小"></a>六、确定线程池大小</h1><p>具体问题具体分析，一个简单且适用面儿比较光的场合：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——动态代理及实现</title>
    <url>/2020/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在啃Spring的AOP之前，在复习以下动态代理及其实现方式</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>在不使用代理模式的场景下，对象A想使用对象B的功能，一个方法是通过持有对对象B的引用，然后直接使用对象B提供的服务了。</p>
<p> 而使用了代理模式，则引入一个第三方的代理对象，这个代理对象持有着对对象B的引用，可以调用对象B的服务与资源，而如果有对象希望使用对象B提供的服务的话，则不再去找对象B，而是去找这个代理对象。 如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200507203649883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很多思想都是通过引入一个第三者来去实现某个功能，使得程序耦合度更低，或者提高代码复用性等等，例如发布-订阅模式，控制反转，领域模型的思想等等，而这里的代理模式，也是引入了一个第三者（代理对象），这个对象对外提供的接口仅仅是对某一主要功能的服务接口，代理对象内部持有真正提供这一服务的对象，通过它们来调用服务，同时，在代理对象这一层面对方法进行增强。。。</p>
<a id="more"></a>

<p>例如：当我们调用dao接口访问数据库的时候，我们关注的是访问数据库这一过程，而记录日志，安全管理，事务管理这一类事情尽管也很重要，但并不是我们关注的对象，并且这类事情不仅仅只是在这一次访问数据库才会去做的，而是每次访问数据库都要去做的。。<br><img src="https://img-blog.csdnimg.cn/20200507205459191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="代理模式的两种实现方式"><a href="#代理模式的两种实现方式" class="headerlink" title="代理模式的两种实现方式"></a>代理模式的两种实现方式</h1><p>在实现代理模式之前，脑中要有2个关键核心的东西， 代理对象 = 被代理对象 + 切面逻辑， 也许这么说并不是非常严谨准确，但方便对代理模式的学习。</p>
<h2 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h2><p>静态代理就是在编译时就已经确定了怎样去增强方法，也就是，把切面的逻辑都写死在代理对象里面。<strong>就是说，在代理类里，就已经确定了代理对象 和 切面逻辑。（毕竟都写死在里面了）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:50 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 9:05 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 因为主要功能都是提供某一个服务，实现某一个服务的话，往往也是要去实现某一个接口（单一责任原则），因此代理对象往往会和被代理对象实现同一个接口。 </span></span><br><span class="line"> <span class="comment">// 例如，这里被代理对象是（ToCPaymentImpl implemets Pay） 也是实现了Pay接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPayProxy</span> <span class="keyword">implements</span> <span class="title">Pay</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pay payment;  <span class="comment">// 被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticPayProxy</span><span class="params">(Pay payment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payment = payment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        postProcessBeforePayment();  <span class="comment">// 增强逻辑</span></span><br><span class="line">        payment.pay(); <span class="comment">// 真正的业务逻辑，我们所关心的</span></span><br><span class="line">        postProcessAfterPayment(); <span class="comment">// 增强逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforePayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付前需要做的一些事情～～～ 我要支付啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessAfterPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付后需要做的一些事情～～～支付完啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ge myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myAOP.proxy.impl.ToCPaymentImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pay userPay = <span class="keyword">new</span> StaticPayProxy(<span class="keyword">new</span> ToCPaymentImpl());</span><br><span class="line">        userPay.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020050721170085.png" alt="在这里插入图片描述"><br>静态代理带来的弊端就是，增强的代码被写死到某一个固定的代理类中，这样使得增强的代码无法被复用。 例如，上面的例子中，我们又来了一个ToC的Payment需要去实现的话，那么也许业务逻辑不一样，但是增强的方法实际上是一样的，但我们确不得不重新在新的代理对象里再写一遍这个增强方法。。 为了能够使得增强代码复用， 可以用动态代理来做。</p>
<h2 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h2><p>动态代理是在运行时去确定增强的方法，在运行时将一些切面逻辑给织入到我们的程序中。<strong>也就是说，在运行时才确定 被代理对象 + 切面逻辑</strong> 。  而下面的2种动态代理的实现，实际上也主要就是学习使用JDK和第三方库提供给我们的强大功能，即：</p>
<ol>
<li>切面逻辑抽象化的功能 （JDK里用的InvovationHandler，Cglib里是实现了CallBack接口的Interceptor）</li>
<li>代理对象创建的功能（JDK里用的是Proxy类，Cglib里用的是Enhancer类）</li>
</ol>
<h3 id="2-1-使用JDK的提供的动态代理"><a href="#2-1-使用JDK的提供的动态代理" class="headerlink" title="2.1 使用JDK的提供的动态代理"></a>2.1 使用JDK的提供的动态代理</h3><p>jdk1.3之后就提供了动态代理的功能.</p>
<h4 id="1-创建将切面逻辑抽象化的Handler对象"><a href="#1-创建将切面逻辑抽象化的Handler对象" class="headerlink" title="1. 创建将切面逻辑抽象化的Handler对象"></a>1. 创建将切面逻辑抽象化的Handler对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.corba.se.spi.ior.ObjectKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:53 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用需要调用的核心方法, 然后在这个方法周围进行织入~</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理的对象, 注意，是代理的对象！！！</span></span><br><span class="line"><span class="comment">     *              不是被代理的对象！！而往往内部调用的都是被代理对象的方法！！</span></span><br><span class="line"><span class="comment">     *              所以需要通过其他方式来得到被代理对象，这里通过有参构造方法实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method  被代理对象的指定方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;  <span class="comment">// 这个才是被代理的对象！！通过有参构造函数传入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PaymentHandler</span><span class="params">(Object targetObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供的是被代理对象所要提供的方法，但在其基础上又添加了一部分逻辑</span></span><br><span class="line">    <span class="comment">// 就是下面的postProcessBeforePayment和postProcessAfterPayment</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        postProcessBeforePayment();</span><br><span class="line">        Object res = method.invoke(targetObject, args); <span class="comment">// 这里使用的是被代理对象～</span></span><br><span class="line">        postProcessAfterPayment();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforePayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付前需要做的一些事情～～～ 我要支付啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessAfterPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付后需要做的一些事情～～～支付完啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代理对象的创建"><a href="#2-代理对象的创建" class="headerlink" title="2. 代理对象的创建"></a>2. 代理对象的创建</h4><p>为了使代码更加优雅，能够统一创建代理对象的接口（即提供被代理对象+抽象出来的切面对象（这里是handler）），这里就对代理对象的创建再做一层封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 6:00 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxyUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(T proxyObject, InvocationHandler handler)</span></span>&#123;</span><br><span class="line">        ClassLoader classLoader = proxyObject.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = proxyObject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// classloader是被代理对象的classloader, interfaces是被代理对象实现的所有接口</span></span><br><span class="line">        Object res = Proxy.newProxyInstance(classLoader, interfaces, handler);</span><br><span class="line">        <span class="keyword">return</span> (T)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myAOP.proxy.impl.ToCPaymentImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pay userPay = <span class="keyword">new</span> ToCPaymentImpl();</span><br><span class="line">        PaymentHandler paymentHandler = <span class="keyword">new</span> PaymentHandler(userPay);</span><br><span class="line">        Pay pay = JDKDynamicProxyUtil.newProxyInstance(userPay, paymentHandler);</span><br><span class="line">        pay.pay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但使用JDK自带的动态代理库的话，<strong>被代理对象一定要实现了某一个接口</strong>，如果被代理对象没有实现任何接口的话，就不能用这个方法… 例如下面这个情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 6:53 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayWithoutInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户进行了支付（本操作未实现接口）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myAOP.proxy.impl.ToCPaymentImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// JDK提供的动态代理，是通过实例化一个实现了被代理对象实现的接口，这样它们就都能够被同一个接口给接着</span></span><br><span class="line">        <span class="comment">// 但如果被代理对象根本就没有实现任何接口，那么就会报错，例如下面这个：</span></span><br><span class="line">        PayWithoutInterface userPay = <span class="keyword">new</span> PayWithoutInterface();</span><br><span class="line">        PaymentHandler paymentHandler = <span class="keyword">new</span> PaymentHandler(userPay);</span><br><span class="line">        PayWithoutInterface pay = JDKDynamicProxyUtil.newProxyInstance(userPay, paymentHandler);</span><br><span class="line">        pay.pay();</span><br><span class="line">        <span class="comment">// 就会抛出Exception in thread "main" java.lang.ClassCastException:</span></span><br><span class="line">        <span class="comment">// com.sun.proxy.$Proxy0 cannot be cast to myAOP.proxy.PayWithoutInterface</span></span><br><span class="line">        <span class="comment">//	at myAOP.proxy.proxyMain.main</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果使用Cglib的话，就不存在这一问题了。。</p>
<h3 id="2-2-使用cglib实现动态代理"><a href="#2-2-使用cglib实现动态代理" class="headerlink" title="2.2 使用cglib实现动态代理"></a>2.2 使用cglib实现动态代理</h3><p>cglib是第三方库，基于asm实现的，即直接对字节码进行代码织入</p>
<h4 id="1-创建将切面逻辑抽象化的Callback对象"><a href="#1-创建将切面逻辑抽象化的Callback对象" class="headerlink" title="1. 创建将切面逻辑抽象化的Callback对象"></a>1. 创建将切面逻辑抽象化的Callback对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 7:00 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o   代理对象 （注意，是代理对象，不是被代理对象！！！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method   需要调用的被代理对象的方法..</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args  方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy  包装了被代理对象方法的对象...可以调用invokeSuper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        postProcessBeforePayment(); <span class="comment">// 增强的逻辑</span></span><br><span class="line">        Object res = methodProxy.invokeSuper(o, args); <span class="comment">// 实际调用的核心方法</span></span><br><span class="line">        postProcessAfterPayment(); <span class="comment">// 增强的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeforePayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付前需要做的一些事情～～～ 我要支付啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessAfterPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"支付后需要做的一些事情～～～支付完啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看似没有实现Callback接口，是因为MethodInterceptor接口已经继承了Callback接口了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代理对象的创建-1"><a href="#2-代理对象的创建-1" class="headerlink" title="2. 代理对象的创建"></a>2. 代理对象的创建</h4><p>这里同样对创建逻辑进行了一层封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 7:04 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(T targetObject, Callback methodInterceptor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(targetObject.getClass(), methodInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myAOP.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myAOP.proxy.impl.ToCPaymentImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> czf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/5/7 5:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxyMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Pay userPay = new StaticPayProxy(new ToCPaymentImpl());</span></span><br><span class="line"><span class="comment">//        userPay.pay();</span></span><br><span class="line"><span class="comment">//        Pay userPay = new ToCPaymentImpl();</span></span><br><span class="line"><span class="comment">////        userPay.pay();</span></span><br><span class="line"><span class="comment">//        PaymentHandler paymentHandler = new PaymentHandler(userPay);</span></span><br><span class="line"><span class="comment">//        Pay pay = JDKDynamicProxyUtil.newProxyInstance(userPay, paymentHandler);</span></span><br><span class="line"><span class="comment">//        pay.pay();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK提供的动态代理，是通过实例化一个实现了被代理对象实现的接口，这样它们就都能够被同一个接口给接着</span></span><br><span class="line">        <span class="comment">// 但如果被代理对象根本就没有实现任何接口，那么就会报错，例如下面这个：</span></span><br><span class="line"><span class="comment">//        PayWithoutInterface userPay = new PayWithoutInterface();</span></span><br><span class="line"><span class="comment">//        PaymentHandler paymentHandler = new PaymentHandler(userPay);</span></span><br><span class="line"><span class="comment">//        PayWithoutInterface pay = JDKDynamicProxyUtil.newProxyInstance(userPay, paymentHandler);</span></span><br><span class="line"><span class="comment">//        pay.pay();</span></span><br><span class="line">        <span class="comment">// 就会抛出Exception in thread "main" java.lang.ClassCastException:</span></span><br><span class="line">        <span class="comment">// com.sun.proxy.$Proxy0 cannot be cast to myAOP.proxy.PayWithoutInterface</span></span><br><span class="line">        <span class="comment">//	at myAOP.proxy.proxyMain.main</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于这种情况，可以考虑使用cglib</span></span><br><span class="line">        PayWithoutInterface userPay = <span class="keyword">new</span> PayWithoutInterface();</span><br><span class="line">        Callback interceptor = <span class="keyword">new</span> PayInterceptor();</span><br><span class="line">        PayWithoutInterface userPayProxy = CglibUtil.newInstance(userPay, interceptor);</span><br><span class="line">        userPayProxy.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200507215449172.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java并发基础总结</title>
    <url>/2020/07/09/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，<strong>用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异</strong>，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。为了实现了JVM的跨平台性，在向上提供了一系列的指令的同时，也提供了一些编程规则需要理解和遵守，比如Happens-Before原则，as-if-serial原则，主内存工作内存的概念等等。  </p>
<a id="more"></a>
<p>编译器，处理器进行不同层次上的指令重排会对多线程编程造成一定的影响，对于一些不应该进行指令重排的场景下，Java编译器通过在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序，JMM把内存屏障指令分为如下四类：<br><img src="https://img-blog.csdnimg.cn/20200401210939258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从JDK5开始，Java使用新的JSR-133内存模型，其主要作用就是提供了happens-before原则，屏蔽掉了底层解决内存可见行问题的实现，编程者只要记住happens-before原则，并在理解这一原则下进行编程，happens-before原则为：</p>
<ul>
<li>程序顺序原则：一个线程中的每个操作，都happens-before于该线程中的任意后续操作；</li>
<li>监视器锁规则：对一个锁的解锁，一定happens-before于随后对这个锁的读</li>
<li>volatile变量规则：对一个volatile域的<strong>写</strong>，happens-before于任意后续对这个volatile域的<strong>读</strong>.</li>
<li>传递性：A happens-before B， B happens-before C, 那么 A happens-before C.</li>
</ul>
<h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a><font color=brown>Happens-Before</font></h2><h3 id="1-程序次序规则："><a href="#1-程序次序规则：" class="headerlink" title="1. 程序次序规则："></a>1. 程序次序规则：</h3><p>在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p>
<h3 id="2-管程锁定规则："><a href="#2-管程锁定规则：" class="headerlink" title="2. 管程锁定规则："></a>2. 管程锁定规则：</h3><p>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p>
<h3 id="3-volatile变量规则："><a href="#3-volatile变量规则：" class="headerlink" title="3. volatile变量规则："></a>3. volatile变量规则：</h3><p>就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p>
<h3 id="4-线程启动规则："><a href="#4-线程启动规则：" class="headerlink" title="4. 线程启动规则："></a>4. 线程启动规则：</h3><p>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p>
<h3 id="5-线程终止规则："><a href="#5-线程终止规则：" class="headerlink" title="5. 线程终止规则："></a>5. 线程终止规则：</h3><p>在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p>
<h3 id="6-线程中断规则："><a href="#6-线程中断规则：" class="headerlink" title="6. 线程中断规则："></a>6. 线程中断规则：</h3><p>对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p>
<h3 id="7-传递规则："><a href="#7-传递规则：" class="headerlink" title="7. 传递规则："></a>7. 传递规则：</h3><p>这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p>
<h3 id="8-对象终结规则："><a href="#8-对象终结规则：" class="headerlink" title="8. 对象终结规则："></a>8. 对象终结规则：</h3><p>这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a><font color=brown>as-if-serial</font></h2><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</strong>。但依然会对毫无关联的两个语句进行指令重排，比如 int a=1; int b = 2; 它们的先后顺序可能会不一样.</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title=" 主内存和工作内存"></a><font color=brown> 主内存和工作内存</font></h2><p>JMM定义的内存变量的访问规则（这里的变量是指线程共享的变量），有了主内存和工作内存的概念。 Java虚拟机规定所有变量（非线程私有的变量）都存在主内存中，而线程私有的局部变量存在线程独有的工作内存中，这两个概念比较类似Java内存规范中的堆（主内存）和虚拟机栈（工作内存），只是比较类似！</p>
<p>而<font color=red><strong>解决主内存的中的变量和工作内存中的变量的同步的方式</strong></font>就是用volatile关键字。</p>
<h1 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h1><ul>
<li><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ul>
<li>保证了“共享变量”在多线程环境下的“可见性”.</li>
</ul>
</li>
<li><h2 id="底层实现原则："><a href="#底层实现原则：" class="headerlink" title="底层实现原则："></a>底层实现原则：</h2><ul>
<li>对被volatile修饰的变量进行写操作的时候，JVM会向处理器发送一条#Lock前缀指令，这个指令的作用就是将对应缓存行的数据写回到被缓存的内存。</li>
<li>一个处理器将缓存回写到内存<code>&lt;addr&gt;</code>中，那么其他处理器中对<code>&lt;addr&gt;</code>内存地址的缓存都会被标记成’失效’。（缓存一致性协议MESI：由嗅探技术实现，每个缓存行会有一个标示位，分别代表 ：M(被修改)，E(独占的), S(共享的), I(无效的), 若读取的缓存行是无效，那么会重新从内存读取）</li>
</ul>
</li>
</ul>
<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1. 作用："></a>1. 作用：</h2><p>对于 Synchronized 关键字而言，每一个Java对象都可以作为锁，具体表现为：</p>
<ul>
<li>普通<code>Synchronized</code>方法，锁是当前对象</li>
<li>静态<code>Synchronized</code>方法，锁是当前类的Class对象</li>
<li>对于<code>Synchronized</code>方法块，锁是括号里配置的对象</li>
</ul>
<h2 id="2-对象头："><a href="#2-对象头：" class="headerlink" title="2. 对象头："></a>2. 对象头：</h2><ul>
<li>普通对象的对象头占2个字，分别为：<ul>
<li>Mark Word：存储了对象的HashCode和锁信息</li>
<li>Class Metadata Address：存储对象类型的数据指针</li>
</ul>
</li>
<li>数组类对象的对象头占3个字，除了上面两个还有一个：<ul>
<li>Array Length: 数组的长度</li>
</ul>
</li>
</ul>
<h3 id="Mark-Word："><a href="#Mark-Word：" class="headerlink" title="Mark Word："></a>Mark Word：</h3><p><img src="https://img-blog.csdnimg.cn/20200401195923419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401200123515.png" alt="在这里插入图片描述"></p>
<h2 id="3-锁的升级和对比"><a href="#3-锁的升级和对比" class="headerlink" title="3. 锁的升级和对比:"></a>3. 锁的升级和对比:</h2><p><a href="https://www.cnblogs.com/pomer-huang/p/10965228.html" target="_blank" rel="noopener">https://www.cnblogs.com/pomer-huang/p/10965228.html</a><br><img src="https://img-blog.csdnimg.cn/20200401200452817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在讲重量级锁的调用的时候，可以说一下Java对管程的实现，即每一个对象都可以被视作一个MonitorObject，且维护着一个WaitSet，EntrySet，具体可以看 <a href="https://www.cnblogs.com/minikobe/p/12123065.html" target="_blank" rel="noopener">这个</a> 。<br><img src="https://img-blog.csdnimg.cn/20200613143648450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-原子操作的实现："><a href="#4-原子操作的实现：" class="headerlink" title="4. 原子操作的实现："></a>4. 原子操作的实现：</h2><ul>
<li><h3 id="处理器实现院子操作："><a href="#处理器实现院子操作：" class="headerlink" title="处理器实现院子操作："></a>处理器实现院子操作：</h3><ul>
<li><h4 id="1-总线锁："><a href="#1-总线锁：" class="headerlink" title="1.总线锁："></a>1.总线锁：</h4><ul>
<li>处理器提供一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将会被阻塞，此时处理器可以独享内存。缺点是，内存的不同地址之间其实不存在同步关系，这样会使得效率很低.</li>
</ul>
</li>
<li><h4 id="2-缓存锁"><a href="#2-缓存锁" class="headerlink" title="2. 缓存锁"></a>2. 缓存锁</h4><ul>
<li>利用<a href="https://blog.csdn.net/martin_ke/article/details/88851393" target="_blank" rel="noopener">缓存一致性协议</a>（如MESI协议），和处理器提供的LOCK指令对指定内存上锁，完成了对共享资源操作的互斥。</li>
<li>需要注意的是以下两个情况不能使用缓存锁：<ol>
<li>数据无法写入到缓存中，或操作数据跨多个缓存行。</li>
<li>处理器不支持缓存锁，此时会使用总线锁.</li>
</ol>
</li>
</ul>
</li>
<li><h3 id="Java实现原子操作："><a href="#Java实现原子操作：" class="headerlink" title="Java实现原子操作："></a>Java实现原子操作：</h3><ul>
<li><h4 id="CAS操作-Compare-And-Swap"><a href="#CAS操作-Compare-And-Swap" class="headerlink" title="CAS操作 ( Compare And Swap )"></a>CAS操作 ( Compare And Swap )</h4>通过调用处理器提供的<code>CMPXCHG</code>指令信实现，CAS的作用是：相等则交换。</li>
</ul>
</li>
<li><h4 id="CAS遇到的三大问题和解决方法："><a href="#CAS遇到的三大问题和解决方法：" class="headerlink" title="CAS遇到的三大问题和解决方法："></a>CAS遇到的三大问题和解决方法：</h4><ul>
<li><p>ABA问题</p>
<ul>
<li>问题：CAS会先检查操作值是否发生变化，如果发生了A-&gt;B-&gt;A这种变化则发现不出来。</li>
<li>解决方法：通过增加版本号的方式来解决: 1A-&gt;2B-&gt;3A</li>
</ul>
<ul>
<li><p>循环时间开销大：</p>
<ul>
<li>问题：在循环尝试CAS时，会给CPU带来很大的执行开销。</li>
<li>解决方法：如果jvm能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令可以延迟CPU的执行并且不会因此清空cpu的指令流水的预读取。</li>
</ul>
<ul>
<li>问题：只能保证一个共享变量执行原子操作：</li>
<li>解决方法：将多个共享变量打包成一个就行了。从JDK1.5开始，JDK提供了AtomicReference类来保证引用对象的原子性！</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ReentrantLock与AQS"><a href="#ReentrantLock与AQS" class="headerlink" title="ReentrantLock与AQS"></a>ReentrantLock与AQS</h1><p><a href="详解AQS.md">详情</a></p>
<hr>
<h1 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a>start和run的区别</h1><p><img src="https://img-blog.csdnimg.cn/20200612201742112.png" alt="在这里插入图片描述"></p>
<ul>
<li>start方法是创建一个新的子线程并启动（调用run方法）</li>
<li>run方法只是Thread的一个普通方法的调用</li>
</ul>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><h2 id="1-新建-New-创建后尚未启动的线程的状态"><a href="#1-新建-New-创建后尚未启动的线程的状态" class="headerlink" title="1. 新建(New): 创建后尚未启动的线程的状态"></a>1. 新建(New): 创建后尚未启动的线程的状态</h2><h2 id="2-运行-Runnable-包含Running和Ready"><a href="#2-运行-Runnable-包含Running和Ready" class="headerlink" title="2. 运行(Runnable):包含Running和Ready"></a>2. 运行(Runnable):包含Running和Ready</h2><h2 id="3-无限期等待-Waiting-不会被分配CPU执行时间，需要被唤醒"><a href="#3-无限期等待-Waiting-不会被分配CPU执行时间，需要被唤醒" class="headerlink" title="3. 无限期等待(Waiting): 不会被分配CPU执行时间，需要被唤醒"></a>3. 无限期等待(Waiting): 不会被分配CPU执行时间，需要被唤醒</h2><ul>
<li>没有设置Timeout参数的Object.wait()方法</li>
<li>没有设置Timeout参数的Thread.join()方法</li>
<li>LockSupport.part()<h2 id="4-限期等待-timed-waiting-：在一定时间后会由系统自动唤醒"><a href="#4-限期等待-timed-waiting-：在一定时间后会由系统自动唤醒" class="headerlink" title="4. 限期等待(timed waiting)：在一定时间后会由系统自动唤醒"></a>4. 限期等待(timed waiting)：在一定时间后会由系统自动唤醒</h2></li>
<li>Thread.sleep()</li>
<li>没有设置Timeout参数的Object.wait() 方法</li>
<li>没有设置Timeout参数的Thread.join() 方法</li>
<li>LockSupport.parkNanos() 方法</li>
<li>LockSupport.parkUntil() 方法</li>
</ul>
<h2 id="5-阻塞-Blocked-等待获取排他锁"><a href="#5-阻塞-Blocked-等待获取排他锁" class="headerlink" title="5. 阻塞(Blocked): 等待获取排他锁"></a>5. 阻塞(Blocked): 等待获取排他锁</h2><ul>
<li>就是在竞争锁的时候，被阻塞了（例如因Lock 或者synchronize 关键字产生的状态）</li>
</ul>
<h2 id="6-终止（terminate）：终止状态"><a href="#6-终止（terminate）：终止状态" class="headerlink" title="6. 终止（terminate）：终止状态"></a>6. 终止（terminate）：终止状态</h2><p><img src="https://img-blog.csdnimg.cn/20200613143919461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h1><p>这几个方法光知道是个啥，但理解的还不够深入，这里做一下总结。</p>
<h2 id="1-wait-notify-notifyAll"><a href="#1-wait-notify-notifyAll" class="headerlink" title="1. wait/notify/notifyAll"></a>1. wait/notify/notifyAll</h2><p>在聊上面这个常见的方法之前，有必要先知道什么是管程。</p>
<p>当我们对临界区进行实现的时候，往往都是通过PV操作来实现的，但让程序员手动去做PV操作，很容易发生死锁。 所以为了方便编程，减少死锁出现的可能，我们希望能有一种数据结构或是软件模块来专门为我们提供对“临界区”的实现，这就是管程了～（但单单就说管程就是对临界区的实现是不准确的，继续往下看）</p>
<p>但仅仅是实现临界区还是不够的，比如，当线程A获取到锁了之后，进入了临界区，这个时候因为一些<font color=red><strong>外部条件X</strong></font>, 而导致无法进行下去，这个时候就需要等待这个外部条件X的发生… 而假设这个外部条件X的发生是需要另一个线程B进入到当前的这个“临界区”中才能触发，而因为线程A已经处于临界区中了，所以线程B需要等待线程A退出临界区才能继续执行。。 于是。。就变成了线程A在等线程B，线程B在等线程A，死锁出现了。。</p>
<p>因此，解决临界区中的线程同步问题，也是管程需要实现的。</p>
<p>一个解决方案就是，在临界区中的线程A一旦发现自己想要的外部条件没有发生，而不能够继续进行下去了的时候，就主动释放掉当前获取的这个临界区的锁，然后让其他线程进入到这个临界区来触发这个“外部条件X”的发生。。  等到这个外部条件X发生了之后，再通知线程A（之前因这个条件而释放掉锁的那个线程）重新去竞争锁，继续执行临界区..     </p>
<p>这个方法流程是不是很熟悉？ 没错，这不就是wait和notify嘛。。</p>
<p>因此，管程的实现主要就是：</p>
<ul>
<li>临界区的实现</li>
<li>monitor 对象及锁的实现</li>
<li>条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现</li>
</ul>
<p>然后就可以了解下<a href="https://www.jianshu.com/p/7f8a873d479c" target="_blank" rel="noopener">Java对管程的实现</a>了。</p>
<h3 id="a-对临界区的实现"><a href="#a-对临界区的实现" class="headerlink" title="a. 对临界区的实现"></a>a. 对临界区的实现</h3><p>Synchronized的同步块,  ReentrantLock在lock和unlock期间的那段代码.. 都是对临界区的实现..</p>
<blockquote>
<p>在Java中，每个对象都有两个池，锁(monitor)池和等待池</p>
</blockquote>
<blockquote>
<p>锁池：假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
</blockquote>
<blockquote>
<p>等待池：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.</p>
</blockquote>
<h3 id="b-条件变量以及定义在-monitor-对象上的-wait，signal-操作的实现"><a href="#b-条件变量以及定义在-monitor-对象上的-wait，signal-操作的实现" class="headerlink" title="b. 条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现"></a>b. 条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现</h3><p>对于Synchronized，只实现了wait和signal操作…<br>如果想使用更细粒度的条件变量，来控制临界区内线程的同步，那么可以使用ReentrantLock来做.. </p>
<p>ReentrantLock提供了Condition变量，作为条件变量，对应的方法是 condition.await() 和 condition.signal() </p>
<h2 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h2><p>在Java中，每个对象都有两个池，锁(monitor)池和等待池</p>
<p>锁池:  假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
<p>等待池:  假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p>
<h2 id="wait原理："><a href="#wait原理：" class="headerlink" title="wait原理："></a>wait原理：</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<p>必读：<br><a href="https://blog.csdn.net/u014561933/article/details/58639411?utm_source=blogxgwz4" target="_blank" rel="noopener">sleep()和wait()方法与对象锁、锁池、等待池</a></p>
<p><a href="https://blog.csdn.net/qq_15037231/article/details/103440060" target="_blank" rel="noopener">Thread.yield()和Thread.sleep(0)</a></p>
<p><a href="https://blog.csdn.net/weixin_42621338/article/details/82899060?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">推荐阅读</a></p>
<h2 id="wait和park的区别"><a href="#wait和park的区别" class="headerlink" title="wait和park的区别"></a>wait和park的区别</h2><blockquote>
<p>我们在编程的时候必须能保证wait方法比notify方法先执行。如果notify方法比wait方法晚执行的话，就会导致因wait方法进入休眠的线程接收不到唤醒通知的问题。</p>
</blockquote>
<blockquote>
<p>而park、unpark则不会有这个问题，我们可以先调用unpark方法释放一个许可证，这样后面线程调用park方法时，发现已经许可证了，就可以直接获取许可证而不用进入休眠状态了。</p>
</blockquote>
<blockquote>
<p>LockSupport.park() 的实现原理是通过二元信号量做的阻塞，要注意的是，这个信号量最多只能加到1。我们也可以理解成获取释放许可证的场景。unpark()方法会释放一个许可证，park()方法则是获取许可证，如果当前没有许可证，则进入休眠状态，知道许可证被释放了才被唤醒。无论执行多少次unpark()方法，也最多只会有一个许可证。</p>
</blockquote>
<p><font color=red>另外，和wait方法不同，执行park进入休眠后并不会释放持有的锁。<br>并且，调用wait方法需要已经获取到锁，而park则不需要 </font></p>
<p><strong>wait的局限，以及Condition的出场</strong></p>
<p>使用wait的一个前提就是在sync的同步块里，而这又导致了在同步块里的条件变量只有一个，尽管可以通过共享变量的方式来实现“需要多个条件变量的场合”，但这样不仅实现的复杂度高，而且也不是很高效。因此，为了让在同步块中使用更多样的条件变量（即对某一资源或者某一个事件的等待），ReentrantLock就提供了Condition这一个神器，一个Lock可以new出多个Condition，即多个等待队列。</p>
<p>所以，await/signal, 可以看成强化版的 wait/notify</p>
<p><a href="https://blog.csdn.net/boguesfei/article/details/81736489" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h1><h2 id="1-信号量和条件变量的区别是什么？"><a href="#1-信号量和条件变量的区别是什么？" class="headerlink" title="1. 信号量和条件变量的区别是什么？"></a>1. 信号量和条件变量的区别是什么？</h2><ul>
<li>条件变量可以通过<code>signal()</code>唤醒队首阻塞线程，使用<code>signalAll()</code>来唤醒所有阻塞线程；而信号量只能通过<code>release()</code>唤醒队首阻塞线程.</li>
<li>信号量可以初始化初始的值，但条件变量不可以，但条件变量+共享变量可以实现初始值大于0的信号量的功能。（个人理解成，条件变量的功能类似一个初始值为0的信号量 ）。</li>
</ul>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java并发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>错排问题（装错信封问题）</title>
    <url>/2020/07/10/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%85%E9%94%99%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><blockquote>
<p>某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。<br>粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？</p>
</blockquote>
<a id="more"></a>

<p>换句话说：</p>
<p>对[0,n)进行全排列，对于每一个排列A，对于任意i∈[0,n) , 都满足 A[i]!=i ， 求这种排列的个数.</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ol>
<li><p>面试遇到这种题，n应该不会太大，用下面这个思路和递推就能搞定<br><img src="https://img-blog.csdnimg.cn/20200605173948874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>如果是笔试的话…就直接上dp来做..</p>
</li>
<li><p>最后象征性的放个公式<br><img src="https://img-blog.csdnimg.cn/20200605174836735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>详解AQS</title>
    <url>/2020/07/09/%E8%AF%A6%E8%A7%A3AQS/</url>
    <content><![CDATA[<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><p>我们常用的j.u.c包里，提供了许多强大的同步工具，例如ReentrantLock，Semphore，ReentrantReadWriteLock等，但当这些工具难以满足某个场景的需求时，我们就需要定制化我们自己的同步器，这时，我们可能会想，如果能有一个像Servlet这种只要重写某几个方法就能完成一把定制锁的实现的就好了！！ 没错，AQS就是提供了这样一种功能，它如果要实现一个同步器的大部分通用功能都帮我们实现好了，然后提供出抽象函数供我们重写来定制化自己想要的同步器。 实际上，上面所说的ReentrantLock，Semphore，ReentrantReadWriteLock等juc包中同步工具的实现，也都是在AQS的辅助下进行的“二次开发”。  例如在ReentrantLock继承了Lock接口，然后利用定制化了的继承了AQS的类，来去实现Lock接口。</p>
<a id="more"></a>

<hr>
<h1 id="AQS提供了什么功能"><a href="#AQS提供了什么功能" class="headerlink" title="AQS提供了什么功能"></a>AQS提供了什么功能</h1><p>同步器一般会包括两种方法，一种是acquire方法， 另一种是release方法； acquire方法是尝试获取锁操作，如果获取不到就阻塞(park)当前线程，并将其放入等待队列中；release方法是释放锁操作，然后会从等待队列中出队一个或多个被acquire阻塞的线程并将其唤醒(unpark). </p>
<p>j.u.c包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p>
<ul>
<li>阻塞(例如：acquire)和非阻塞（例如：tryAcquire）同步。</li>
<li>可选的超时设置，让调用者可以放弃等待</li>
<li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以（例如ReentrantLock中的<code>lockInterruptibly()</code>就是可在阻塞等待中被中断的，而<code>lock()</code>是阻塞等待中不可被中断的）。</li>
</ul>
<hr>
<h1 id="读源码之前需要知道的知识"><a href="#读源码之前需要知道的知识" class="headerlink" title="读源码之前需要知道的知识"></a>读源码之前需要知道的知识</h1><h2 id="AQS的内部队列"><a href="#AQS的内部队列" class="headerlink" title="AQS的内部队列"></a>AQS的内部队列</h2><p>在AQS中，被阻塞的线程会被打包成一个Node然后放到等待队列中，head指向队列头结点，tail指向尾结点，队列不存在时（未初始化时）的样子为：<code>head==tail==null</code> ，初始化之后，队列为空的情况为：<code>head==tail==dummy头结点</code>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200407163818175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>head指向dummy头结点，这个头结点存在的意义是为了方便队列操作，并且里面保存的thread恒为null。下面来看一下node每个字段的意思</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>为了抓住重点学习，这里只介绍Node里的重要成员：</p>
<ul>
<li>thread ：当前结点里保存的线程</li>
<li>prev，next：当前结点的前后指针，这里队列的实现是<strong>带有头结点的双向链表</strong>。 prev是靠近头结点那一端的，next是靠近尾结点那一端的。</li>
<li>waitStatus：初始状态为0。为-1时，表示存在正在阻塞等待的线程，结点入队之后，会自旋一次来再次尝试tryAcquire，如果依然失败，才会进入阻塞，自旋的这一次就是把waitStatus字段CAS成-1。 这一字段取值范围如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前结点为-1, 则说明后一个结点需要park阻塞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="AQS源码解读"><a href="#AQS源码解读" class="headerlink" title="AQS源码解读"></a>AQS源码解读</h1><p>这里先更新一下独占式的部分。。共享式的日后再看.</p>
<h2 id="独占式代码部分"><a href="#独占式代码部分" class="headerlink" title="独占式代码部分"></a>独占式代码部分</h2><p>先有个宏观上的理解，如下图：<br><img src="https://img-blog.csdnimg.cn/20200407154554112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中tryRelease，tryAcquire是非阻塞式获取锁。 有了宏观上的框架，再去看一下实现的细节。</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">	        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">	        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>短路原理</code>, 如果<code>tryAcquire</code>成功的话，就直接跳出if了； 如果 <code>tryAcquire</code>失败，那么会先执行<code>addWaiter</code>把当前线程打包成一个node放入等待队列， 然后再执行<code>acquireQueued</code>尝试一次自旋，如果依然无法获取到锁，就进入阻塞。</p>
<h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">     <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">     Node pred = tail;</span><br><span class="line">     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">         node.prev = pred;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">             pred.next = node;</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     enq(node);</span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>将当前线程打包成一个node， 然后将这个node入队，如果入队失败则有2种情况：</p>
<ul>
<li>队列还不存在（队列还没初始化）</li>
<li>在入队时，出现了同步问题。（这里的队列也是临界资源，如果CAS失败说明资源竞争失败）<br>当入队失败时，进入<code>enq</code>函数，这一函数的作用是：初始化队列并自旋入队操作。</li>
</ul>
<h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果队列未初始化，那么就初始化队列，如果已经初始化了，就将当前结点自旋入队，该方法一定返回true.</p>
<p><strong>线程被打包成结点，然后入队之后，会进入acquireQueued进行一次自旋try，如果依然失败就阻塞</strong></p>
<h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    booleanfailed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// （*）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断前驱结点是不是head，因为head指向的是dummy结点，因此，如果前驱结点就是head了，那么当前结点就是队首了！！ 然后只有队首的结点才有资格在第一次自旋的时候进行<code>tryAcquire</code> </p>
<p><strong>每一个结点不会改变自己的waitStatus, 只会改变在队列中前驱结点的waitStatus</strong> ， 因此，如果前驱结点是0，则通过CAS操作将其变为-1，然后自旋一次，如果前驱结点是-1，则说明已经自旋过一次了，然后才能进入 <code>parkAndCheckInterrupt</code>函数，也就是将当前结点的线程阻塞。</p>
<p>这个函数里的几个细节，如果队首元素成功tryAcquire，则需要进行出队操作，把当前结点设置成dummy结点就可以了。<br>在setHead的时候。 <strong>会将thread设置成null 也是用于help gc</strong> 。 同时也要手动让前驱结点的next设置为null， 方便gc回收..</p>
<p><strong>到此位置，线程就会被卡在<code>parkAndCheckInterrupt</code>这个函数中，等待被唤醒</strong></p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>release的实现就更短了，如果tryRelease成功的话，就看是否还存在阻塞等待的线程，<code>if (h != null &amp;&amp; h.waitStatus != 0)</code> 这句话的判断就是判断否还存在阻塞等待的线程。 如果h是null的话，则说明队列根本就不存在，更别说等待的线程了，如果h.waitStatus不是0的话，则说明队列里存在等待的线程node。</p>
<p>如果存在正在等待的线程的话，就<code>unparkSuccessor</code> , 即唤醒这个正在等待的队首线程. </p>
<h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，s是下一个需要被唤醒的node结点，然后后面会对其进行unpark（唤醒）操作。</p>
<h1 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h1><p>到目前位置，只是简单过完了一遍AQS的独占式的acquire和release操作， 它帮我们完成了一部分同步状态管理事情，但是最关键的<code>tryAcquire</code>和<code>tryRelease</code> 其实它是一个需要我们去重写的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="需要做的事情"><a href="#需要做的事情" class="headerlink" title="需要做的事情"></a>需要做的事情</h2><p>在使用AQS的时候，往往需要我们自己去重写：</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively：如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回 true。此方法只是 abstractqueuedsynchronizer.conditionobject 方法内进行内部调用，因此，如果不使用条件，则不需要定义它。</li>
</ul>
<p>在实现tryAcquire的时候，我们需要对内部的status进行操作，AQS也提供给了我们关于Status操作接口，分别是：</p>
<ul>
<li>getState()</li>
<li>setState(int)</li>
<li>compareAndSetState(int, int)</li>
</ul>
<p>源码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">state = newState;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AQS在使用的时候，往往是使用一个内部类继承AQS，然后重写上述提到的方法，然后就可以在当前类中使用这个内部类的acquire / release来实现同步了</strong></p>
<h2 id="使用AQS完成信号量的功能"><a href="#使用AQS完成信号量的功能" class="headerlink" title="使用AQS完成信号量的功能"></a>使用AQS完成信号量的功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解了AQS的原理之后，可以来趁热打铁的看一下ReentrantLock的加锁实现</p>
<h1 id="ReentrantLock的原理"><a href="#ReentrantLock的原理" class="headerlink" title="ReentrantLock的原理"></a>ReentrantLock的原理</h1><p>这里主要详细介绍一下ReentrantLock对AQS的两种实现方式：</p>
<ul>
<li>公平锁（FairSync）</li>
<li>非公平锁（NonfairSync）<br><img src="https://img-blog.csdnimg.cn/20200407212955709.png" alt="在这里插入图片描述"><br>其中Sync是公平锁和非公平锁的抽象基类，里面已经初步实现了一些方法，但其中的<code>lock()</code>方法和<code>tryAcquire()</code>方法依然是抽象的，需要子类去进行实现，而公平锁和非公平锁的主要区别也主要在这两个函数中，下面来看一下。</li>
</ul>
<h2 id="公平锁与非公平锁的实现区别"><a href="#公平锁与非公平锁的实现区别" class="headerlink" title="公平锁与非公平锁的实现区别"></a>公平锁与非公平锁的实现区别</h2><h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作:"></a>lock操作:</h3><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">	      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，非公平锁在lock的时候会进行一次CAS操作，如果直接获取到锁了的话，那么就直接继续执行。 在临界区的执行速度比较快的情况下，非公平锁会比公平锁要更快，因为在唤醒阻塞线程的过程中，有可能有其他线程已经取得锁然后执行完并释放了。。 </p>
<h3 id="tryAcquire操作："><a href="#tryAcquire操作：" class="headerlink" title="tryAcquire操作："></a>tryAcquire操作：</h3><h4 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 这里直接进行CAS ， 尝试拿锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 重入时，给state加一个acquires偏移量，对应release时会减去一次</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁-1"><a href="#公平锁-1" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 这里会先判断是否存在比当前线程等待更久的线程！</span></span><br><span class="line">    	<span class="comment">// 只有不存在等待的线程的时候，才有资格去尝试获取锁资源（CAS）</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 重入时，给state加一个acquires偏移量，对应release时会减去一次</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在tryAcquire时，公平锁会先判断是否存在比当前线程等待的更久的线程，如果不存在这样的线程，才能进行CAS尝试获取锁； 而非公平锁是直接进行CAS获取锁。</p>
<h2 id="关于Interrupt"><a href="#关于Interrupt" class="headerlink" title="关于Interrupt"></a>关于Interrupt</h2><p>我们知道， thread1.interrupt()就是将thread1的中断标志位置为1（Thread.interrupted()是检测并清除中断标志，thread1.isInterrupted()是仅仅检测thread1的中断标志但不清除）.</p>
<p><code>ReentrantLock()</code> 的<code>lock()</code>方法，thread因等待资源而被阻塞在等待队列中的时候，不会被打断，而是先将这个中断标记位记下来，然后当获取到锁资源之后，执行<code>selfInterrupt()</code>, 也就是在获得锁资源后打断自己！！  如果希望在阻塞队列中依然可以被打断的话，应该使用<code>lockInterruptibly</code> , 这个lock操作是可以允许线程在阻塞等待时被中断的！</p>
<p>到此为止，我们看到了在ReentrantLock中对tryAcquire和tryRelease的实现，分别实现了公平竞争和非公平竞争的场景，因为这里的ReentrantLock是独占式的锁（也就是说资源只允许被一个线程获取，也可以理解成01信号量），所以并没有实现 <code>tryAcquireShared</code>和<code>tryReleaseShared</code> 这两个方法。 实际上，我们在使用的时候也是，需要哪种模式就实现对应模式的acquire和release.  </p>
<p>对于 <code>tryAcquireShared</code>和<code>tryReleaseShared</code> 这两个方法的实现例子，可以去看看Semphore的源码，它就是只重写了<code>tryAcquireShared</code>和<code>tryReleaseShared</code>，理解完上面分析的代码之后，去看Semphore的源码也不会很困难了。。日后有时间再写<code>Semphore</code>的源码记录把。。</p>
]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>AQS</tag>
      </tags>
  </entry>
</search>
