<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式——动态代理及实现</title>
      <link href="/2020/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池学习小结</title>
      <link href="/2020/07/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/07/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么使用线程池"><a href="#一、为什么使用线程池" class="headerlink" title="一、为什么使用线程池"></a>一、为什么使用线程池</h1><h2 id="1-能够减少线程切换带来的开销"><a href="#1-能够减少线程切换带来的开销" class="headerlink" title="1. 能够减少线程切换带来的开销"></a>1. 能够减少线程切换带来的开销</h2><p>如果有大量执行时间很短的任务，那么上下文切换带来的时间开销甚至会超过任务执行的时间，这显然是不合理的。而使用线程池就能降低线程创建和销毁造成的损耗。</p><h2 id="2-能够提高响应速度"><a href="#2-能够提高响应速度" class="headerlink" title="2. 能够提高响应速度"></a>2. 能够提高响应速度</h2><p>任务到达时，无需等待线程创建即可立即执行。</p><h2 id="3-提高线程的可管理性"><a href="#3-提高线程的可管理性" class="headerlink" title="3. 提高线程的可管理性"></a>3. 提高线程的可管理性</h2><p>线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</p><a id="more"></a><h1 id="二、线程池的生命周期"><a href="#二、线程池的生命周期" class="headerlink" title="二、线程池的生命周期"></a>二、线程池的生命周期</h1><p>线程池有5种状态：<br><img src="https://img-blog.csdnimg.cn/20200601173458887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其生命周期转换如下入所示：<br><img src="https://img-blog.csdnimg.cn/20200601173510245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="三、线程池的工作原理"><a href="#三、线程池的工作原理" class="headerlink" title="三、线程池的工作原理"></a>三、线程池的工作原理</h1><p>线程池的3个重要参数：核心线程数，最大线程数和阻塞队列容量。</p><p>线程池将任务提交和任务执行进行了解耦，用户只需要负责提交，而不用去关心任务执行。 在提交一个任务的时候，会根据线程池目前的状态来触发不同的操作：</p><ol><li>如果当前线程池中正在运行的线程 &lt; 核心线程数： 直接创建线程给任务执行</li><li>如果当前线程池中正在运行的线程 &gt;= 核心线程数:<ul><li>阻塞队列没满：把任务放进阻塞队列中，正在运行的线程执行完之后会从阻塞队列中拿任务执行，没任务就阻塞（生产者消费者）</li><li>阻塞队列满了：<ul><li>如果当前正在工作的线程数 &lt; 最大线程数，就创建线程去执行任务</li><li>如果当前正在工作的线程数 &gt;= 最大线程数，就触发拒绝策略：</li></ul></li></ul></li></ol><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p>拒绝策略是一个接口，其设计如下：<br><img src="https://img-blog.csdnimg.cn/20200601175343997.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200601175249670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="四、线程池使用场景"><a href="#四、线程池使用场景" class="headerlink" title="四、线程池使用场景"></a>四、线程池使用场景</h1><h2 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a>场景1：快速响应用户请求</h2><p>描述：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p><p>分析：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该<strong>不设置队列去缓冲并发任务</strong>，<strong>调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200601180213236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a>场景2：快速处理批量任务</h2><p>描述：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p><p>分析：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，<strong>调整合适的corePoolSize去设置处理任务的线程数</strong>。在这里，<strong>设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200601180237988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">[Reference]</a></p><h1 id="五、线程池的几种类型"><a href="#五、线程池的几种类型" class="headerlink" title="五、线程池的几种类型"></a>五、线程池的几种类型</h1><h2 id="1-FixedThreadPool"><a href="#1-FixedThreadPool" class="headerlink" title="1. FixedThreadPool"></a>1. FixedThreadPool</h2><h3 id="a-特点"><a href="#a-特点" class="headerlink" title="a. 特点"></a>a. 特点</h3><p>FixedThreadPool 中创建了固定个数的线程，其 <strong>核心线程数 == 最大线程数</strong>，且<strong>阻塞队列长度为Integer.MAX_VALUE（就是一个LinkedBlockingQueue）</strong>.</p><h3 id="b-创建方法"><a href="#b-创建方法" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-使用须知"><a href="#c-使用须知" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><ul><li>因为阻塞队列是LinkedBlockingQueue, 因此，所以几乎不会触发拒绝策略，如果提交任务数过多的话，可能会导致OOM.</li></ul><h2 id="2-SingleThreadExecutor"><a href="#2-SingleThreadExecutor" class="headerlink" title="2. SingleThreadExecutor"></a>2. SingleThreadExecutor</h2><h3 id="a-特点-1"><a href="#a-特点-1" class="headerlink" title="a. 特点"></a>a. 特点</h3><p>线程池中只有1个线程，并保证恒有一个线程（就是这个线程如果挂了，还会创建1个，保证线程池中有1个线程） <strong>核心线程数 == 最大线程数 == 1</strong> ，其他参数和FixedThreadPool相同</p><h3 id="b-创建方法-1"><a href="#b-创建方法-1" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="c-使用须知-1"><a href="#c-使用须知-1" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><p>和FixedThreadPool相同，可能会导致OOM</p><h2 id="2-CachedThreadPool"><a href="#2-CachedThreadPool" class="headerlink" title="2. CachedThreadPool"></a>2. CachedThreadPool</h2><h3 id="a-特点-2"><a href="#a-特点-2" class="headerlink" title="a. 特点"></a>a. 特点</h3><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。 什么叫根据需要，其实就是，如果一个线程一段时间没有使用的话，就给销毁掉..  它的实现方法其实就是 <strong>核心线程数 == 0, 最大线程数 == Integer.MAX_VALUE</strong>,</p><p>keepAliveTime是线程池中空闲线程等待工作的超时时间。</p><p>当线程池中线程数量大于corePoolSize（核心线程数量）或设置了allowCoreThreadTimeOut（是否允许空闲核心线程超时）时，线程会根据keepAliveTime的值进行活性检查，一旦超时便销毁线程。</p><p>因此，如果核心线程数为0的话，只要创建的线程空闲了keepAliveTime，就会被销毁..</p><h3 id="b-创建方法-2"><a href="#b-创建方法-2" class="headerlink" title="b. 创建方法"></a>b. 创建方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><h3 id="c-使用须知-2"><a href="#c-使用须知-2" class="headerlink" title="c. 使用须知"></a>c. 使用须知</h3><p>因为最大线程数没有上线，因此极端情况也会OOM</p><h2 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3. ScheduledThreadPoolExecutor"></a>3. ScheduledThreadPoolExecutor</h2><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong></p><h1 id="六、确定线程池大小"><a href="#六、确定线程池大小" class="headerlink" title="六、确定线程池大小"></a>六、确定线程池大小</h1><p>具体问题具体分析，一个简单且适用面儿比较光的场合：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux指令学习/JVM指令</title>
      <link href="/2020/07/10/Linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0-JVM%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/07/10/Linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0-JVM%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试端口是否能连通"><a href="#1-测试端口是否能连通" class="headerlink" title="1. 测试端口是否能连通"></a>1. 测试端口是否能连通</h2><ul><li><code>telnet ip port</code> </li></ul><p><img src="https://img-blog.csdnimg.cn/20200602180129633.png" alt="在这里插入图片描述"></p><ul><li><code>ssh -v -p port username@ip</code><br>(-v表示是debug模式)<br><img src="https://img-blog.csdnimg.cn/20200602180352698.png" alt="在这里插入图片描述"></li><li><code>curl ip:port</code><br><img src="https://img-blog.csdnimg.cn/2020060218281616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><a id="more"></a><h2 id="2-远程登陆会话"><a href="#2-远程登陆会话" class="headerlink" title="2. 远程登陆会话"></a>2. 远程登陆会话</h2><ul><li>指令：ssh</li><li>SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。<br>远程登陆<code>ssh username@ip</code><h2 id="3-检测本机的端口网络连接情况"><a href="#3-检测本机的端口网络连接情况" class="headerlink" title="3. 检测本机的端口网络连接情况"></a>3. 检测本机的端口网络连接情况</h2></li><li>指令：netstat </li><li>检测本机的端口连接情况，可以使用netstat<br><code>netstat -ano | grep port</code><h2 id="4-查看某个进程的情况"><a href="#4-查看某个进程的情况" class="headerlink" title="4. 查看某个进程的情况"></a>4. 查看某个进程的情况</h2></li><li>指令： ps </li><li>查看某个进程的情况<br><code>ps -ef | grep pid</code> <h2 id="5-管道-正则匹配"><a href="#5-管道-正则匹配" class="headerlink" title="5. 管道 + 正则匹配"></a>5. 管道 + 正则匹配</h2></li><li>指令： <code>指令</code>  |  grep <code>正则表达式</code></li><li><code>grep ‘pattern‘ file</code> pattern为正则匹配字符串,file为输入文件<br>最常用的是配合管道来一起使用，即前一个指令的输出作为输入，然后用正则过滤，例如上面的<code>ps -ef</code> 就列出了所有的进程，然后 使用’|’ 作为管道连接字符，作为grep pid的输入, 就找到了指定pid的进程信息。</li></ul><h2 id="6-服务器上传-下载文件"><a href="#6-服务器上传-下载文件" class="headerlink" title="6. 服务器上传 / 下载文件"></a>6. 服务器上传 / 下载文件</h2><ul><li>指令：scp</li><li><code>scp [可选参数] file_source file_target</code></li></ul><p>从服务器上下载或上传文件.</p><p>上传：<br><code>scp ./1.txt root@xx.xx.xx.xx:/usr/local/software/</code><br>下载:<br><code>scp root@xx.xx.xx.xx:/usr/local/software/1.txt .</code> </p><h2 id="7-cpu负载很高怎么查看"><a href="#7-cpu负载很高怎么查看" class="headerlink" title="7. cpu负载很高怎么查看"></a>7. cpu负载很高怎么查看</h2><ul><li><p>执行top -c ，显示进程运行信息列表</p></li><li><p>键入P (大写p)，进程按照CPU使用率排序</p></li></ul><h3 id="案例一：CPU利用率100-怎么排查"><a href="#案例一：CPU利用率100-怎么排查" class="headerlink" title="案例一：CPU利用率100%怎么排查"></a>案例一：CPU利用率100%怎么排查</h3><h5 id="第一步：找到最消CPU性能的进程"><a href="#第一步：找到最消CPU性能的进程" class="headerlink" title="第一步：找到最消CPU性能的进程"></a>第一步：找到最消CPU性能的<font color=red>进程</font></h5><ol><li>top -c</li><li>键入大写P, 进程按照CPU使用率排序<br><img src="https://img-blog.csdnimg.cn/20200629225342216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h5 id="第二步：查找进程内最耗CPU的线程"><a href="#第二步：查找进程内最耗CPU的线程" class="headerlink" title="第二步：查找进程内最耗CPU的线程"></a>第二步：查找进程内最耗CPU的线程</h5></li><li>top -Hp pid ： 找出进程号为pid的进程中的所有线程</li><li>键入大写P，线程按照CPU使用率排序</li></ol><h5 id="第三步：转换线程ID"><a href="#第三步：转换线程ID" class="headerlink" title="第三步：转换线程ID"></a>第三步：转换线程ID</h5><ol><li>printf “%x/n” thread_id<br><img src="https://img-blog.csdnimg.cn/202006292259470.png" alt="在这里插入图片描述"></li></ol><h5 id="第四步：定位Java进程中cpu占用率高的线程"><a href="#第四步：定位Java进程中cpu占用率高的线程" class="headerlink" title="第四步：定位Java进程中cpu占用率高的线程"></a>第四步：定位Java进程中cpu占用率高的线程</h5><p><code>jstack pid | grep thread_id_hex  -A  需要打印的行数</code><br>下面是查看 14505进程中 “main”线程<br><img src="https://img-blog.csdnimg.cn/20200630003452292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="Java相关指令"><a href="#Java相关指令" class="headerlink" title="Java相关指令"></a>Java相关指令</h1><h2 id="8-打印出Java正在运行的进程"><a href="#8-打印出Java正在运行的进程" class="headerlink" title="8. 打印出Java正在运行的进程"></a>8. 打印出Java正在运行的进程</h2><ul><li>指令：jps</li><li>可以知道启动了哪些进程，对应的进程号<br><img src="https://img-blog.csdnimg.cn/20200630001657346.png" alt="在这里插入图片描述"><h2 id="9-图形化查看内存，线程等信息"><a href="#9-图形化查看内存，线程等信息" class="headerlink" title="9. 图形化查看内存，线程等信息"></a>9. 图形化查看内存，线程等信息</h2></li><li>指令：jconsole</li><li>连接对应的进程：<br><img src="https://img-blog.csdnimg.cn/20200630002304398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>连接后的界面：<br>可以查看内存（GC情况），线程，类，JVM情况和加载的Bean<br><img src="https://img-blog.csdnimg.cn/20200630002239287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="10-查看内存使用状况-jstat"><a href="#10-查看内存使用状况-jstat" class="headerlink" title="10. 查看内存使用状况( jstat )"></a>10. 查看内存使用状况( jstat )</h2></li><li>jstat -gc pid </li><li>用的比较少，需要用到就百度吧..<h2 id="11-分析Java线程的状况"><a href="#11-分析Java线程的状况" class="headerlink" title="11. 分析Java线程的状况"></a>11. 分析Java线程的状况</h2></li><li>指令：jstack thread_id </li><li>打印对应线程的运行情况</li></ul><h2 id="12-把当前java进程的状态给dump下来，或查看内存信息"><a href="#12-把当前java进程的状态给dump下来，或查看内存信息" class="headerlink" title="12. 把当前java进程的状态给dump下来，或查看内存信息"></a>12. 把当前java进程的状态给dump下来，或查看内存信息</h2><h3 id="1-dump下来"><a href="#1-dump下来" class="headerlink" title="1. dump下来"></a>1. dump下来</h3><ul><li>指令：jmap -dump:file=xxx pid （xxx是dump的文件名）</li><li>dump下来之后，需要用专门的工具来查看这个文件，有专门查看这类文件的可视化工具<br><img src="https://img-blog.csdnimg.cn/20200630004205794.png" alt="在这里插入图片描述"><h3 id="2-查看内存信息"><a href="#2-查看内存信息" class="headerlink" title="2. 查看内存信息"></a>2. 查看内存信息</h3></li><li>指令：jmap -heap pid<br><img src="https://img-blog.csdnimg.cn/20200630004556581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="13-强大的监控图形界面"><a href="#13-强大的监控图形界面" class="headerlink" title="13. 强大的监控图形界面"></a>13. 强大的监控图形界面</h2><p>升级版jconsole, 并且能手动GC，并且可以手动直接dump，<strong>可以查看dump出来的dump文件！</strong> 很强大。</p><ul><li>指令：jvisualvm<br><img src="https://img-blog.csdnimg.cn/20200630004822314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="一个JVM参数，当出现OOM时，自动进行dump"><a href="#一个JVM参数，当出现OOM时，自动进行dump" class="headerlink" title="一个JVM参数，当出现OOM时，自动进行dump"></a>一个JVM参数，当出现OOM时，自动进行dump</h2><ul><li>指令： -XX:+HeapDumpOnOutOfMemoryError</li></ul><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="a-在指定文件夹下查询指定文件"><a href="#a-在指定文件夹下查询指定文件" class="headerlink" title="a. 在指定文件夹下查询指定文件"></a>a. 在指定文件夹下查询指定文件</h2><p>指令：find base_dir -f file_name<br>这里的file_name是可以使用正则来匹配的，比如  *.txt</p><h2 id="b-cut指令"><a href="#b-cut指令" class="headerlink" title="b. cut指令"></a>b. cut指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cut</span><br><span class="line">-d ：分隔符，按列分割</span><br><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个列</span><br><span class="line">-c ：以字符为单位取出列。 ( ps: cut -c 7- 表示以自负为单位, 打印从第7列及其之后的字符列</span><br></pre></td></tr></table></figure><h3 id="示例-1：last-显示登入者的信息，取出用户名。"><a href="#示例-1：last-显示登入者的信息，取出用户名。" class="headerlink" title="示例 1：last 显示登入者的信息，取出用户名。"></a>示例 1：last 显示登入者的信息，取出用户名。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ last</span><br><span class="line">root pts&#x2F;1 192.168.201.101 Sat Feb 7 12:35 still logged in</span><br><span class="line">root pts&#x2F;1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span><br><span class="line">root pts&#x2F;1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span><br><span class="line"></span><br><span class="line">$ last | cut -d &#39; &#39; -f 1</span><br></pre></td></tr></table></figure><h3 id="示例-2：将-export-输出的信息，取出第-12-字符以后的所有字符串。"><a href="#示例-2：将-export-输出的信息，取出第-12-字符以后的所有字符串。" class="headerlink" title="示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。"></a>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ export</span><br><span class="line">declare -x HISTCONTROL&#x3D;&quot;ignoredups&quot;</span><br><span class="line">declare -x HISTSIZE&#x3D;&quot;1000&quot;</span><br><span class="line">declare -x HOME&#x3D;&quot;&#x2F;home&#x2F;dmtsai&quot;</span><br><span class="line">declare -x HOSTNAME&#x3D;&quot;study.centos.vbird&quot;</span><br><span class="line">.....(其他省略).....</span><br><span class="line"></span><br><span class="line">$ export | cut -c 12-</span><br></pre></td></tr></table></figure><h2 id="c-sort指令"><a href="#c-sort指令" class="headerlink" title="c. sort指令"></a>c. sort指令</h2><p>排序指令：<br>sort</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错排问题（装错信封问题）</title>
      <link href="/2020/07/10/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%85%E9%94%99%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2020/07/10/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98%EF%BC%88%E8%A3%85%E9%94%99%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><blockquote><p>某人给五个朋友写信，邀请他们来家中聚会。请柬和信封交由助手去处理。<br>粗心的助手却把请柬全装错了信封。请问：助手会有多少种装错的可能呢？</p></blockquote><a id="more"></a><p>换句话说：</p><p>对[0,n)进行全排列，对于每一个排列A，对于任意i∈[0,n) , 都满足 A[i]!=i ， 求这种排列的个数.</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><ol><li><p>面试遇到这种题，n应该不会太大，用下面这个思路和递推就能搞定<br><img src="https://img-blog.csdnimg.cn/20200605173948874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>如果是笔试的话…就直接上dp来做..</p></li><li><p>最后象征性的放个公式<br><img src="https://img-blog.csdnimg.cn/20200605174836735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select/poll/epoll学习</title>
      <link href="/2020/07/10/select-poll-epoll%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/10/select-poll-epoll%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>一次网络IO会涉及两个系统对象:</p><ol><li>等待数据准备好</li><li>将数据从内核空间的buffer拷贝到用户空间进程的buffer<br>而这五种IO模型的特点就在于以怎样的方式来处理这两个系统对象和两个阶段.</li></ol><h2 id="Unix-有五种-I-O-模型："><a href="#Unix-有五种-I-O-模型：" class="headerlink" title="Unix 有五种 I/O 模型："></a>Unix 有五种 I/O 模型：</h2><ol><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ol><a id="more"></a><h2 id="1-阻塞式IO"><a href="#1-阻塞式IO" class="headerlink" title="1. 阻塞式IO"></a>1. 阻塞式IO</h2><p>应用进程被阻塞，直到<strong>数据从内核buffer复制到应用进程buffer中</strong>才返回。</p><p>特点：</p><ul><li>在准备数据阶段：被阻塞</li><li>数据从内核buffer复制到用户态buffer阶段：被阻塞</li><li><code>recvfrom</code>执行结束之后才能之后后面的程序<br><img src="https://img-blog.csdnimg.cn/20200605141204458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="2-非阻塞式IO"><a href="#2-非阻塞式IO" class="headerlink" title="2. 非阻塞式IO"></a>2. 非阻塞式IO</h2>用户态程序执行IO调用后，无论IO是否完成，都会立刻返回结果，应用程序需要不断的执行这个系统调用去获知IO是否完成。（注意，这里会返回IO是否已经完成的状态，而不是数据是否准备好）</li></ul><p>特点：</p><ul><li>在数据准备阶段：非阻塞式（会立刻返回一个错误码）</li><li>数据从内核buffer复制到用户态buffer阶段：阻塞式</li><li><code>recvfrom</code>会立刻返回结果，一般会用一个循环来不停的去判断IO是否完成。</li><li>实时性会比较好，但CPU利用率比较低<br><img src="https://img-blog.csdnimg.cn/20200605142017590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="3-IO复用"><a href="#3-IO复用" class="headerlink" title="3. IO复用"></a>3. IO复用</h2>让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</li></ul><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p>特点：</p><ul><li>数据准备阶段：阻塞，并会返回一个“事件已经发生的信号”（这里的事件就是数据已经准备好了）</li><li>数据从内核buffer复制到用户态buffer阶段：阻塞</li></ul><p>IO复用的实现有select/poll/epoll，后面会详细说<br><img src="https://img-blog.csdnimg.cn/20200605142242540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-信号驱动-I-O"><a href="#4-信号驱动-I-O" class="headerlink" title="4. 信号驱动 I/O"></a>4. 信号驱动 I/O</h2><p>个人理解 信号驱动IO = 事件驱动机制 + 非阻塞式IO</p><p>信号驱动IO是指：进程预先告知内核，使得 当某个socketfd有events（事件）发生时，内核使用信号通知相关进程。 </p><p>因此通知完了之后，并不会被阻塞。 </p><p>当内核通知相关进程，它感兴趣的事件发生了的时候（这里就是数据已经准备好了），然后再去做recvfrom，将数据从内核态复制到用户态。</p><p>特点：</p><ul><li>数据准备阶段：非阻塞式。（因为只是向OS发送一个通知，立刻就返回了）</li><li>数据从内核buffer复制到用户态buffer阶段：阻塞式。</li><li>相比于前面的非阻塞式IO的轮询，信号驱动IO的CPU利用率更高</li></ul><p><img src="https://img-blog.csdnimg.cn/20200605142951404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5. 异步IO"></a>5. 异步IO</h2><p>理解异步IO，先要理解异步，通俗来说就是，只要我触发了一IO调用，那么这个IO在这之后的任何一个时刻完成对我的程序都不会有影响，因此我就没必要非等你IO完了才继续往下执行，而是利用“委派”的思想，让内核去帮我完成.</p><p>因此，在调用完异步IO的系统调用（例如aio_read）之后，应用进程可以继续执行，不会被阻塞，内核会在<strong>所有操作完成之后</strong>向应用进程发送信号。</p><p>注意，异步IO也是 “事件驱动 + 非阻塞” ， 但它和信号驱动IO的区别是， 异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p>特点：</p><ul><li>数据准备阶段：非阻塞</li><li>数据从内核buffer复制到用户态buffer阶段：非阻塞</li><li>相当于把IO操作给委派出去了，所以自己完全不会被阻塞<br><img src="https://img-blog.csdnimg.cn/2020060514341991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="五大-I-O-模型比较"><a href="#五大-I-O-模型比较" class="headerlink" title="五大 I/O 模型比较"></a>五大 I/O 模型比较</h1><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li><li>异步 I/O：第二阶段应用进程不会阻塞。</li></ul><p><font color=red size=5>同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，</font></p><p><font color=red size=5>它们的主要区别在第一个阶段。</font></p><p><font color=red size=5>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</font><br><img src="https://img-blog.csdnimg.cn/20200605143505407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="IO复用——select-poll-epoll"><a href="#IO复用——select-poll-epoll" class="headerlink" title="IO复用——select/poll/epoll"></a>IO复用——select/poll/epoll</h1><p>这三种对IO复用的实现方式的区别主要在于：</p><ul><li>对socketfd的存储方式</li><li>以怎样的方式去通知用户级进程去获取已经发生的事件（或者说用户级进程用怎样的方式去获取已经放发生的事件）</li></ul><h2 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">buffer</span>[MAXBUF];</span><br><span class="line">  <span class="keyword">int</span> fds[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">  <span class="keyword">int</span> addrlen, n,i,<span class="built_in">max</span>=<span class="number">0</span>;;</span><br><span class="line">  <span class="keyword">int</span> sockfd, commfd;</span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  child_process();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">  <span class="built_in">listen</span> (sockfd, <span class="number">5</span>); </span><br><span class="line">  <span class="comment">// ==================从这里开始=====================</span></span><br><span class="line">  <span class="comment">// 初始化rset(32个长整型 = 一个1024的bitmap)</span></span><br><span class="line">  <span class="comment">// 主要目的是获取最大的文件描述符</span></span><br><span class="line">  <span class="comment">// 将打开的文件描述符fds_i对应的位置为1（linux默认最多打开1024个文件，因此这个文件描述符小于1024）</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">    <span class="built_in">max</span> = fds[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开始监听事件</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  FD_SET(fds[i],&amp;rset);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">   <span class="comment">// 在这里会阻塞，当有事件发生时，会修改rset的值，</span></span><br><span class="line">   <span class="comment">// 即发生事件的对应bit会被置位1，其他都被置为0</span></span><br><span class="line">   <span class="comment">// 因此，每循环一轮都要对rset重新初始化一次</span></span><br><span class="line">select(<span class="built_in">max</span>+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 遍历所有监听的文件描述符，若被置位了，那么就去进行IO</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line"><span class="built_in">read</span>(fds[i], <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>每个操作系统都实现了select模式，可移植性较强</li><li>在一些监听事件个数比较少的情况下，也比较优秀</li></ol><p>缺点：</p><ol><li>因为对文件描述符的存储是一个1024的bitmap, 所以一个进程最多监听的事件个数被限制。 </li><li>因为select每次都会对传入的readset进行一个修改，所以在每次轮询的时候，都要重新进行一次初始化，这也是比较低效的</li><li>事件监听的种类是通过传入fd_set类型的参数来进行的，因此不太好扩展.</li><li>每次都需要遍历所有的文件描述符才能知道事件发生的是哪一个socket，如果监听的事件比较多，且只有一个事件发生，那么也需要遍历全部，这样显然是很低效的。</li><li>在进行IO的时候，需要将<font color=red><strong>存储文件描述符状态信息的bitmap</strong></font>从内核态复制到用户态，这一复制过程开销也比较大.</li></ol><h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2. poll"></a>2. poll</h2><p>poll的实现大体上和select类似，只是改变了对事件的存储形式，不再使用fd_set, 而是使用一个结构体来保存.  这个结构体中保存的数据主要有：</p><ul><li>对应的文件描述符</li><li>被监听的事件类型</li><li>事件是否发生的一个标志位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd; <span class="comment">// 对应的文件描述符</span></span><br><span class="line">      short events; <span class="comment">// 被监听的事件类型</span></span><br><span class="line">      short revents; <span class="comment">// 事件是否发生的一个标志位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 这儿不再需要每次都初始化了</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">pollfds[i].revents = <span class="number">0</span>; <span class="comment">// 事件得到处理，标志为复原</span></span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line"><span class="built_in">read</span>(pollfds[i].fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>解决了select的监听事件个数存在上限问题，和每处理一轮请求需要重新初始化的问题。</li></ul><p>缺点：</p><ul><li>并不是所有系统都实现了poll模型，因此跨平台性较差</li><li>依然存在遍历所有事件 和 内核态数据复制到用户态的问题（用户态到内核态复制的数据，之前在select里面是一个bitmap，而在poll里面，是一个结构体数组）</li></ul><h2 id="3-epoll"><a href="#3-epoll" class="headerlink" title="3. epoll"></a>3. epoll</h2><h3 id="3-1-epoll-create"><a href="#3-1-epoll-create" class="headerlink" title="3.1 epoll_create"></a>3.1 epoll_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_create() 该 函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。</p><h3 id="3-1-epoll-ctl"><a href="#3-1-epoll-ctl" class="headerlink" title="3.1 epoll_ctl"></a>3.1 epoll_ctl</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br></pre></td></tr></table></figure><p>epoll_ctl() ⽤于向内核注册新的描述符或者是改变某个文件描述符的状态。</p><h3 id="3-1-epoll-wait"><a href="#3-1-epoll-wait" class="headerlink" title="3.1 epoll_wait"></a>3.1 epoll_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>已注册的描述符在内核中会被维护在 ⼀棵红⿊树上，通过回调函数内核会将 I/O 准备好的描述符加入到⼀个链表中管理（这个链表就是传入的第二个指针参数events），进程调⽤ epoll_wait() 便可 以得到事件完成的描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"> <span class="comment">// epfd是一个文件描述符，指向一个内核中的文件区域</span></span><br><span class="line"> <span class="comment">// 这块区域是用户态和内核态共享的</span></span><br><span class="line"> <span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   ev.events = EPOLLIN;</span><br><span class="line">   <span class="comment">// 向epfd指向的那块区域中添加( EPOLL_CTL_ADD )一条 监听记录信息:</span></span><br><span class="line">   <span class="comment">// &lt; 需要被监听的文件描述符 (ev.data.fd), 正在监听的事件(ev) &gt;</span></span><br><span class="line">   <span class="comment">// 直接把需要监听的sockfd的信息写到了上面申请的那块内存区域中...</span></span><br><span class="line">   <span class="comment">// 因为上面的那块内存区域是内核态和用户态共享的，所以省去了 用户态到内核态的复制开销！！！！</span></span><br><span class="line">   <span class="comment">// ps: 这里多说两句，这里的epoll_ctl实际上是“注册新的描述符或者是改变某个文件描述符的状态”</span></span><br><span class="line">   <span class="comment">// 已经注册过的描述符以红黑树的形式被存储维护起来， 当有数据准备好时，会通过硬中断进行一个回调，</span></span><br><span class="line">   <span class="comment">// 把准备好了数据对应的那个socketfd给加入到一个链表中， </span></span><br><span class="line">   <span class="comment">// 然后后面进行epoll_wait的时候，实际上就是获取这个链表，因为这个链表存储的就是已经准备好的数据的socketfd</span></span><br><span class="line">   epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"> <span class="comment">// 等待正在监听的事件发生</span></span><br><span class="line"> <span class="comment">// 若返回-1，则说明在监听时出现了中断或错误</span></span><br><span class="line"> <span class="comment">// 若返回0，则说明超时，没有事件发生</span></span><br><span class="line"> <span class="comment">// 若大于0，则表示正在监听的所有事件中，发生了的事件个数，并且会把发生了的事件放到</span></span><br><span class="line"> <span class="comment">// 传入的这个events数组中</span></span><br><span class="line"> <span class="comment">// ps: 这里的监听-复制，是使用硬中断来做的</span></span><br><span class="line"> nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取events数组里的数据，然后进行处理</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line"><span class="built_in">read</span>(events[i].data.fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line"><span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>不需要每次遍历所有监听的events，而只用去遍历已经发生的events</li><li>因为申请的内存是内核态用户态共享的一块内存，所以在注册需要监听的socketfd信息的时候，省去了一次用户态-&gt;内核态的开销</li></ul><p>缺点：</p><ul><li><p>只有linux上实现了epoll</p></li><li><h2 id="epoll小结"><a href="#epoll小结" class="headerlink" title="epoll小结"></a><font color=red>epoll小结</font></h2></li></ul><ol><li>使用epoll_create申请一块用户态和用户态共享的一块内存</li><li>使用epoll_ctl来注册一个socket文件描述符，或是更改一个socket文件描述的状态，注册的文件描述符信息保存在epoll_create申请的那块内存中，并且文件描述符是被维护在一个红黑树上。因为这块内存是用户态和内核态共享的，所以才能够省去一次用户态复制到内核态的开销。</li><li>socket文件描述符被注册到了共享内存中了之后，当事件来临时，例如数据已经准备完毕了，会触发一个中断，会将这个已经发生了的事件（数据已经准备好了）对应的socketfd给加入到一个链表中尽心管理</li><li>在调用epoll_wait的时候，实际上就是从这个链表中，获取事件完成的描述符。 因此，epoll_wait将返回事件完成的个数(假设为k， k&gt;0)，并且传入的events数组的前k个就是事件已经发生了的对应的描述符，因此能够减少O(N)的遍历，从而变成O(K)的遍历.</li></ol><hr><h2 id="select-poll-epoll的应用场景"><a href="#select-poll-epoll的应用场景" class="headerlink" title="select/poll/epoll的应用场景"></a>select/poll/epoll的应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h3 id="1-select-应用场景"><a href="#1-select-应用场景" class="headerlink" title="1. select 应用场景"></a>1. select 应用场景</h3><ol><li><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p></li><li><p>select 可移植性更好，几乎被所有主流平台所支持。</p></li></ol><h3 id="2-poll-应用场景"><a href="#2-poll-应用场景" class="headerlink" title="2. poll 应用场景"></a>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><h3 id="3-epoll-应用场景"><a href="#3-epoll-应用场景" class="headerlink" title="3. epoll 应用场景"></a>3. epoll 应用场景</h3><ol><li><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p></li><li><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p></li><li><p><strong>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。</strong> 因为 epoll 中的所有描述符都存储在内核中，造成<font color=red><strong>每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用</strong></font>，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p></li></ol><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1qJ411w7du?from=search&seid=6751505418841311165" target="_blank" rel="noopener">IO多路复用select/poll/epoll介绍</a><br><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket?id=epoll" target="_blank" rel="noopener">CS-Note</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2" target="_blank" rel="noopener">讲解nio,epoll,多路复用</a></p>]]></content>
      
      
      <categories>
          
          <category> io模型 </category>
          
          <category> io多路复用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP滑动窗口/拥塞控制/流量控制</title>
      <link href="/2020/07/10/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/07/10/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><h2 id="1-有连接和无连接"><a href="#1-有连接和无连接" class="headerlink" title="1. 有连接和无连接"></a>1. 有连接和无连接</h2><p><img src="https://img-blog.csdnimg.cn/20200528213311923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="二、UDP一对一-一对多和一对全-，TCP一对一"><a href="#二、UDP一对一-一对多和一对全-，TCP一对一" class="headerlink" title="二、UDP一对一, 一对多和一对全 ，TCP一对一"></a>二、UDP一对一, 一对多和一对全 ，TCP一对一</h2><p><img src="https://img-blog.csdnimg.cn/20200528215917191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、UDP面向报文，TCP面向字节流"><a href="#三、UDP面向报文，TCP面向字节流" class="headerlink" title="三、UDP面向报文，TCP面向字节流"></a>三、UDP面向报文，TCP面向字节流</h2><p><img src="https://img-blog.csdnimg.cn/202005282208496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、可靠性"><a href="#四、可靠性" class="headerlink" title="四、可靠性"></a>四、可靠性</h2><p><img src="https://img-blog.csdnimg.cn/20200528221123262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="五、报文头信息"><a href="#五、报文头信息" class="headerlink" title="五、报文头信息"></a>五、报文头信息</h2><p><img src="https://img-blog.csdnimg.cn/20200528221355933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://img-blog.csdnimg.cn/20200528221549152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82?id=tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3" target="_blank" rel="noopener">滑动窗口</a></h1><h2 id="1-发送方："><a href="#1-发送方：" class="headerlink" title="1. 发送方："></a>1. 发送方：</h2><p>一个报文的状态：</p><ul><li><p>已经发送，并且收到确认报文（已结束）<font color=blue>（窗口外）</font></p></li><li><p>已经发送，但还未收到确认报文（等待ACK） <font color=red>（窗口内）</font></p></li><li><p>可以发送，但尚未发送（已就绪，等待发送）<font color=red>（窗口内）</font></p></li><li><p>不可以发送（受窗口限制，不允许发送）<font color=blue> （窗口外）</font><br><img src="https://img-blog.csdnimg.cn/20200528195853562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果出现丢包，那么就会重复对丢包报文前的那个报文进行确认，例如在上图中，如果发送了31，32，33，34，45，其中32丢包，31，33，34，35按序号到达，那么当33到的时候，34到的时候，35到的时候，都是发的对31的确认报文，相当于多发了3次对31的确认报文（当对同一个报文重复确认3次的时候，则会触发快重传）。</p><p>  因此，在上图中，31～41一定都是未收到确认的，当31确认收到了以后，那么窗口就会向右滑动，直到最左方的首个元素是“发送了但尚未收到确认报文的” 或者“尚未发送的”。 继续上面这个例子，当31，33，34，35到达，接收方发送了3个对31号报文的ACK，就会触发“快重传”，重新传送32。</p></li></ul><h2 id="2-接收方"><a href="#2-接收方" class="headerlink" title="2. 接收方"></a>2. 接收方</h2><p>接收方窗口左边为已经发送过的确认报文，右边为当前不能接收的报文。</p><h3 id="接收方窗口："><a href="#接收方窗口：" class="headerlink" title="接收方窗口："></a>接收方窗口：</h3><ul><li>最左边报文一定是尚未收到的报文</li><li>如果31没到，32，33先到，就先把32，33缓存在接收缓冲区中，并且会发送2个对30的确认报文，当收到了31的确认报文，那么窗口就继续滑动到34的位置.</li></ul><p><img src="https://img-blog.csdnimg.cn/20200528202534525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82?id=tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">拥塞控制</a></h1><p>在理想情况下，随着请求数的增长，网络的吞吐量也会增长，当用户的请求出超出了网络所能承载的负荷时，吞吐量将保持不变。。</p><p>而实际情况是，当用户对网络资源的请求数量超过了网路所能抗住的负荷时，吞吐量会随着请求的增多而减少，直到变为0。<img src="https://img-blog.csdnimg.cn/20200528171821368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 而拥塞控制就是为了防止这一情况的产生，其实现的方式就是，通过调整发送窗口的大小，来控制发送速率，从而起到减少网络流量的作用。  </p><p><strong>发送方</strong>需要维护3个变量( 发送窗口(cwnd), 拥塞窗口(swnd), 窗口阈值(ssthresh))：<br><font color=red><strong>实际上，发送方发送窗口大小 = min（拥塞窗口大小（拥塞控制）, 接收方接收窗口大小（流量控制））</strong></font><br><img src="https://img-blog.csdnimg.cn/20200528184230937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>拥塞控制包括了4个算法策略分别是：慢开始，拥塞避免，快重传，快恢复。</p><h2 id="慢开始："><a href="#慢开始：" class="headerlink" title="慢开始："></a>慢开始：</h2><p>cwnd = 1, 每发送一轮窗口大小的数据并成功接收到确认报文，就给窗口大小乘2，<br>当窗口大小超过ssthresh时，使用拥塞避免算法。</p><h2 id="拥塞避免："><a href="#拥塞避免：" class="headerlink" title="拥塞避免："></a>拥塞避免：</h2><p>每发送一轮窗口大小的数据并成功接收到确认报文，就给窗口大小<font color=red><strong>加1</strong></font>，一旦出现超时重传，则判定网络可能出现了拥堵，<strong>将cwnd置为1</strong>，<strong>ssthresh变为原来的一半</strong></p><p><img src="https://img-blog.csdnimg.cn/20200528192205692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="快重传："><a href="#快重传：" class="headerlink" title="快重传："></a>快重传：</h2><p>快重传就是：并不是等超时了才再重传，而是<strong>连续收到3个重复的ACK报文时</strong>，就开始重传！</p><p><img src="https://img-blog.csdnimg.cn/20200528192030381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h2><p>快恢复就是：出现了需要重传的情况，并不是把cwnd置为1，而是置成原来大小的一半,（ssthresh也置为原来的一半）。<br><img src="https://img-blog.csdnimg.cn/20200528192239154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200528170429906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><a href="https://www.bilibili.com/video/BV1kJ41177Qd?from=search&seid=15849888663651403541" target="_blank" rel="noopener">流量控制</a></h1><p>流量控制就是，让接收方的发送速率能够匹配上接收方的接收速率，具体实现体现在：控制发送方的发送窗口大小（如果发送的太快了，就把窗口调小点，如果发的太慢了，就把窗口调大点），发送方窗口的大小根据接收方窗口的大小来决定。</p><p><font color=red><strong>实际上，发送方发送窗口大小 = min（拥塞窗口大小（拥塞控制）, 接收方接收窗口大小（流量控制））</strong></font></p><p>该<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60" target="_blank" rel="noopener">视频</a>的例子讲的非常棒。</p><ul><li><p>发送方在接收到接收方的确认报文段后，会根据报文中的接收方窗口大小值，来重新调整当前的发送窗口大小。（初始大小在TCP三次握手的时候确定）</p></li><li><p>发送方窗口可以被设成零。 当发送方窗口大小为0时，会定时发送零窗口探测报文，询问接收方的窗口大小，如果还是0，那么就重置这个定时器，如果不是0就重新调整窗口大小。</p></li><li><p>TCP规定，接收方接收窗口即使为0，也应接收零窗口探测报文，确认报文段，以及携带紧急数据的报文段。</p></li></ul><hr><h1 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h1><p><img src="https://img-blog.csdnimg.cn/20200528145334495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><h2 id="源端口："><a href="#源端口：" class="headerlink" title="源端口："></a>源端口：</h2><ul><li>源端口和IP地址的作用是<strong>标识报文的返回地址</strong>。</li></ul></li><li><h2 id="目的端口："><a href="#目的端口：" class="headerlink" title="目的端口："></a>目的端口：</h2><ul><li>端口指明接收方计算机上的应用程序接口。</li></ul></li></ul><p><font color=red>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接</font></p><ul><li><h3 id="序号-Seq-和确认号-ACK-："><a href="#序号-Seq-和确认号-ACK-：" class="headerlink" title="序号 (Seq) 和确认号 (ACK) ："></a>序号 (Seq) 和确认号 (ACK) ：</h3><ul><li>序号是<strong>本报文段</strong>发送的数据组的第一个字节的序号。<strong>在TCP传送的流中，每一个字节一个序号</strong>。例如：一个报文段的序号为300（Seq=300），此报文段数据部分共有100字节，则下一个报文段的序号为400。所以<strong>序号确保了TCP传输的有序性</strong>。</li><li>确认号，即ACK，指<strong>下一个期待收到的字节序号</strong>， <strong>表明该序号之前的所有数据已经正确无误的收到</strong>。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li></ul></li><li><h3 id="数据偏移／首部长度：4bits。"><a href="#数据偏移／首部长度：4bits。" class="headerlink" title="数据偏移／首部长度：4bits。"></a>数据偏移／首部长度：4bits。</h3><ul><li>由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li></ul></li><li><h3 id="保留："><a href="#保留：" class="headerlink" title="保留："></a>保留：</h3><ul><li>为将来定义新的用途保留，现在一般置0</li></ul></li><li><h3 id="控制位：URG-ACK-PSH-RST-SYN-FIN，共6个，每一个标志位表示一个控制功能。"><a href="#控制位：URG-ACK-PSH-RST-SYN-FIN，共6个，每一个标志位表示一个控制功能。" class="headerlink" title="控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。"></a>控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</h3><ul><li><p>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</p></li><li><p><font color=red><strong>ACK</strong></font>：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</p></li><li><p>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</p></li><li><p>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</p></li><li><p><font color=red> <strong>SYN</strong></font>：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</p></li><li><p><font color=red><strong>FIN</strong></font>：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http/https学习</title>
      <link href="/2020/07/10/http-https%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/10/http-https%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP1-0和HTTP1-1的主要区别"><a href="#HTTP1-0和HTTP1-1的主要区别" class="headerlink" title="HTTP1.0和HTTP1.1的主要区别"></a>HTTP1.0和HTTP1.1的主要区别</h1><h2 id="区别一：短连接和长连接"><a href="#区别一：短连接和长连接" class="headerlink" title="区别一：短连接和长连接"></a>区别一：短连接和长连接</h2><h3 id="一、HTTP1-0使用短连接"><a href="#一、HTTP1-0使用短连接" class="headerlink" title="一、HTTP1.0使用短连接"></a>一、HTTP1.0使用短连接</h3><p>http1.0使用的是短连接，就是每进行一次http请求都要重新建立一次tcp连接。</p><h4 id="短连接影响性能的最主要的两个原因"><a href="#短连接影响性能的最主要的两个原因" class="headerlink" title="短连接影响性能的最主要的两个原因"></a>短连接影响性能的最主要的两个原因</h4><h5 id="a-每次都需要握手-挥手-慢启动"><a href="#a-每次都需要握手-挥手-慢启动" class="headerlink" title="a. 每次都需要握手/挥手/慢启动"></a>a. 每次都需要握手/挥手/慢启动</h5><p>tcp连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大</p><h5 id="b-tcp连接数过多而被阻塞"><a href="#b-tcp连接数过多而被阻塞" class="headerlink" title="b. tcp连接数过多而被阻塞"></a>b. tcp连接数过多而被阻塞</h5><p>一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个，因此，在短连接的场景下，频繁的建立TCP连接可能会因为无法创建新的连接而被阻塞住。</p><a id="more"></a><h4 id="二、HTTP1-1支持长连接-并且默认是长连接"><a href="#二、HTTP1-1支持长连接-并且默认是长连接" class="headerlink" title="二、HTTP1.1支持长连接( 并且默认是长连接 )"></a>二、HTTP1.1支持长连接( 并且默认是长连接 )</h4><p>而http1.1支持长连接，并且默认是长连接, 即在tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。但是在这里需要注意的是，这里的tcp复用必须是对同一个tcp连接的复用（废话），即是对同一个socket的复用（例如请求同一个网页上的文字，图片等资源，是可以复用的，但如果是不同的连接上的资源（例如其他网站），那么肯定就无法复用了）。  Connection请求头的值为Keep-Alive 表示为长连接</p><p>PS: 在http2.0中，使用长连接+IO多路复用模型进一步优化【针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞】这一问题。</p><h2 id="区别二：HTTP1-0更节约带宽"><a href="#区别二：HTTP1-0更节约带宽" class="headerlink" title="区别二：HTTP1.0更节约带宽"></a>区别二：HTTP1.0更节约带宽</h2><p>HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。 </p><p>而HTTP1.1种在请求消息中增加了range头域，它允许只请求资源的某个部分。</p><h3 id="对于请求报文"><a href="#对于请求报文" class="headerlink" title="对于请求报文"></a>对于请求报文</h3><p>在请求报文中添加 <font color=red><strong>Range</strong></font> 首部字段指定请求的范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;z4d4kWk.jpg HTTP&#x2F;1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes&#x3D;0-1023</span><br></pre></td></tr></table></figure><h3 id="对于响应报文"><a href="#对于响应报文" class="headerlink" title="对于响应报文"></a>对于响应报文</h3><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 </p><p>在响应报文中，由<font color=red><strong>Content-Range和Content-Length</strong> </font>字段 来告知传输情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023&#x2F;146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure><h2 id="区别三：HTTP1-1多了Host域"><a href="#区别三：HTTP1-1多了Host域" class="headerlink" title="区别三：HTTP1.1多了Host域"></a>区别三：HTTP1.1多了Host域</h2><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，<strong>因此，请求消息中的URL并没有传递主机名（hostname）</strong>。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</p><p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。</p><p>（PS：补充一下这个host的意思，若多个域名对应同一个ip，那么当根据不同的域名访问到同一个ip的时候，服务端不知道该响应哪一种服务，而如果有host，服务端就知道这个请求是从哪个域名访问来的，就可以提供对应的服务啦）</p><h2 id="区别四：HTTP1-1支持分块传输"><a href="#区别四：HTTP1-1支持分块传输" class="headerlink" title="区别四：HTTP1.1支持分块传输"></a>区别四：HTTP1.1支持分块传输</h2><p>发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载，同时也能让浏览器逐步显示页面，提高页面的响应速度。</p><h2 id="区别五：HTTP1-1引入了新的状态码100"><a href="#区别五：HTTP1-1引入了新的状态码100" class="headerlink" title="区别五：HTTP1.1引入了新的状态码100"></a>区别五：HTTP1.1引入了新的状态码100</h2><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><p>该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。在服务器发送了 100 Continue 状态码之后，如果收到客户端的请求，则必须进行响应。</p><p>这个状态码实际上是对如下场景的一种优化：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。实际操作为客户端发送一条特殊的请求报文，报文的头部应包含</p><p><code>Expect: 100-continue</code></p><p>此时，如果服务器愿意接受，就会返回 100 Continue 状态码，反之则返回 417 Expectation Failed 状态码。对于客户端而言，如果客户端没有发送实际请求的打算，则不应该发送包含 100 Continue Expect 的报文，因为这样会让服务器误以为客户端将要发送一个请求。</p><h2 id="区别六：HTTP1-1支持流水线"><a href="#区别六：HTTP1-1支持流水线" class="headerlink" title="区别六：HTTP1.1支持流水线"></a>区别六：HTTP1.1支持流水线</h2><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在<strong>同一条长连接</strong>上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2 id="区别七：引入max-age指令"><a href="#区别七：引入max-age指令" class="headerlink" title="区别七：引入max-age指令"></a>区别七：引入max-age指令</h2><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br></pre></td></tr></table></figure><p>http1.0里 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h1 id="Get-和-Post-的区别"><a href="#Get-和-Post-的区别" class="headerlink" title="Get 和 Post 的区别"></a><a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%E4%B9%9D%E3%80%81get-%E5%92%8C-post-%E6%AF%94%E8%BE%83" target="_blank" rel="noopener">Get 和 Post 的区别</a></h1><ul><li><p>GET是安全的，而POST是不安全的。</p><p>  安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p></li><li><p>GET请求会被浏览器主动cache，而POST默认不会缓存（除非手动设置）。</p></li><li><p>GET请求在URL中传送的参数是有长度限制的（实际上是没限制的，但是因为参数是放到url里，浏览器对url的最大长度是有限制的，所以GET请求传输参数就有限制的了..），而POST没有（实际是有的，尽管http协议没限制，但是在服务器配置中会有限制，例如：在 Tomcat 环境中，server.xml 文件有个 maxPostSize 字段来限制 POST 上传大小，默认貌似是 2M。） 因此，<font color=red>GET 和 POST 是没有长度限制的，真正限制的是浏览器和服务器。</font> 但就算这样，POST能够上传的数据大小依然比GET要多.. </p><p>  <a href="https://www.jianshu.com/p/ddab44726e11" target="_blank" rel="noopener">参考链接</a></p></li><li><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p></li><li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p></li><li><p>GET参数通过URL传递，POST放在Request body中</p></li></ul><hr><h1 id="一个url请求的流程"><a href="#一个url请求的流程" class="headerlink" title="一个url请求的流程"></a>一个url请求的流程</h1><h2 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h2><p>域名解析就是根据url来获取对应的ip的过程。</p><ol><li>浏览器 会首先会去搜索浏览器自身的DNS缓存 ， 如果找到了url对应的ip就直接返回</li><li>如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</li><li>如果在OS的DNS缓存里也没找到，那么尝试读取hosts文件（在linux和mac下，hosts在/etc/hosts里）</li><li>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是运营商提供的）发起域名解析请求。</li><li>DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。</li><li>如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（假如url=<a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a></li><li>根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求</li><li>com域这台服务器告诉运营商的DNS我不知道<a href="http://www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址发起请求" target="_blank" rel="noopener">www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址发起请求</a></li><li>然后在baidu.com这个域名的DNS服务器中找到了我们想要的<a href="http://www.baidu.com的ip，然后将ip层层返回，并刷新到缓存中。" target="_blank" rel="noopener">www.baidu.com的ip，然后将ip层层返回，并刷新到缓存中。</a><h2 id="2-发起TCP的3次握手"><a href="#2-发起TCP的3次握手" class="headerlink" title="2. 发起TCP的3次握手"></a>2. 发起TCP的3次握手</h2>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024 &lt; 端口 &lt; 65535）根据获取的ip ，向服务器的WEB程序80端口发起TCP的连接请求。<br>（然后开始三次握手）<h2 id="3-建立TCP连接后发起http请求"><a href="#3-建立TCP连接后发起http请求" class="headerlink" title="3. 建立TCP连接后发起http请求"></a>3. 建立TCP连接后发起http请求</h2>进过TCP3次握手之后，浏览器发起了http的请求<h2 id="4-服务器响应http请求，浏览器得到html代码"><a href="#4-服务器响应http请求，浏览器得到html代码" class="headerlink" title="4. 服务器响应http请求，浏览器得到html代码"></a>4. 服务器响应http请求，浏览器得到html代码</h2><h2 id="5-浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）"><a href="#5-浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）" class="headerlink" title="5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）"></a>5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</h2><h2 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6. 浏览器对页面进行渲染呈现给用户"></a>6. 浏览器对页面进行渲染呈现给用户</h2><h2 id="7-当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。"><a href="#7-当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。" class="headerlink" title="7.当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。"></a>7.当浏览器页面被关闭时，终止HTTP会话并关闭连接，TCP连接断开的时候会发生四次挥手。</h2></li></ol><hr><h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><ol><li>HTTP监听80端口，HTTPS监听443端口</li><li>HTTP的报文没有进行加密，而HTTPS使用了SSL或TSL进行了加密，其实质是通过非对称加密+CA认证来得到对称加密的密钥，然后开始使用对称加密进行传输，下面是HTTPS的一个主要流程。</li></ol><h1 id="HTTPS流程"><a href="#HTTPS流程" class="headerlink" title="HTTPS流程"></a>HTTPS流程</h1><h2 id="1-根据非对称加密-CA-确定对称加密的密钥K"><a href="#1-根据非对称加密-CA-确定对称加密的密钥K" class="headerlink" title="1. 根据非对称加密 + CA 确定对称加密的密钥K"></a>1. 根据非对称加密 + CA 确定对称加密的密钥K</h2><ol><li><p>客户端 =&gt; 服务端:</p><ul><li>在请求报文中携带的信息主要有：<ul><li>支持的SSL版本</li><li>支持的非对称加密算法</li><li><font color=red>随机数1</font></li></ul></li></ul></li><li><p>服务端向CA请求证书：（这一步需要付费）</p><ol><li>服务端向CA发送: &lt; 服务端的相关信息、公钥（PK） &gt;</li><li>CA将获取到的 &lt; 服务端的相关信息、公钥 &gt; 打包在一起放到数字证书里。</li><li>使用 <strong>CA 端的密钥（CSK）</strong> 对 &lt; 服务端的相关信息、公钥 &gt; 进行加密，生成<strong>数字签名</strong> , 然后也放到数字证书里面。</li><li>CA将数字证书发送给A。 数字证书中主要包含了 ( 服务端的公钥（PK）和经CSK加密过的PK )</li></ol></li><li><p>服务端 =&gt; 客户端:</p><ul><li>服务端发送给客户端响应报文，其中包含了：<ul><li>对SSL版本号的确认</li><li>对称加密算法</li><li><font color =red>随机数2</font></li><li><font color=blue>数字证书</font></li></ul></li></ul></li><li><p>客户端会对接收到的数字证书做一个认证：</p><ul><li>将数字证书中的<strong>数字签名取出</strong>，并使用CA的公钥（CPK）进行解密，将解密后的信息和数字证书中预存的信息做一个对比，若相同，则说明这个请求确实是从服务端发来的，可以信任里面的信息的。若不同则会认为被黑客篡改了，会抛出告警信息，即证书不安全的提示。 若验证通过，则从证书种能够获得服务端的公钥，用它来进行一个加密。</li></ul></li><li><p>客户端 =&gt; 服务端 （假设证书合法，继续往下走）</p><ul><li>在请求报文中主要包括的信息：<ul><li>将前两次通信的报文数据做一个哈希加密，得到一个加密结果（假设为X）</li><li><font color=red>随机数3</font></li></ul></li></ul></li><li><p>服务端进行验证</p><ul><li>服务端也根据前两次通信的报文数据以相同的加密算法来进行一个加密，并和客户端传输来的X进行一个比较，若相同则合法，否则就非法。</li><li>如果合法的话，就根据前面传输的 &lt;随机数1，随机数2，随机数3 &gt; 来用一个特殊的加密算法生成一个数字，这个数字将作为对称加密的密钥，假设它为K</li></ul></li><li><p>服务端 =&gt; 客户端 </p><ul><li>服务端向客户端发送的数据主要是：<ul><li>K</li><li>将前三次的通信报文数据来做一个哈希加密，得到的加密结果（假设为Z）</li></ul></li></ul></li><li><p>客户端进行验证：</p><ul><li>根据前三次的通信报文用相同的算法进行加密，得到结果，并和服务端传来的Z进行比较，若相同则合法。</li><li>若合法的话，也根据&lt;随机数1， 随机数2， 随机数3 &gt;来用和服务端相同的加密算法来生成对称加密的密钥K</li></ul></li></ol><h2 id="2-以K作为密钥，开始使用对称加密进行传输"><a href="#2-以K作为密钥，开始使用对称加密进行传输" class="headerlink" title="2. 以K作为密钥，开始使用对称加密进行传输"></a>2. 以K作为密钥，开始使用对称加密进行传输</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis主从同步学习</title>
      <link href="/2020/07/10/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/10/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="单机Redis的瓶颈"><a href="#单机Redis的瓶颈" class="headerlink" title="单机Redis的瓶颈"></a>单机Redis的瓶颈</h1><ul><li>容量瓶颈( 单台Redis提供的容量有限 )</li><li>QPS瓶颈( 单台Redis能提供的有限 )</li><li>机械故障( 单台redis无法保证高可用 )</li></ul><h1 id="主从复制的约定"><a href="#主从复制的约定" class="headerlink" title="主从复制的约定"></a>主从复制的约定</h1><ul><li>一个master可以有多个slave</li><li>一个slave只能用一个master</li><li>数据流向是<strong>单向</strong>的，master到slave （所以要求一般slave是read-only的，不然就无法保证主从一致性了）</li></ul><a id="more"></a><h1 id="主从配置的两种方式"><a href="#主从配置的两种方式" class="headerlink" title="主从配置的两种方式"></a>主从配置的两种方式</h1><h2 id="slaveof命令（运行中执行）"><a href="#slaveof命令（运行中执行）" class="headerlink" title="slaveof命令（运行中执行）"></a>slaveof命令（运行中执行）</h2><p>例如，机器A的ip为ipA, 机器B的ip为ipB，机器A上的redis作为slave，机器B的redis作为master，如果希望机器A对机器B的redis进行一个主从配置/复制同步的话，那么就在机器A上执行： <code>slaveof ipB:port</code> （机器A的redis执行完该命令之后，会对机器A的redis进行一个清楚，然后进行数据同步）</p><p>如果不再让机器A作为机器B的slave的话，可以执行 <code>slaveof no one</code>来断开主从关系(即使断开了主从关系，过去同步的数据依然不会清楚)</p><h2 id="配置（启动执行）"><a href="#配置（启动执行）" class="headerlink" title="配置（启动执行）"></a>配置（启动执行）</h2><p>可以在配置文件中加入如下命令:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port <span class="comment">// 表示作为哪一个节点的从节点</span></span><br><span class="line">slave-<span class="built_in">read</span>-only yes <span class="comment">// 表示当前从节点是read-only的</span></span><br><span class="line">masterauth [password]  <span class="comment">// 如果master有密码的话，那么需要设置master的密码</span></span><br></pre></td></tr></table></figure><p>(ps：在master的配置文件中，requirepass [password] 来设置密码)<br>(pps: 在redis中，auth password 用于验证身份， info replication查看主从状态)</p><table><thead><tr><th>方式</th><th>命令</th><th>配置</th></tr></thead><tbody><tr><td>优点</td><td>无需重启</td><td>统一配置,方便管理</td></tr><tr><td>缺点</td><td>不方便管理</td><td>需要重启</td></tr></tbody></table><hr><h1 id="Redis主从模式下的几个问题"><a href="#Redis主从模式下的几个问题" class="headerlink" title="*Redis主从模式下的几个问题"></a>*Redis主从模式下的几个问题</h1><h2 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h2><ul><li><p>读写分离：读流量分摊到从节点<br><img src="https://img-blog.csdnimg.cn/20200615153811154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="读写分离的问题："><a href="#读写分离的问题：" class="headerlink" title="读写分离的问题："></a>读写分离的问题：</h3></li><li><p><strong>复制数据延迟</strong>（解决延迟代价很高）</p></li><li><p><strong>读到过期的数据</strong></p><p>  redis在清理过期数据时，有一个方式是懒惰删除，即在获取这个key的时候检查是否过期，若过期则删除，而又由于从节点无法主动删除数据（read-only）, 所以如果master没有及时把过期数据告诉slave的话可能会造成脏读，redis3.2之后解决了这个问题。</p></li><li><p><strong>从节点故障</strong></p><p>  将从节点上的客户端进行迁移，成本较高。</p><h2 id="2-主从配置不一致"><a href="#2-主从配置不一致" class="headerlink" title="2. 主从配置不一致"></a>2. 主从配置不一致</h2></li><li><p><strong>例如maxmemory不一致，导致主从不一致</strong></p><h2 id="3-规避全量复制"><a href="#3-规避全量复制" class="headerlink" title="3. 规避全量复制"></a>3. 规避全量复制</h2></li></ul><ol><li><p><strong>第一次全量复制</strong></p><p> 第一次全量复制不可能避免（减少分片maxmemory,  在低峰的时候进行）</p></li><li><p><strong>节点运行ID不匹配</strong></p><p> redis每次启动时，会有一个run_id，slave会保存master的run_id, 如果master的run_id发生了变化的话，那么就会触发一个全量复制。</p></li><li><p><strong>复制积压缓冲区不足</strong></p><h2 id="4-规避复制风暴"><a href="#4-规避复制风暴" class="headerlink" title="4. 规避复制风暴"></a>4. 规避复制风暴</h2></li></ol><hr><h1 id="主从复制流程"><a href="#主从复制流程" class="headerlink" title="主从复制流程"></a>主从复制流程</h1><h2 id="run-id-："><a href="#run-id-：" class="headerlink" title="run_id ："></a><strong>run_id</strong> ：</h2><p>Redis每次启动时，都有一个随机ID来标识Redis,这个随机ID就是上面通过info命令查看得到的run_id， 查看master节点上的run_id和偏移量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# redis-cli info server | grep run_id</span><br><span class="line">run_id:7e366f6029d3525177392e98604ceb5195980518</span><br><span class="line">[root@localhost ~]# redis-cli info | grep master_repl_offset</span><br><span class="line">master_repl_offset:0</span><br></pre></td></tr></table></figure><h2 id="offset"><a href="#offset" class="headerlink" title="offset:"></a>offset:</h2><p>偏移量(offset)就是数据写入量的字节数。</p><p>在master节点的Redis上写入数据时，master就会记录写了多少数据，并记录在偏移量中。</p><p>在master上的操作，会同步到salve机器上，slave上的Redis也会记录偏移量。</p><p>当两台机器上的偏移量相同时，代表数据同步完成</p><p>偏移量是部分复制很重要的依据</p><p>查看Redis的偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication    # 查看复制信息</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;192.168.81.101,port&#x3D;6379,state&#x3D;online,offset&#x3D;8602,lag&#x3D;0</span><br><span class="line">master_repl_offset:8602             # 此时192.168.81.100上的偏移量是8602</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:8601</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3           # 向192.168.81.100写入数据</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication    # 查看复制信息</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;192.168.81.101,port&#x3D;6379,state&#x3D;online,offset&#x3D;8759,lag&#x3D;1</span><br><span class="line">master_repl_offset:8759             # 写入数据后192.168.81.100上的偏移量是8759</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:8758</span><br></pre></td></tr></table></figure><p><font color=red>master的run_id的改变会触发全量复制</font></p><p><font color=red>主从的offset相等则说明一致</font></p><h2 id="psync-run-id-offset"><a href="#psync-run-id-offset" class="headerlink" title="psync [run_id] [offset]"></a>psync [run_id] [offset]</h2><p>表示需要让run_id的redis将offset之后的数据同步给当前节点..</p><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ul><li>master的全部数据同步到slave</li><li>master在进行同步期间写的数据也同步到slave</li></ul><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><p><strong>1. slave -&gt; master:</strong></p><p>slave向master发送一个<code>psync ？ -1</code>的命令， 因为第一次不知道master节点的run_id和offset，所以传的是？和-1 </p><p><strong>2. master -&gt; slave:</strong></p><p>返回 master 的 run_id 和 offset</p><p><strong>3. slave保存master传来的信息</strong></p><p><strong>4. master 进行一个bgsave，生成RDB文件</strong></p><p><strong>5. master -&gt; slave:</strong></p><p><strong>传输RDB文件</strong>（全量备份），传输期间会把“write”的信息存到一个buffer中（repl_back_buffer），这部分就是在传输期间会导致不一致的数据，在传输完RDB之后会传输这部分消息</p><p><strong>6. master -&gt; slave:</strong></p><p><strong>传输buffer中的数据</strong>（增量备份）</p><p><strong>7. salve清除旧的数据，写入新数据</strong></p><p><img src="https://img-blog.csdnimg.cn/20200615164603150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="全量复制的开销"><a href="#全量复制的开销" class="headerlink" title="全量复制的开销"></a>全量复制的开销</h3><ol><li>bgsave的开销 （master）</li><li>RDB文件进行网络传输的时间 （master）</li><li>slave清空数据（slave）</li><li>slave加载RDB数据（slave）</li><li>可能的AOF重写时间 （slave加载完RDB之后，如果开启了AOF，那么会进行一个AOF重写）</li></ol><h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p>全量复制开销太大， 在没有必要使用全量复制的时候就可以使用部分复制来做.</p><p>部分复制其实还是<code>psync [run_id] [offset]</code> , 通知run_id对应的redis把offset之后的数据都同步过来。。master节点在收到这个指令之后，会去查看能否响应这个offset之后的数据（看这个offset是否在维护的范围内），如果可以响应，那么就将offset后的部分数据同步给slave..</p><p><img src="https://img-blog.csdnimg.cn/20200615170210883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis主从 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础学习</title>
      <link href="/2020/07/10/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/10/redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的数据结构以及使用场景分析"><a href="#redis的数据结构以及使用场景分析" class="headerlink" title="redis的数据结构以及使用场景分析"></a>redis的数据结构以及使用场景分析</h1><h2 id="1-string"><a href="#1-string" class="headerlink" title="1. string"></a>1. string</h2><h3 id="a-底层结构"><a href="#a-底层结构" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>string的数据结构存储的是key-value类型, value不仅可以是string，也可以是数字。</p><p>redis中的String是可以修改的，称为动态字符串（SDS），其实就是维护了一个预分配的字节数组，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&#123;</span></span><br><span class="line">T capacity;       <span class="comment">//数组容量</span></span><br><span class="line">  T len;            <span class="comment">//实际长度</span></span><br><span class="line">  <span class="keyword">byte</span> flages;  <span class="comment">//标志位,低三位表示类型</span></span><br><span class="line">  <span class="keyword">byte</span>[] content;   <span class="comment">//数组内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="b-常用命令"><a href="#b-常用命令" class="headerlink" title="b. 常用命令"></a>b. 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">set   [key]  [value]   给指定key设置值（set 可覆盖老的值）</span><br><span class="line"> </span><br><span class="line">get  [key]   获取指定key 的值</span><br><span class="line"> </span><br><span class="line">del  [key]   删除指定key</span><br><span class="line"> </span><br><span class="line">exists  [key]  判断是否存在指定key</span><br><span class="line"> </span><br><span class="line">mset  [key1]  [value1]  [key2]  [value2] ...... 批量存键值对</span><br><span class="line"> </span><br><span class="line">mget  [key1]  [key2] ......   批量取key</span><br><span class="line"> </span><br><span class="line">expire [key]  [time]    给指定key 设置过期时间  单位秒</span><br><span class="line"> </span><br><span class="line">setex    [key]  [time]  [value]  等价于 set + expire 命令组合</span><br><span class="line"> </span><br><span class="line">setnx  [key]  [value]   如果key不存在则set 创建，否则返回0</span><br><span class="line"> </span><br><span class="line">incr   [key]           如果value为整数 可用 incr命令每次自增1</span><br><span class="line"> </span><br><span class="line">incrby  [key] [number]  使用incrby命令对整数值 进行增加 number</span><br></pre></td></tr></table></figure><h3 id="c-使用场景举例"><a href="#c-使用场景举例" class="headerlink" title="c. 使用场景举例"></a>c. <strong>使用场景举例</strong></h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>简单key-value存储</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>setnx key value，当key不存在时，将 key 的值设为 value ，返回1</p><p>若给定的 key 已经存在，则setnx不做任何动作，返回0。</p><p>当setnx返回1时，表示获取锁，做完操作以后del key，表示释放锁，如果setnx返回0表示获取锁失败，整体思路大概就是这样</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>如知乎每个问题的被浏览器次数</p><h4 id="全局标志位"><a href="#全局标志位" class="headerlink" title="全局标志位"></a>全局标志位</h4><p>例如售罄标志，防止超卖</p><h2 id="2-hash"><a href="#2-hash" class="headerlink" title="2. hash"></a>2. hash</h2><h3 id="a-底层结构-1"><a href="#a-底层结构-1" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的Hash和 <strong>Java的HashMap更加相似</strong>，都是<font color=red><strong>数组+链表</strong></font>的结构，当发生 hash 碰撞时将会把元素追加到链表上，下面是hash存储的一个KV结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key&#x3D;JavaUser293847</span><br><span class="line">value&#x3D;&#123;</span><br><span class="line">  “id”: 1,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: 22,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（可以看作是 map&lt; key, map&lt;key, value&gt; &gt;）</p><h3 id="b-常用指令"><a href="#b-常用指令" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hset  [key]  [field] [value]    新建字段信息</span><br><span class="line"> </span><br><span class="line">hget  [key]  [field]    获取字段信息</span><br><span class="line"> </span><br><span class="line">hdel [key] [field]  删除字段</span><br><span class="line"> </span><br><span class="line">hlen  [key]   保存的字段个数</span><br><span class="line"> </span><br><span class="line">hgetall  [key]  获取指定key 字典里的所有字段和值 （字段信息过多,会导致慢查询 慎用：亲身经历 曾经用过这个这个指令导致线上服务故障）</span><br><span class="line"> </span><br><span class="line">hmset  [key]  [field1] [value1] [field2] [value2] ......   批量创建</span><br><span class="line"> </span><br><span class="line">hincr  [key] [field]   对字段值自增</span><br><span class="line"> </span><br><span class="line">hincrby [key] [field] [number] 对字段值增加number</span><br></pre></td></tr></table></figure><h3 id="c-应用场景"><a href="#c-应用场景" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>可以存储对象（ (对象名，成员变量名，值) ）</p><h2 id="3-list"><a href="#3-list" class="headerlink" title="3. list"></a>3. list</h2><h3 id="a-底层结构-2"><a href="#a-底层结构-2" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的list和Java中的LinkedList很像，底层都是一种链表结构，list的插入和删除操作非常快，时间复杂度为 0(1)，不像数组结构插入、删除操作需要移动数据。</p><p>像归像，但是redis中的list底层可不是一个双向链表那么简单。</p><p>在redis3.2版本之前，对list的实现是：</p><ul><li>当数据量较少的时候它的底层存储结构为一块连续内存，称之为ziplist(压缩列表)，它将所有的元素紧挨着一起存储，分配的是一块连续的内存；(保存的是entry数组)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">    int32 zlbytes;            <span class="comment">//压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset;    <span class="comment">//最后一个元素距离起始位置的偏移量,用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength;            <span class="comment">//元素个数</span></span><br><span class="line">    T[] entries;            <span class="comment">//元素内容</span></span><br><span class="line">    int8 zlend;                <span class="comment">//结束位 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>当数据量较多的时候，它的底层结构是使用linkedlist来做的，是离散的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 链表长度</span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。<br>quicklist其实就是又对linkedlist和ziplist进行了一层抽象，变为quicklistnode, 它可以指向压缩后的list，也可以指向未压缩的list, 如下图<br><img src="https://img-blog.csdnimg.cn/20200612103952646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;        <span class="comment">// 指向quicklist的头部</span></span><br><span class="line">    quicklistNode *tail;        <span class="comment">// 指向quicklist的尾部</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">// 列表中所有数据项的个数总和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">// quicklist节点的个数，即ziplist的个数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : <span class="number">16</span>;              <span class="comment">// ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">// 节点压缩深度设置，由list-compress-depth给定</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 指向上一个ziplist节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一个ziplist节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;           <span class="comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// 表示指向ziplist结构的总长度(内存占用长度)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// 表示ziplist中的数据项个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 编码方式，1--ziplist，2--quicklistLZF</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// 预留字段，存放数据的方式，1--NONE，2--ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试相关</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">// 扩展字段，暂时没用</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><h3 id="b-常用指令-1"><a href="#b-常用指令-1" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rpush  [key] [value1] [value2] ......    链表右侧插入</span><br><span class="line"> </span><br><span class="line">rpop    [key]  移除右侧列表头元素，并返回该元素</span><br><span class="line"> </span><br><span class="line">lpop   [key]    移除左侧列表头元素，并返回该元素</span><br><span class="line"> </span><br><span class="line">llen  [key]     返回该列表的元素个数</span><br><span class="line"> </span><br><span class="line">lrem [key] [count] [value]  删除列表中与value相等的元素，count是删除的个数。 count&gt;0 表示从左侧开始查找，删除count个元素，count&lt;0 表示从右侧开始查找，删除count个相同元素，count&#x3D;0 表示删除全部相同的元素</span><br><span class="line"> </span><br><span class="line">(PS:   index 代表元素下标，index 可以为负数， index&#x3D; 表示倒数第一个元素，同理 index&#x3D;-2 表示倒数第二 个元素。)</span><br><span class="line"> </span><br><span class="line">lindex [key] [index]  获取list指定下标的元素 （需要遍历，时间复杂度为O(n)）</span><br><span class="line"> </span><br><span class="line">lrange [key]  [start_index] [end_index]   获取list 区间内的所有元素 （时间复杂度为 O（n））</span><br><span class="line"> </span><br><span class="line">ltrim  [key]  [start_index] [end_index]   保留区间内的元素，其他元素删除（时间复杂度为 O（n））</span><br></pre></td></tr></table></figure><h3 id="c-应用场景-1"><a href="#c-应用场景-1" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>由于list它是一个按照插入顺序排序的列表，所以应用场景相对还较多的，例如：</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>lpop和rpush（或者反过来，lpush和rpop）能实现队列的功能<br><img src="https://img-blog.csdnimg.cn/20200612112455562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="朋友圈用户消息列表"><a href="#朋友圈用户消息列表" class="headerlink" title="朋友圈用户消息列表"></a>朋友圈用户消息列表</h4><p>例如想拿最近发得10条动态，就可以使用 lrange 来拿</p><h2 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. set</h2><h3 id="a-底层结构-3"><a href="#a-底层结构-3" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>Redis中的set和Java中的HashSet有些类似，它内部的键值对是<strong>无序的、唯一</strong> 的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值 NULL。当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。</p><h3 id="b-常用指令-2"><a href="#b-常用指令-2" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sadd  [key]  [value]  向指定key的set中添加元素</span><br><span class="line"> </span><br><span class="line">smembers [key]    获取指定key 集合中的所有元素</span><br><span class="line"> </span><br><span class="line">sismember [key] [value]   判断集合中是否存在某个value</span><br><span class="line"> </span><br><span class="line">scard [key]    获取集合的长度</span><br><span class="line"> </span><br><span class="line">spop  [key]   弹出一个元素</span><br><span class="line"> </span><br><span class="line">srem [key] [value]  删除指定元素</span><br><span class="line"></span><br><span class="line">sinterstore key1 key2 key3     将交集存在key1内</span><br></pre></td></tr></table></figure><h4 id="d-高频指令"><a href="#d-高频指令" class="headerlink" title="d. 高频指令"></a>d. 高频指令</h4><p>求交集：<code>sinterstore key1 key2 key3</code>   将交集存在key1内</p><h3 id="c-应用场景-2"><a href="#c-应用场景-2" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好、共同好友等功能。这个过程也就是求交集的过程。<br>（关键字：共同）</p><h2 id="5-zset-sorted-set"><a href="#5-zset-sorted-set" class="headerlink" title="5. zset ( sorted set )"></a>5. zset ( sorted set )</h2><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</p><h3 id="a-底层结构-4"><a href="#a-底层结构-4" class="headerlink" title="a. 底层结构"></a>a. 底层结构</h3><p>zset是基于skiplist(<a href="https://www.jianshu.com/p/cc379427ef9d" target="_blank" rel="noopener">跳表</a>)实现的。</p><h3 id="b-常用指令-3"><a href="#b-常用指令-3" class="headerlink" title="b. 常用指令"></a>b. 常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zadd [key] [score] [value] 向指定key的集合中增加元素</span><br><span class="line"> </span><br><span class="line">zrange [key] [start_index] [end_index] 获取下标范围内的元素列表，按score 排序输出</span><br><span class="line"> </span><br><span class="line">zrevrange [key] [start_index] [end_index]  获取范围内的元素列表 ，按score排序 逆序输出</span><br><span class="line"> </span><br><span class="line">zcard [key]  获取集合列表的元素个数</span><br><span class="line"> </span><br><span class="line">zrank [key] [value]  获取元素再集合中的排名</span><br><span class="line"> </span><br><span class="line">zrangebyscore [key] [score1] [score2]  输出score范围内的元素列表</span><br><span class="line"> </span><br><span class="line">zrem [key] [value]  删除元素</span><br><span class="line"> </span><br><span class="line">zscore [key] [value] 获取元素的score</span><br></pre></td></tr></table></figure><h3 id="c-应用场景-3"><a href="#c-应用场景-3" class="headerlink" title="c. 应用场景"></a>c. 应用场景</h3><p>zset可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</p><p>zset还可以用来存储学生的成绩，value值是学生的 ID,score是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。<br>（关键字：排行榜）<br><img src="https://img-blog.csdnimg.cn/20200612112945534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="d-高频指令-1"><a href="#d-高频指令-1" class="headerlink" title="d. 高频指令"></a>d. 高频指令</h3><ul><li>求名次为[a,b]的分数的玩家  ： <code>zrevrange [key] [start_index] [end_index]</code>  ps： zrange是升序，zrevrange是降序</li><li>求某一个玩家的排名  ： <code>zrank</code> </li><li>求分数为[a,b]的玩家  ： <code>zrangebyscore [key] [score1] [score2]</code> </li><li>求某一个玩家的分数 ： <code>zscore [key] [value]</code> ( zscore player_set czf )</li></ul><hr><h1 id="Redis缓存雪崩-穿透-击穿-无底洞问题"><a href="#Redis缓存雪崩-穿透-击穿-无底洞问题" class="headerlink" title="Redis缓存雪崩/穿透/击穿/无底洞问题"></a>Redis缓存雪崩/穿透/击穿/无底洞问题</h1><h2 id="缓存穿透-大量请求不命中"><a href="#缓存穿透-大量请求不命中" class="headerlink" title="缓存穿透 - 大量请求不命中"></a><font color=red>缓存穿透</font> - 大量请求不命中</h2><p><img src="https://img-blog.csdnimg.cn/20200529200256342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>当请求到来时，会先去查缓存，缓存中没有，然后才会“穿过”缓存层访问数据库，如果数据库中存有请求的结果，那么会将结果数据写到缓存中。 但如果访问的是数据库中也没有的记录，那么缓存中也不会存储。 当有大量请求访问数据库中不存在的数据时，那么缓存也就形同虚设，大量的并发直接落在了数据库上。</p><h3 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h3><h4 id="1-业务代码自身的问题"><a href="#1-业务代码自身的问题" class="headerlink" title="1. 业务代码自身的问题"></a>1. 业务代码自身的问题</h4><p>例如对于一些不合理的查询请求在业务代码层面上没有过滤掉等。</p><h4 id="2-恶意攻击、爬虫等"><a href="#2-恶意攻击、爬虫等" class="headerlink" title="2. 恶意攻击、爬虫等"></a>2. 恶意攻击、爬虫等</h4><h3 id="如何发现："><a href="#如何发现：" class="headerlink" title="如何发现："></a>如何发现：</h3><h4 id="1-业务的响应时间"><a href="#1-业务的响应时间" class="headerlink" title="1. 业务的响应时间"></a>1. 业务的响应时间</h4><p>如果出现了穿透，请求打到了存储层上，响应时间一定会收到影响。</p><h4 id="2-采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数"><a href="#2-采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数" class="headerlink" title="2. 采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数"></a>2. 采集相关指标（对缓存进行监控）：总调用数、缓存层命中数、存储层名中数</h4><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="方法一：把查询空结果也给缓存起来"><a href="#方法一：把查询空结果也给缓存起来" class="headerlink" title="方法一：把查询空结果也给缓存起来"></a>方法一：把查询空结果也给缓存起来</h4><ul><li>但这样会出现两个问题：<ol><li>对于恶意攻击来说，他们可以通过组合不同的键来查询空结果，所以穿透依然无法避免。</li><li>如果在查询某个关键的key的时候，查询接口因为一些意外原因（如网络延迟过大）而导致了查询到了空结果，在把这个空结果给缓存了之后，在其失效之前，对于这个key的查询得到的结果总是空的，但这个期间，有可能查询接口又恢复正常了（但却因为缓存缓存了空结果，所以还是查询不到）。 </li></ol></li></ul><h4 id="方法二-布隆过滤器拦截"><a href="#方法二-布隆过滤器拦截" class="headerlink" title="方法二: 布隆过滤器拦截"></a>方法二: <a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="noopener">布隆过滤器</a>拦截</h4><blockquote><p>布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data<br>structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200529200412695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此，在查询的时候，先去布隆过滤器查询，只有对于通过了布隆过滤器的查询，才会真正的去执行查询.  但这并不能100%的过滤掉所有空查询，因为布隆过滤器可以保证不通过的一定不存在，但不能保证通过的一定存在。</p><blockquote><p>缓存穿透应该是<br>当数据库中没有某个key对应的value时，缓存中也不会有该value的缓存。所以大量的对该value的查询该的请求会绕过缓存，直接查询数据库。</p><p>缓存中一般存的是 key+value ,但是布隆过滤器却可以告诉你 key<br>对应的value在数据库中存不存在，如果不存在就不用查询数据库了。</p><p>拿redis为例子： 请注意，用 redis 也可以做到判断 key 对应的value<br>在数据库中存不在，那就是把数据库里的所有value对应的key都储存在redis<br>中,而value可以为空，然后判断下key.IsExists()就可以了，但是这无疑会浪费大量空间，因为存储了数据库中所有的key。而且这也不符合缓存的初衷：咱不能暴力的把所有key都存下来，而是查询了啥key，我们缓存啥key。</p><p>而布隆过滤器是一种非常高效的数据结构，把所有数据库的value对应的key<br>存储到布隆过滤器里，几乎不消耗什么空间，而且查询也是相当的快！但是请注意，它只能判断 key 是否存在（而且会有一定的误差）。</p><p>所以一个查询先通过布隆顾虑器判断key是否存在(key 对应的value是否存在数据库中)，如果不存在直接返回空就好了。</p><p>那么布隆过滤器是怎么做到几乎不消耗空间来储存所有的key,并快速判断特定的key是否存在呢？</p><p>其实原理很简单，布隆过滤器 只是一个 byte数组，再加上几个映射函数。</p><p>每个key 都通过一系列映射函数，得到一系列的的值k，然后在这个byte数组上的把k下标的值变成1。</p><p>当要判断key是否存在时，通过映射函数映射得到的一系列k，查看byte数组相应下标k对应的值是否为1，如果有一个不为1，那么一定不存在。如果都是1<br>，那么可能存在。为什么可能而不是一定呢？因为这是一个误差问题，有可能别的key把某个k的位置变成了1，key越多时，误差越大。但是放心不会很大的，这是可以控制的，byte数组越长，误差越小。</p></blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font color=red>缓存雪崩</font></h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>一般情况下，缓存层将接受大量的服务请求，存储层只接受比较少的服务请求，但当缓存层发生异常/脱机（总之暂时无法工作）或是是指在某一个时间段，缓存集中过期失效，那么流量直接压向后端组件（例如数据库，或第三方API），造成级联故障。</p><blockquote><p>级联故障的解释：<br>网络中，一个或少数几个节点或连线的失效会通过节点之间的耦合关系引发其他节点也发生失效，进而产生级联效应，最终导致相当一部分节点甚至整个网络的崩溃，这种现象就称为级联失效，有时也形象称之为“雪崩” 。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200529200451927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="保证缓存的高可用性"><a href="#保证缓存的高可用性" class="headerlink" title="保证缓存的高可用性"></a>保证缓存的高可用性</h4><p>例如 Redis的主从机制，主机挂了从机上.</p><ul><li>Redis Sentinel</li><li>Redis Cluster</li><li>主从漂移</li></ul><h4 id="依赖隔离组件为后端限流"><a href="#依赖隔离组件为后端限流" class="headerlink" title="依赖隔离组件为后端限流"></a>依赖隔离组件为后端<font color=red>限流</font></h4><ul><li>Hystrix这种隔离组件</li><li>使用线程池/信号量隔离组件</li><li>使用Guava提供的限流API（令牌桶，漏桶）<h4 id="提前演练：例如压力测试"><a href="#提前演练：例如压力测试" class="headerlink" title="提前演练：例如压力测试"></a>提前演练：例如压力测试</h4><h4 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h4>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>一个超级热点数据如果因为超时失效或其他原因而从redis中被删除，那么短期大量的流量就会打到数据库上.</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h3><ul><li>对于热点数据不设置失效时间</li><li>提前将热点数据预存到redis中</li><li>使用第三方缓存或本地缓存（例如Guava的Cache），如果是热点数据的话，频繁被访问的情况话就不会被置换出去</li><li>限流（线程池、信号量、RateLimiter。。。）熔断（to study）</li></ul><h2 id="无底洞问题优化"><a href="#无底洞问题优化" class="headerlink" title="无底洞问题优化*"></a>无底洞问题优化*</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>加机器之后，性能不但没有提升，反而下降了。（因为加的机器多了，网络请求次数也多了，开销也大了）</p><p><img src="https://img-blog.csdnimg.cn/20200529200327517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="优化IO的几种方法"><a href="#优化IO的几种方法" class="headerlink" title="优化IO的几种方法"></a>优化IO的几种方法</h3><ol><li>命令本身优化：例如慢查询keys、hgetall bigkey</li><li>减少网络通信次数（无底洞问题主要优化的位置）</li><li>降低接入成本：例如客户端长连接/连接池、NIO等</li></ol><h3 id="四种批量优化的方法"><a href="#四种批量优化的方法" class="headerlink" title="四种批量优化的方法"></a>四种批量优化的方法</h3><ol><li>串行meget</li><li>串行io</li><li>并行io</li><li>hash_tag<br><img src="https://img-blog.csdnimg.cn/2020052920051222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><hr><h1 id="Redis对过期key的删除策略"><a href="#Redis对过期key的删除策略" class="headerlink" title="Redis对过期key的删除策略"></a>Redis对过期key的删除策略</h1><p>如果假设你设置了一批 key 只能存活 1 个小时，那么接下来 1 小时后，redis 是怎么对这批 key 进行删除的？</p><p><strong>定期删除 + 惰性删除</strong></p><ul><li><p><font size=4><strong>定期删除</strong></font>:</p><p>  redis是默认每隔100ms就<strong>随机抽取一些设置了过期时间的key</strong>，检查是否过期，如果过期就删除。注意！这里是<strong>随机抽取</strong>， 这样即使在redis中存储了很多数据的情况下，依然能够保证性能.</p></li><li><p><font size=4><strong>惰性删除</strong></font>:</p><p>  懒惰删除就如字面意思，每次在获取key的时候，会排查这个key是否过期，如果过期了就删除。</p></li><li><p><font size=4><strong>Redis内存淘汰机制</strong></font>:</p><p>  考虑一下这种场景，定期删除漏掉了许多过期的key，同时也没有去及时去排查，也就没触发惰性删除，这时，大量的过期key就会堆积在内存里，导致redis内存块耗尽…… 而解决这个问题的办法就是redis内存淘汰机制。</p><p>  <font size=3 color=brown><strong>Redis提供6种数据淘汰策略</strong></font></p><ul><li><p><strong>volatile-lru</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>最近最少使用</strong></font>的数据淘汰    </p></li><li><p><strong>volatile-ttl</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>即将过期的</strong></font>的数据淘汰    </p></li><li><p><strong>volatile-random</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>随机挑选</strong></font>数据淘汰    </p></li><li><p><strong>allkeys-lru</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>最近最少使用</strong></font>的数据淘汰 <strong>（最常用）</strong></p></li><li><p><strong>allkeys-random</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>随机挑选</strong></font>数据淘汰 </p></li><li><p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p><br><p><font size=3 color=brown><strong>4.0版本之后增加了以下两种：</strong></font></p><ul><li><strong>volatile-lfu</strong>：从<font color=red><strong>已经设置了过期时间的数据集</strong></font>中挑选<font color=blue><strong>最不经常使用</strong></font>的数据淘汰    </li></ul></li><li><p><strong>allkeys-lfu</strong>：从<font color=red><strong>所有数据集</strong></font>中挑选<font color=blue><strong>最不经常使用</strong></font>的数据淘汰    </p></li></ul></li></ul><hr><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis的事务其实就是<font color=brown size=4><strong>将一组命令打包，然后一次性执行完，期间不允许被打断，执行完毕后才能去执行其他客户端的命令</strong></font>。</p><p>所以Redis的事务满足：</p><ul><li><strong>不支持回滚</strong>的原子性</li><li>一致性</li><li>隔离性（因为是串行的）</li></ul><p>如果运行在特性的持久化模式下，也会具有一定程度的持久性。</p><blockquote><p>redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。（<a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener">来自issue:关于 Redis 事务不是原子性问题</a> ）</p></blockquote><hr><h1 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h1><h2 id="从海量Key里查询出某一固定前缀的Key"><a href="#从海量Key里查询出某一固定前缀的Key" class="headerlink" title="从海量Key里查询出某一固定前缀的Key"></a>从海量Key里查询出某一固定前缀的Key</h2><p><code>kyes pattern: 查找所有符合给定模式pattern的key</code></p><ul><li>一次性返回所有匹配的key</li><li>键的数量过大会使服务卡顿</li></ul><p>可以使用<code>scan cursor [Match pattern][COUNT count]</code> ：</p><ul><li>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程。</li><li>以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历。</li><li>不保证每次执行都返回给定数量的元素（count数大于key总数的时候）一次返回数量不可控，只能是大概率符合count。</li><li>支持模糊查询，即能够返回满足pattern匹配的key</li></ul><p>例如：<code>scan 0 match k1* count 10</code> ，注意，返回的值有可能的是重复的！ 因此需要去重！（例如写程序的时候用hashset）</p><p><code>blpop</code></p><h2 id="通过Redis实现分布式锁"><a href="#通过Redis实现分布式锁" class="headerlink" title="通过Redis实现分布式锁"></a>通过Redis实现分布式锁</h2><p>即分布式系统中，访问共同资源时的一种锁的实现。</p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，setnx key val 就是如果不存在key的话，那么就设置key为val。设置成功返回1， 失败返回0</p><p><code>SET lock_key random_value NX PX 5000</code> </p><p><strong>一定要放到一个语句里，保证“获取锁”和“设置超时时间”的原子性。如果设置完setnx以后，程序就挂掉了，那么这个key（锁）就一直被占用！</strong></p><h2 id="使用Redis做异步队列"><a href="#使用Redis做异步队列" class="headerlink" title="使用Redis做异步队列"></a>使用Redis做异步队列</h2><p>除了使用list的rpush, lpop, blpop 以外，可以用pub/sub:主题订阅者模式，来做。</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><ul><li>订阅一个频道：<ul><li>redis-cli1:  <code>subscribe myTopic</code>   ,之后进入监听状态</li><li>redis-cli2:  <code>subscribe myTopic</code>   ,之后进入监听状态</li><li>redis-cli3:  <code>subscribe myTopic</code>   ,之后进入监听状态</li><li>redis-cli4:  <code>publish myTopic &quot;hello!!&quot;</code> ：<br>这条消息发送出去之后，监听myTopic的3个客户端都收到了“hello!!”这个字符串。</li></ul></li></ul><p><strong>缺点</strong>：<br>但需要注意的是，消息的发布是无状态的，也就是无法保证可达。对于发布者来说，消息是即发即失的。 若想解决这个问题，需要用专业的消息队列，如kafka，rocketmq等。</p><h1 id="Redis如何做持久化"><a href="#Redis如何做持久化" class="headerlink" title="Redis如何做持久化"></a>Redis如何做持久化</h1><h2 id="RDB-快照-持久化：保存某一个时间点的全数据快照"><a href="#RDB-快照-持久化：保存某一个时间点的全数据快照" class="headerlink" title="RDB ( 快照 ) 持久化：保存某一个时间点的全数据快照."></a><a href="https://www.cnblogs.com/javazhiyin/p/12985656.html" target="_blank" rel="noopener">RDB ( 快照 ) 持久化</a>：保存某一个时间点的全数据快照.</h2><p>redis服务器加载时，会启用reids.conf文件中的配置信息，里面的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">save 900 1   # 就是900秒内如果有1条是写入指令，那么就触发一次快照</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">stop-writes-on-bgsave-error yes #当设置成yes，</span><br><span class="line"># 就是备份进程若出错了，则主进程就停止</span><br><span class="line"># 接受新的写入操作, 这是为了保证数据一致性！</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>可以根据不同的情况来合理配置。 <code>src</code>目录下的<code>dump.rdb</code>文件，就是redis系统定期备份的rdb文件. 它是一个二进制文件。</strong></p><h3 id="生成RDB备份文件的方式"><a href="#生成RDB备份文件的方式" class="headerlink" title="生成RDB备份文件的方式:"></a>生成RDB备份文件的方式:</h3><ul><li><h4 id="主动生成"><a href="#主动生成" class="headerlink" title="主动生成"></a>主动生成</h4><ul><li>SAVE: 阻塞Redis的服务器进程，直到RDB文件被创建完毕。 很少被使用，因为占用了主线程！！ 主线程是用来处理client的请求的！！</li><li>BGSAVE：Fork一个子进程创建RBD文件，不阻塞服务器进程！此时，主进程依然继续工作，子进程将内存中的数据写入临时文件中，因为copy-on-write的机制，父子进程此时会共享相同的物理页面，当(主)父进程处理写请求时，os会为父进程要写的页面创建一个副本（这个副本用于备份），而不是写入共享的页面！ RDB文件的载入，一般情况下是自动的，redis服务器启动时，若检测到rdb文件的存在，那么会载入这个文件<br><img src="https://img-blog.csdnimg.cn/20200412162246617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在fork时，子进程和父进程共享同一块资源空间，只有当父进程对此空间进行修改时，才会触发给子进程的资源复制，这一机制为copy-on-write. ，juc的copyOnWriteArrayList也是使用的这一原理。</li></ul></li><li><h4 id="被动生成"><a href="#被动生成" class="headerlink" title="被动生成"></a>被动生成</h4><ul><li>根据redis.conf里的save m n 定时触发 (用的是BGSAVE)</li><li>主从复制时，主节点自动触发（主节点发送rdb文件给从结点，这时，主节点会触发一次！）</li><li>执行debug reload</li><li>执行shutdown且没有开启AOF持久化，那么会触发一次RDB持久化</li></ul></li></ul><h3 id="RDB持久化的缺点"><a href="#RDB持久化的缺点" class="headerlink" title="RDB持久化的缺点:"></a>RDB持久化的缺点:</h3><ul><li>内存数据的<strong>全部同步</strong>！ 数据量大的时候会因为IO而严重影响性能！</li><li>可能会因为redis挂掉而丢失从当前到最近一次备份期间的所有数据！</li></ul><h2 id="AOF-Append-Only-File-持久化：保存写状态"><a href="#AOF-Append-Only-File-持久化：保存写状态" class="headerlink" title="AOF ( Append-Only-File )持久化：保存写状态"></a><a href="https://blog.csdn.net/liangd8888/article/details/89322605" target="_blank" rel="noopener">AOF ( Append-Only-File )</a>持久化：保存写状态</h2><ul><li>记录下除了查询以外的所有变更数据库状态的指令</li><li>以append的形式追加保存到AOF文件中</li><li>AOF持久化默认是关闭的，可以修改redis.conf来让其生效：            <ul><li>appendonly yes # 启动 aof</li><li>appendfsync everysec/always/no：<ul><li>always:  一旦缓存区发生改变，就立刻将内容写到文件中！</li><li>everysec: 每隔1s，写入一次</li><li>no: 什么时候写交给os判断, 一般是等缓存区写满了就写入一次。</li></ul></li></ul></li></ul><h3 id="日志重写解决AOF文件大小不断增大的问题（例如100条incr-可以用一条add-100实现）-其原理如下："><a href="#日志重写解决AOF文件大小不断增大的问题（例如100条incr-可以用一条add-100实现）-其原理如下：" class="headerlink" title="日志重写解决AOF文件大小不断增大的问题（例如100条incr 可以用一条add 100实现）, 其原理如下："></a>日志重写解决AOF文件大小不断增大的问题（例如100条incr 可以用一条add 100实现）, 其原理如下：</h3><ul><li>调用fork(), 创建一个子进程。</li><li>子进程把新的AOF写到一个临时文件里，新的AOF是根据内存数据生成对应的命令，并不需要区依赖原来的AOF文件。</li><li>主进程持续将新的变动写到内存中，并更新到“旧”的AOF文件里。</li><li>重写结束之后，会给主进程一个信号，然后把内存的buff追加到新生成的AOF文件。</li><li>用新的AOF替换掉旧的AOF。</li></ul><h2 id="从Redis中恢复数据"><a href="#从Redis中恢复数据" class="headerlink" title="从Redis中恢复数据"></a>从Redis中恢复数据</h2><p>其实只要重启就可以了。。</p><ul><li>检查AOF是否存在，若存在则直接加载AOF，不再去找RDB</li><li>若不存在AOF，则尝试加载RDB</li></ul><h2 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h2><ul><li><p>RDB优点：创建RDB那一瞬间的全部内存数据快照，文件小，恢复快</p></li><li><p>RDB缺点：无法保存最近一次快照之后的数据</p></li><li><p>AOF优点：可读性高，适合保存增量数据，数据不易丢失</p></li><li><p>AOF缺点：文件体积大，恢复时间长</p></li></ul><h2 id="redis-4-0之后的备份就是混合模式，即RDB-AOF"><a href="#redis-4-0之后的备份就是混合模式，即RDB-AOF" class="headerlink" title="redis 4.0之后的备份就是混合模式，即RDB-AOF."></a>redis 4.0之后的备份就是混合模式，即RDB-AOF.</h2><p>rdb用于全量备份，aof用于增量备份，为redis4.0之后的默认备份方式。</p><p>bgsave做全量持久化，aof做增量持久化</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由mysql的默认隔离级别引出的几个问题</title>
      <link href="/2020/07/10/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/10/mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>讲讲mysql有几个隔离级别？</li><li>mysql的默认隔离级别是哪个？</li><li>你们项目中选了哪个隔离级别，为什么？</li></ul><p>这上面三个问题是面美团的时候被问到的。。前两个还好。。第三个让我有点摸不着头脑。。查了些资料之后就记录一下这个问题吧</p><a id="more"></a><h1 id="Q1-MySQL有几个隔离级别"><a href="#Q1-MySQL有几个隔离级别" class="headerlink" title="Q1: MySQL有几个隔离级别"></a>Q1: MySQL有几个隔离级别</h1><p>送分题… 读未提交，读提交，可重复读，串行化</p><h1 id="Q2-Mysql的默认隔离级别是哪个？"><a href="#Q2-Mysql的默认隔离级别是哪个？" class="headerlink" title="Q2: Mysql的默认隔离级别是哪个？"></a>Q2: Mysql的默认隔离级别是哪个？</h1><p>送分题… mysql默认是可重复读，但oracle等其他的几个默认好像都是读提交…</p><p>而mysql默认是可重复也是有历史原因的，mysql的主从一致性是会通过binlog来做，而早期的mysql的binlog仅支持statement模式，因为保存的是执行的命令，在RC级别下可能会导致主从不一致，而这一问题在RR级别下就能够得到解决，所以就一直默认的使用RR级别</p><p><a href="https://www.cnblogs.com/shoshana-kong/p/10516404.html" target="_blank" rel="noopener">参考链接</a></p><h1 id="Q3-你们项目中选了哪个隔离级别，为什么？"><a href="#Q3-你们项目中选了哪个隔离级别，为什么？" class="headerlink" title="Q3: 你们项目中选了哪个隔离级别，为什么？"></a>Q3: 你们项目中选了哪个隔离级别，为什么？</h1><p>= = 作为一个零项目的蒟蒻，虽然答不上来自己的项目里使用了哪个隔离级别，但可以说一下一般会使用哪个隔离级别。。</p><p>如果没有RR（可重复读）的需求的话，能使用RC还是使用RC（读提交）。。</p><p>有以下几个原因：</p><h2 id="原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多"><a href="#原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多" class="headerlink" title="原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多"></a><font color=red><em>原因一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多</em></font></h2><p>这里说一个间隙锁导致死锁的例子：</p><ol><li>事务A使用间隙锁锁住了Id为(1,5)的索引， 然后插入一条id=8的记录</li><li>然后在尝试插入一条id=8的记录前发生了调度，轮到事务B去执行</li><li>事务B锁住了id为(6,10)的索引，然后尝试插入一条id=3的记录，然因为被事务A锁住了，所以等待</li><li>事务A又获得了执行权，开始执行插入id=8的记录，但因为id属于(6,10)的这个区间被事务B锁住了，所以等待事务B</li><li>事务B等事务A，事务A等事务B，死锁发生了..</li></ol><p><strong>而在RC隔离级别下，不存在间隙锁，其他事务是可以插入数据！</strong></p><p><strong>ps:在RC隔离级别下并不是不会出现死锁，只是出现几率比RR低而已！</strong></p><h2 id="原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行"><a href="#原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行" class="headerlink" title="原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行"></a><font color=red><em>原因二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行</em></font></h2><p>在RC隔离级别下，如果走聚簇索引进行全表扫描的时候，实际操作中，MySQL进行了改进，在进行过滤条件时，<strong>发现不满足条件后，会调用 unlock_row 方法，把不满足条件的记录放锁</strong> ， 即<strong>锁的粒度是行锁</strong>！</p><p>但是！！在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，锁的粒度是<strong>表级锁</strong>！！</p><p><a href="https://www.csdn.net/gather_2b/MtTaEg5sMzM4Ny1ibG9n.html" target="_blank" rel="noopener">参考链接</a></p><h2 id="原因三：在RC隔离级别下，半一致性读-semi-consistent-特性增加了update操作的并发性"><a href="#原因三：在RC隔离级别下，半一致性读-semi-consistent-特性增加了update操作的并发性" class="headerlink" title="*原因三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性"></a><font color=red><em>*原因三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性</em></font></h2><p>在RC隔离级别或者innodb_locks_unsafe_for_binlog被设置为true，并发时，如果update的记录发生锁等待，那么返回该记录的prev 版本（在返回前会将锁等待的这个lock从trx中删除掉），到mysql层进行where判断，是否满足条件。如果满足where条件，那么再次进入innodb层，真正加锁或者发生锁等待。</p><p>这样做的好处是：减少同一行记录的锁冲突及锁等待；无并发冲突时，直接读取最新版本加锁，有冲突时，不加锁，读取prev版本不需要锁等待。</p><p>缺点：非冲突串行话策略，对于binlog来说是不安全的。只能发生在RC隔离级别和innodb_lock_unsafe_for_binlog下。</p><p><a href="https://blog.51cto.com/yanzongshuai/2106100" target="_blank" rel="noopener">参考链接</a></p><hr><p><strong>其实Q3感觉说前两个原因就行了，第三个原因了解下吧.. 因为并不是在RC级别下特有的，设置innodb_locks_unsafe_for_binlog=true好像也可..</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2020/07/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FQ/"/>
      <url>/2020/07/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FQ/</url>
      
        <content type="html"><![CDATA[<h1 id="Q1-进程间的通信方式"><a href="#Q1-进程间的通信方式" class="headerlink" title="Q1: 进程间的通信方式"></a>Q1: 进程间的通信方式</h1><h2 id="1-匿名管道"><a href="#1-匿名管道" class="headerlink" title="1. 匿名管道"></a>1. 匿名管道</h2><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2]);</span><br></pre></td></tr></table></figure><p><font size=4><strong>存在形式</strong>:</font><br>无名管道：只存在于内存中的文件</p><p><font size=4><strong>使用限制</strong>:</font></p><ul><li>只支持半双工（单向交替传输）</li><li>只能在父子进程或兄弟进程中使用<br><img src="https://img-blog.csdnimg.cn/20200616143952244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><a id="more"></a><h2 id="2-命名管道"><a href="#2-命名管道" class="headerlink" title="2. 命名管道"></a>2. 命名管道</h2><p>解决了匿名管道的只能在父子进程中使用的限制。</p><p><font size=4><strong>存在形式</strong>:</font><br>命名管道：存在于实际的磁盘介质或者文件系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkfifo(const char *path, mode_t mode);</span><br><span class="line">int mkfifoat(int fd, const char *path, mode_t mode);</span><br></pre></td></tr></table></figure><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><p><font size=4><strong>管道的实现机制</strong>:</font></p><p>管道是由内核管理的一个缓冲区，这个缓冲区被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。</p><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h2><p>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。 进程控制块（PCB）中有对应的字段会保存对应消息队列的标识符. </p><p><font size=4><strong>存在形式</strong>:</font></p><p>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p><p><font size=4><strong>消息队列的优点</strong>:</font></p><ul><li>可以对消息随机读取，而不是像管道那样只能FIFO</li><li>比起管道, 消息队列能存储的信息更多更丰富</li></ul><h2 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h2><p>信号量可以理解成一个计数器，用于解决多个进程访问共享资源时的同步问题。</p><h2 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5. 共享内存"></a>5. 共享内存</h2><p>使多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。 这种方式需要依靠某种同步操作，例如：互斥锁和信号量等。 </p><h2 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h2><p>此方法主要用于不在同一台机器上的进程间的通信，例如客户端的一个进程和服务端的一个进程进行通信。</p><hr><h1 id="Q2-线程间的同步方式有哪些"><a href="#Q2-线程间的同步方式有哪些" class="headerlink" title="Q2: 线程间的同步方式有哪些"></a>Q2: 线程间的同步方式有哪些</h1><h2 id="1-互斥量-mutex-抢占式同步"><a href="#1-互斥量-mutex-抢占式同步" class="headerlink" title="1. 互斥量(mutex) (抢占式同步)"></a>1. 互斥量(mutex) (抢占式同步)</h2><p>就是上锁，在java中主要就是 synchronized 和 各种Lock. </p><h2 id="2-信号量-Semphore-非抢占式同步"><a href="#2-信号量-Semphore-非抢占式同步" class="headerlink" title="2. 信号量(Semphore) (非抢占式同步)"></a>2. 信号量(Semphore) (非抢占式同步)</h2><p>允许多个线程访问同一个资源，但需要控制同一时刻访问此资源的最大线程数量</p><h2 id="3-Java对管程的实现-wait-notify"><a href="#3-Java对管程的实现-wait-notify" class="headerlink" title="3. Java对管程的实现( wait / notify )"></a>3. Java对管程的实现( wait / notify )</h2><p>通过wait和notify来实现同步</p><hr><h1 id="Q3：死锁产生的条件"><a href="#Q3：死锁产生的条件" class="headerlink" title="Q3：死锁产生的条件"></a>Q3：死锁产生的条件</h1><h2 id="1-互斥"><a href="#1-互斥" class="headerlink" title="1. 互斥"></a>1. 互斥</h2><p>每一个资源只能分给一个进程.</p><h2 id="2-占用和等待"><a href="#2-占用和等待" class="headerlink" title="2. 占用和等待"></a>2. 占用和等待</h2><p>已经得到了某个资源的进程可以再请求新的资源. 并且可以在持有一些资源的状态下去等待暂时无法获取的资源</p><h2 id="3-不可抢占"><a href="#3-不可抢占" class="headerlink" title="3. 不可抢占"></a>3. 不可抢占</h2><p>已经分配给一个进程的资源，在这个进程没有使用完或主动释放之前，都不能被其他进程获取.</p><h2 id="4-环路等待"><a href="#4-环路等待" class="headerlink" title="4. 环路等待"></a>4. 环路等待</h2><p><img src="https://img-blog.csdnimg.cn/202006161521355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="Q4-解决死锁的策略："><a href="#Q4-解决死锁的策略：" class="headerlink" title="Q4: 解决死锁的策略："></a>Q4: 解决死锁的策略：</h1><h2 id="1-鸵鸟策略（解决策略就是不去解决）"><a href="#1-鸵鸟策略（解决策略就是不去解决）" class="headerlink" title="1. 鸵鸟策略（解决策略就是不去解决）"></a>1. 鸵鸟策略（解决策略就是不去解决）</h2><p>因为解决死锁的代价会比较大，且死锁发生的概率又比较小，并且死锁也不会对用户造成致命影响的话，那么就忽略它好了..</p><h2 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h2><p>不试图阻止死锁，而是当检测到死锁发生的时候，采取一些措施进行一个恢复</p><p><font color=brown size=4><strong>检测到死锁后的恢复策略：</strong></font></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><p>其实就是破坏死锁的必要条件中的一个就行了..</p><h2 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h2><p><font color=red><strong>在程序运行之前</strong></font>就预防发生死锁，就是破坏死锁产生的必要条件中的一个就行。</p><p>例如：</p><ul><li>给资源统一编号，进程只能按编号顺序来请求资源，破坏了环路等待； </li><li>分配资源时，一次性把所有资源都分配出去， 破坏了占有并等待；</li></ul><h2 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h2><p><font color=red><strong>在程序运行时</strong></font>，避免发生死锁。 使用银行家算法，保证在资源分配后依然能让系统处于安全状态.. 如果不安全的话就拒绝分配.</p><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ学习</title>
      <link href="/2020/07/10/rocketmq%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/10/rocketmq%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、消息队列能用来干什么？"><a href="#一、消息队列能用来干什么？" class="headerlink" title="一、消息队列能用来干什么？"></a>一、消息队列能用来干什么？</h1><p>异步，解耦，削峰。</p><h2 id="1-异步："><a href="#1-异步：" class="headerlink" title="1. 异步："></a>1. 异步：</h2><p>比如在电商的业务场景下，下单成功后要调用短信模块，邮件模块提醒买家下单成功的信息，而下单和发短信,发邮件使用消息队列来异步执行可以提高响应速度，增强用户体验。</p><h2 id="2-解耦"><a href="#2-解耦" class="headerlink" title="2. 解耦"></a>2. 解耦</h2><p>如果不用消息队列的话，对不同功能模块的调用是要写死在业务代码里的，也就是调用方在调用逻辑还耦合了”调用哪一个服务”这一层逻辑在里面逻辑，日后增加功能或删掉功能的时候，修改业务代码成本会比较大… 而使用消息队列的topic在中间进行一层解耦就能减轻这种问题，发送方只负责发送消息，消费方只负责消费消息，服务的类型被抽象成topic，由消息队列来管理。</p><h2 id="3-削峰"><a href="#3-削峰" class="headerlink" title="3. 削峰"></a>3. 削峰</h2><p>如果上游请求规模超出了下游服务的负载的话，使用消息队列可以起到一个缓冲的作用，即将请求先存起来然后让下游服务尽自己所能的去消费，保护了下游服务系统。</p><a id="more"></a><h1 id="二、-RocketMQ的架构组成"><a href="#二、-RocketMQ的架构组成" class="headerlink" title="二、 RocketMQ的架构组成"></a>二、 RocketMQ的架构组成</h1><p><img src="https://img-blog.csdnimg.cn/20200614215010509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>NameServer</strong>： 主要是对Broker进行管理，主要包括对消息的路由的管理。</li></ul><blockquote><p>被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群</p></blockquote><blockquote><p>每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</p></blockquote><ul><li><strong>Broker</strong>：主要负责对消息的存储，消息的转发</li></ul><blockquote><p>Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，顺带一提底层的通信和连接都是基于Netty实现的。</p></blockquote><blockquote><p>Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。</p></blockquote><ul><li><strong>Producer</strong>： 消息生产者，负责产生消息，一般由业务系统负责产生消息。<blockquote><p>RocketMQ 提供了三种方式发送消息：同步、异步和单向</p></blockquote></li></ul><blockquote><p>同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p></blockquote><blockquote><p>异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p></blockquote><blockquote><p>单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p></blockquote><ul><li><strong>Consumer</strong>：消息消费者，负责消费消息，一般是后台系统负责异步消费。</li></ul><blockquote><p>Consumer也由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制。</p></blockquote><blockquote><p><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</p></blockquote><blockquote><p>Push：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</p></blockquote><h1 id="三、消息的发送与消费"><a href="#三、消息的发送与消费" class="headerlink" title="三、消息的发送与消费"></a>三、消息的发送与消费</h1><h2 id="a-消息的三种发送方式"><a href="#a-消息的三种发送方式" class="headerlink" title=" a. 消息的三种发送方式"></a><font color=red> a. 消息的三种发送方式</font></h2><h3 id="1-发送同步消息"><a href="#1-发送同步消息" class="headerlink" title="1. 发送同步消息"></a>1. 发送同步消息</h3><p>特点：发送完阻塞，直到发送成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">        <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-发送异步消息"><a href="#2-发送异步消息" class="headerlink" title="2. 发送异步消息"></a>2. 发送异步消息</h3><p>特点：消息发送完之后不会阻塞，传入一个回调方法，当消息发送成功时会对回调方法进行调用。 适合对响应时间比较敏感的业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-单向发送消息"><a href="#3-单向发送消息" class="headerlink" title="3. 单向发送消息"></a>3. 单向发送消息</h4><p>不关心发送结果，发送完也不管是否发送成功，可靠性不高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b-消息的类型"><a href="#b-消息的类型" class="headerlink" title="b. 消息的类型"></a><font color=red>b. 消息的类型</font></h2><h3 id="1-顺序消息"><a href="#1-顺序消息" class="headerlink" title="1. 顺序消息"></a>1. 顺序消息</h3><p>就是按照消息的发送顺序来进行消费.</p><h3 id="2-延时消息"><a href="#2-延时消息" class="headerlink" title="2.  延时消息"></a>2.  延时消息</h3><p>在指定时间之后发送一个消息。例如在 10s钟之后发送一个消息，使用限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure><h3 id="3-事务消息"><a href="#3-事务消息" class="headerlink" title="3. 事务消息"></a><font color=brown size=5>3. 事务消息</font></h3><p><img src="https://img-blog.csdnimg.cn/20200630200614744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="消息的发送和提交"><a href="#消息的发送和提交" class="headerlink" title="消息的发送和提交"></a>消息的发送和提交</h4><p>(1) 发送消息（half消息）。</p><p>(2) 服务端响应消息写入结果。</p><p>(3) 根据发送结果去执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><h4 id="补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）"><a href="#补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）" class="headerlink" title="补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）"></a>补偿流程（在Commit或Rollback的时候失败了，消息会一直处于unknown状态）</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p><p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p><p>(3) 根据本地事务状态，重新Commit或者Rollback</p><h4 id="部分原理"><a href="#部分原理" class="headerlink" title="部分原理"></a>部分原理</h4><h5 id="半消息如何对消费端不可见"><a href="#半消息如何对消费端不可见" class="headerlink" title="半消息如何对消费端不可见"></a>半消息如何对消费端不可见</h5><p>发送出去的半消息会把消息的Topic和Queue等属性给存储到消息中，然后再对这两个属性进行替换，然后这个半消息就被存到一个消费者不可见的Queue中了（QueueId是0）。  当进行二段提交的时候，会将预先存在该消息里的原本消息的topic和queue再替换回去，然后发送出去，就能被消费者看到了…</p><h5 id="如何确定消息的最终状态"><a href="#如何确定消息的最终状态" class="headerlink" title="如何确定消息的最终状态"></a>如何确定消息的最终状态</h5><p>RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息是否状态已经确定（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。</p><p>这个Op消息也是被存储在一个单独的队列里面的，消费者不可见。</p><h5 id="如何处理二阶段失败的消息"><a href="#如何处理二阶段失败的消息" class="headerlink" title="如何处理二阶段失败的消息"></a>如何处理二阶段失败的消息</h5><p>如果在二阶段提交的时候失败了，比如在Commit的时候出现了网络问题导致Commit失败，那么这条消息还是处于unknown状态，为了解决这一问题，rocketmq的使用的方法就是“回查”。</p><p><strong>Broker端</strong>对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。</p><p><a href="https://www.cnblogs.com/hzmark/p/rocket_txn.html" target="_blank" rel="noopener">参考 RocketMQ事务消息实现分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发基础总结</title>
      <link href="/2020/07/09/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/09/Java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，<strong>用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异</strong>，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。为了实现了JVM的跨平台性，在向上提供了一系列的指令的同时，也提供了一些编程规则需要理解和遵守，比如Happens-Before原则，as-if-serial原则，主内存工作内存的概念等等。  </p><a id="more"></a><p>编译器，处理器进行不同层次上的指令重排会对多线程编程造成一定的影响，对于一些不应该进行指令重排的场景下，Java编译器通过在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序，JMM把内存屏障指令分为如下四类：<br><img src="https://img-blog.csdnimg.cn/20200401210939258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从JDK5开始，Java使用新的JSR-133内存模型，其主要作用就是提供了happens-before原则，屏蔽掉了底层解决内存可见行问题的实现，编程者只要记住happens-before原则，并在理解这一原则下进行编程，happens-before原则为：</p><ul><li>程序顺序原则：一个线程中的每个操作，都happens-before于该线程中的任意后续操作；</li><li>监视器锁规则：对一个锁的解锁，一定happens-before于随后对这个锁的读</li><li>volatile变量规则：对一个volatile域的<strong>写</strong>，happens-before于任意后续对这个volatile域的<strong>读</strong>.</li><li>传递性：A happens-before B， B happens-before C, 那么 A happens-before C.</li></ul><h2 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a><font color=brown>Happens-Before</font></h2><h3 id="1-程序次序规则："><a href="#1-程序次序规则：" class="headerlink" title="1. 程序次序规则："></a>1. 程序次序规则：</h3><p>在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</p><h3 id="2-管程锁定规则："><a href="#2-管程锁定规则：" class="headerlink" title="2. 管程锁定规则："></a>2. 管程锁定规则：</h3><p>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）</p><h3 id="3-volatile变量规则："><a href="#3-volatile变量规则：" class="headerlink" title="3. volatile变量规则："></a>3. volatile变量规则：</h3><p>就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</p><h3 id="4-线程启动规则："><a href="#4-线程启动规则：" class="headerlink" title="4. 线程启动规则："></a>4. 线程启动规则：</h3><p>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。</p><h3 id="5-线程终止规则："><a href="#5-线程终止规则：" class="headerlink" title="5. 线程终止规则："></a>5. 线程终止规则：</h3><p>在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。</p><h3 id="6-线程中断规则："><a href="#6-线程中断规则：" class="headerlink" title="6. 线程中断规则："></a>6. 线程中断规则：</h3><p>对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。</p><h3 id="7-传递规则："><a href="#7-传递规则：" class="headerlink" title="7. 传递规则："></a>7. 传递规则：</h3><p>这个简单的，就是happens-before原则具有传递性，即A happens-before B ， B happens-before C，那么A happens-before C。</p><h3 id="8-对象终结规则："><a href="#8-对象终结规则：" class="headerlink" title="8. 对象终结规则："></a>8. 对象终结规则：</h3><p>这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。</p><h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a><font color=brown>as-if-serial</font></h2><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</strong>。但依然会对毫无关联的两个语句进行指令重排，比如 int a=1; int b = 2; 它们的先后顺序可能会不一样.</p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title=" 主内存和工作内存"></a><font color=brown> 主内存和工作内存</font></h2><p>JMM定义的内存变量的访问规则（这里的变量是指线程共享的变量），有了主内存和工作内存的概念。 Java虚拟机规定所有变量（非线程私有的变量）都存在主内存中，而线程私有的局部变量存在线程独有的工作内存中，这两个概念比较类似Java内存规范中的堆（主内存）和虚拟机栈（工作内存），只是比较类似！</p><p>而<font color=red><strong>解决主内存的中的变量和工作内存中的变量的同步的方式</strong></font>就是用volatile关键字。</p><h1 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h1><ul><li><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ul><li>保证了“共享变量”在多线程环境下的“可见性”.</li></ul></li><li><h2 id="底层实现原则："><a href="#底层实现原则：" class="headerlink" title="底层实现原则："></a>底层实现原则：</h2><ul><li>对被volatile修饰的变量进行写操作的时候，JVM会向处理器发送一条#Lock前缀指令，这个指令的作用就是将对应缓存行的数据写回到被缓存的内存。</li><li>一个处理器将缓存回写到内存<code>&lt;addr&gt;</code>中，那么其他处理器中对<code>&lt;addr&gt;</code>内存地址的缓存都会被标记成’失效’。（缓存一致性协议MESI：由嗅探技术实现，每个缓存行会有一个标示位，分别代表 ：M(被修改)，E(独占的), S(共享的), I(无效的), 若读取的缓存行是无效，那么会重新从内存读取）</li></ul></li></ul><h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1. 作用："></a>1. 作用：</h2><p>对于 Synchronized 关键字而言，每一个Java对象都可以作为锁，具体表现为：</p><ul><li>普通<code>Synchronized</code>方法，锁是当前对象</li><li>静态<code>Synchronized</code>方法，锁是当前类的Class对象</li><li>对于<code>Synchronized</code>方法块，锁是括号里配置的对象</li></ul><h2 id="2-对象头："><a href="#2-对象头：" class="headerlink" title="2. 对象头："></a>2. 对象头：</h2><ul><li>普通对象的对象头占2个字，分别为：<ul><li>Mark Word：存储了对象的HashCode和锁信息</li><li>Class Metadata Address：存储对象类型的数据指针</li></ul></li><li>数组类对象的对象头占3个字，除了上面两个还有一个：<ul><li>Array Length: 数组的长度</li></ul></li></ul><h3 id="Mark-Word："><a href="#Mark-Word：" class="headerlink" title="Mark Word："></a>Mark Word：</h3><p><img src="https://img-blog.csdnimg.cn/20200401195923419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401200123515.png" alt="在这里插入图片描述"></p><h2 id="3-锁的升级和对比"><a href="#3-锁的升级和对比" class="headerlink" title="3. 锁的升级和对比:"></a>3. 锁的升级和对比:</h2><p><a href="https://www.cnblogs.com/pomer-huang/p/10965228.html" target="_blank" rel="noopener">https://www.cnblogs.com/pomer-huang/p/10965228.html</a><br><img src="https://img-blog.csdnimg.cn/20200401200452817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在讲重量级锁的调用的时候，可以说一下Java对管程的实现，即每一个对象都可以被视作一个MonitorObject，且维护着一个WaitSet，EntrySet，具体可以看 <a href="https://www.cnblogs.com/minikobe/p/12123065.html" target="_blank" rel="noopener">这个</a> 。<br><img src="https://img-blog.csdnimg.cn/20200613143648450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-原子操作的实现："><a href="#4-原子操作的实现：" class="headerlink" title="4. 原子操作的实现："></a>4. 原子操作的实现：</h2><ul><li><h3 id="处理器实现院子操作："><a href="#处理器实现院子操作：" class="headerlink" title="处理器实现院子操作："></a>处理器实现院子操作：</h3><ul><li><h4 id="1-总线锁："><a href="#1-总线锁：" class="headerlink" title="1.总线锁："></a>1.总线锁：</h4><ul><li>处理器提供一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将会被阻塞，此时处理器可以独享内存。缺点是，内存的不同地址之间其实不存在同步关系，这样会使得效率很低.</li></ul></li><li><h4 id="2-缓存锁"><a href="#2-缓存锁" class="headerlink" title="2. 缓存锁"></a>2. 缓存锁</h4><ul><li>利用<a href="https://blog.csdn.net/martin_ke/article/details/88851393" target="_blank" rel="noopener">缓存一致性协议</a>（如MESI协议），和处理器提供的LOCK指令对指定内存上锁，完成了对共享资源操作的互斥。</li><li>需要注意的是以下两个情况不能使用缓存锁：<ol><li>数据无法写入到缓存中，或操作数据跨多个缓存行。</li><li>处理器不支持缓存锁，此时会使用总线锁.</li></ol></li></ul></li><li><h3 id="Java实现原子操作："><a href="#Java实现原子操作：" class="headerlink" title="Java实现原子操作："></a>Java实现原子操作：</h3><ul><li><h4 id="CAS操作-Compare-And-Swap"><a href="#CAS操作-Compare-And-Swap" class="headerlink" title="CAS操作 ( Compare And Swap )"></a>CAS操作 ( Compare And Swap )</h4>通过调用处理器提供的<code>CMPXCHG</code>指令信实现，CAS的作用是：相等则交换。</li></ul></li><li><h4 id="CAS遇到的三大问题和解决方法："><a href="#CAS遇到的三大问题和解决方法：" class="headerlink" title="CAS遇到的三大问题和解决方法："></a>CAS遇到的三大问题和解决方法：</h4><ul><li><p>ABA问题</p><ul><li>问题：CAS会先检查操作值是否发生变化，如果发生了A-&gt;B-&gt;A这种变化则发现不出来。</li><li>解决方法：通过增加版本号的方式来解决: 1A-&gt;2B-&gt;3A</li></ul><ul><li><p>循环时间开销大：</p><ul><li>问题：在循环尝试CAS时，会给CPU带来很大的执行开销。</li><li>解决方法：如果jvm能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令可以延迟CPU的执行并且不会因此清空cpu的指令流水的预读取。</li></ul><ul><li>问题：只能保证一个共享变量执行原子操作：</li><li>解决方法：将多个共享变量打包成一个就行了。从JDK1.5开始，JDK提供了AtomicReference类来保证引用对象的原子性！</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="ReentrantLock与AQS"><a href="#ReentrantLock与AQS" class="headerlink" title="ReentrantLock与AQS"></a>ReentrantLock与AQS</h1><p><a href="详解AQS.md">详情</a></p><hr><h1 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a>start和run的区别</h1><p><img src="https://img-blog.csdnimg.cn/20200612201742112.png" alt="在这里插入图片描述"></p><ul><li>start方法是创建一个新的子线程并启动（调用run方法）</li><li>run方法只是Thread的一个普通方法的调用</li></ul><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><h2 id="1-新建-New-创建后尚未启动的线程的状态"><a href="#1-新建-New-创建后尚未启动的线程的状态" class="headerlink" title="1. 新建(New): 创建后尚未启动的线程的状态"></a>1. 新建(New): 创建后尚未启动的线程的状态</h2><h2 id="2-运行-Runnable-包含Running和Ready"><a href="#2-运行-Runnable-包含Running和Ready" class="headerlink" title="2. 运行(Runnable):包含Running和Ready"></a>2. 运行(Runnable):包含Running和Ready</h2><h2 id="3-无限期等待-Waiting-不会被分配CPU执行时间，需要被唤醒"><a href="#3-无限期等待-Waiting-不会被分配CPU执行时间，需要被唤醒" class="headerlink" title="3. 无限期等待(Waiting): 不会被分配CPU执行时间，需要被唤醒"></a>3. 无限期等待(Waiting): 不会被分配CPU执行时间，需要被唤醒</h2><ul><li>没有设置Timeout参数的Object.wait()方法</li><li>没有设置Timeout参数的Thread.join()方法</li><li>LockSupport.part()<h2 id="4-限期等待-timed-waiting-：在一定时间后会由系统自动唤醒"><a href="#4-限期等待-timed-waiting-：在一定时间后会由系统自动唤醒" class="headerlink" title="4. 限期等待(timed waiting)：在一定时间后会由系统自动唤醒"></a>4. 限期等待(timed waiting)：在一定时间后会由系统自动唤醒</h2></li><li>Thread.sleep()</li><li>没有设置Timeout参数的Object.wait() 方法</li><li>没有设置Timeout参数的Thread.join() 方法</li><li>LockSupport.parkNanos() 方法</li><li>LockSupport.parkUntil() 方法</li></ul><h2 id="5-阻塞-Blocked-等待获取排他锁"><a href="#5-阻塞-Blocked-等待获取排他锁" class="headerlink" title="5. 阻塞(Blocked): 等待获取排他锁"></a>5. 阻塞(Blocked): 等待获取排他锁</h2><ul><li>就是在竞争锁的时候，被阻塞了（例如因Lock 或者synchronize 关键字产生的状态）</li></ul><h2 id="6-终止（terminate）：终止状态"><a href="#6-终止（terminate）：终止状态" class="headerlink" title="6. 终止（terminate）：终止状态"></a>6. 终止（terminate）：终止状态</h2><p><img src="https://img-blog.csdnimg.cn/20200613143919461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait/notify/notifyAll"></a>wait/notify/notifyAll</h1><p>这几个方法光知道是个啥，但理解的还不够深入，这里做一下总结。</p><h2 id="1-wait-notify-notifyAll"><a href="#1-wait-notify-notifyAll" class="headerlink" title="1. wait/notify/notifyAll"></a>1. wait/notify/notifyAll</h2><p>在聊上面这个常见的方法之前，有必要先知道什么是管程。</p><p>当我们对临界区进行实现的时候，往往都是通过PV操作来实现的，但让程序员手动去做PV操作，很容易发生死锁。 所以为了方便编程，减少死锁出现的可能，我们希望能有一种数据结构或是软件模块来专门为我们提供对“临界区”的实现，这就是管程了～（但单单就说管程就是对临界区的实现是不准确的，继续往下看）</p><p>但仅仅是实现临界区还是不够的，比如，当线程A获取到锁了之后，进入了临界区，这个时候因为一些<font color=red><strong>外部条件X</strong></font>, 而导致无法进行下去，这个时候就需要等待这个外部条件X的发生… 而假设这个外部条件X的发生是需要另一个线程B进入到当前的这个“临界区”中才能触发，而因为线程A已经处于临界区中了，所以线程B需要等待线程A退出临界区才能继续执行。。 于是。。就变成了线程A在等线程B，线程B在等线程A，死锁出现了。。</p><p>因此，解决临界区中的线程同步问题，也是管程需要实现的。</p><p>一个解决方案就是，在临界区中的线程A一旦发现自己想要的外部条件没有发生，而不能够继续进行下去了的时候，就主动释放掉当前获取的这个临界区的锁，然后让其他线程进入到这个临界区来触发这个“外部条件X”的发生。。  等到这个外部条件X发生了之后，再通知线程A（之前因这个条件而释放掉锁的那个线程）重新去竞争锁，继续执行临界区..     </p><p>这个方法流程是不是很熟悉？ 没错，这不就是wait和notify嘛。。</p><p>因此，管程的实现主要就是：</p><ul><li>临界区的实现</li><li>monitor 对象及锁的实现</li><li>条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现</li></ul><p>然后就可以了解下<a href="https://www.jianshu.com/p/7f8a873d479c" target="_blank" rel="noopener">Java对管程的实现</a>了。</p><h3 id="a-对临界区的实现"><a href="#a-对临界区的实现" class="headerlink" title="a. 对临界区的实现"></a>a. 对临界区的实现</h3><p>Synchronized的同步块,  ReentrantLock在lock和unlock期间的那段代码.. 都是对临界区的实现..</p><blockquote><p>在Java中，每个对象都有两个池，锁(monitor)池和等待池</p></blockquote><blockquote><p>锁池：假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p></blockquote><blockquote><p>等待池：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.</p></blockquote><h3 id="b-条件变量以及定义在-monitor-对象上的-wait，signal-操作的实现"><a href="#b-条件变量以及定义在-monitor-对象上的-wait，signal-操作的实现" class="headerlink" title="b. 条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现"></a>b. 条件变量以及定义在 monitor 对象上的 wait，signal 操作的实现</h3><p>对于Synchronized，只实现了wait和signal操作…<br>如果想使用更细粒度的条件变量，来控制临界区内线程的同步，那么可以使用ReentrantLock来做.. </p><p>ReentrantLock提供了Condition变量，作为条件变量，对应的方法是 condition.await() 和 condition.signal() </p><h2 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h2><p>在Java中，每个对象都有两个池，锁(monitor)池和等待池</p><p>锁池:  假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p><p>等待池:  假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。</p><h2 id="wait原理："><a href="#wait原理：" class="headerlink" title="wait原理："></a>wait原理：</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><p>必读：<br><a href="https://blog.csdn.net/u014561933/article/details/58639411?utm_source=blogxgwz4" target="_blank" rel="noopener">sleep()和wait()方法与对象锁、锁池、等待池</a></p><p><a href="https://blog.csdn.net/qq_15037231/article/details/103440060" target="_blank" rel="noopener">Thread.yield()和Thread.sleep(0)</a></p><p><a href="https://blog.csdn.net/weixin_42621338/article/details/82899060?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">推荐阅读</a></p><h2 id="wait和park的区别"><a href="#wait和park的区别" class="headerlink" title="wait和park的区别"></a>wait和park的区别</h2><blockquote><p>我们在编程的时候必须能保证wait方法比notify方法先执行。如果notify方法比wait方法晚执行的话，就会导致因wait方法进入休眠的线程接收不到唤醒通知的问题。</p></blockquote><blockquote><p>而park、unpark则不会有这个问题，我们可以先调用unpark方法释放一个许可证，这样后面线程调用park方法时，发现已经许可证了，就可以直接获取许可证而不用进入休眠状态了。</p></blockquote><blockquote><p>LockSupport.park() 的实现原理是通过二元信号量做的阻塞，要注意的是，这个信号量最多只能加到1。我们也可以理解成获取释放许可证的场景。unpark()方法会释放一个许可证，park()方法则是获取许可证，如果当前没有许可证，则进入休眠状态，知道许可证被释放了才被唤醒。无论执行多少次unpark()方法，也最多只会有一个许可证。</p></blockquote><p><font color=red>另外，和wait方法不同，执行park进入休眠后并不会释放持有的锁。<br>并且，调用wait方法需要已经获取到锁，而park则不需要 </font></p><p><strong>wait的局限，以及Condition的出场</strong></p><p>使用wait的一个前提就是在sync的同步块里，而这又导致了在同步块里的条件变量只有一个，尽管可以通过共享变量的方式来实现“需要多个条件变量的场合”，但这样不仅实现的复杂度高，而且也不是很高效。因此，为了让在同步块中使用更多样的条件变量（即对某一资源或者某一个事件的等待），ReentrantLock就提供了Condition这一个神器，一个Lock可以new出多个Condition，即多个等待队列。</p><p>所以，await/signal, 可以看成强化版的 wait/notify</p><p><a href="https://blog.csdn.net/boguesfei/article/details/81736489" target="_blank" rel="noopener">参考链接</a></p><h1 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h1><h2 id="1-信号量和条件变量的区别是什么？"><a href="#1-信号量和条件变量的区别是什么？" class="headerlink" title="1. 信号量和条件变量的区别是什么？"></a>1. 信号量和条件变量的区别是什么？</h2><ul><li>条件变量可以通过<code>signal()</code>唤醒队首阻塞线程，使用<code>signalAll()</code>来唤醒所有阻塞线程；而信号量只能通过<code>release()</code>唤醒队首阻塞线程.</li><li>信号量可以初始化初始的值，但条件变量不可以，但条件变量+共享变量可以实现初始值大于0的信号量的功能。（个人理解成，条件变量的功能类似一个初始值为0的信号量 ）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解AQS</title>
      <link href="/2020/07/09/%E8%AF%A6%E8%A7%A3AQS/"/>
      <url>/2020/07/09/%E8%AF%A6%E8%A7%A3AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h1><p>我们常用的j.u.c包里，提供了许多强大的同步工具，例如ReentrantLock，Semphore，ReentrantReadWriteLock等，但当这些工具难以满足某个场景的需求时，我们就需要定制化我们自己的同步器，这时，我们可能会想，如果能有一个像Servlet这种只要重写某几个方法就能完成一把定制锁的实现的就好了！！ 没错，AQS就是提供了这样一种功能，它如果要实现一个同步器的大部分通用功能都帮我们实现好了，然后提供出抽象函数供我们重写来定制化自己想要的同步器。 实际上，上面所说的ReentrantLock，Semphore，ReentrantReadWriteLock等juc包中同步工具的实现，也都是在AQS的辅助下进行的“二次开发”。  例如在ReentrantLock继承了Lock接口，然后利用定制化了的继承了AQS的类，来去实现Lock接口。</p><a id="more"></a><hr><h1 id="AQS提供了什么功能"><a href="#AQS提供了什么功能" class="headerlink" title="AQS提供了什么功能"></a>AQS提供了什么功能</h1><p>同步器一般会包括两种方法，一种是acquire方法， 另一种是release方法； acquire方法是尝试获取锁操作，如果获取不到就阻塞(park)当前线程，并将其放入等待队列中；release方法是释放锁操作，然后会从等待队列中出队一个或多个被acquire阻塞的线程并将其唤醒(unpark). </p><p>j.u.c包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire和release操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await和FutureTask.get，在这个框架里，这些方法都是acquire操作。但是，J.U.C为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p><ul><li>阻塞(例如：acquire)和非阻塞（例如：tryAcquire）同步。</li><li>可选的超时设置，让调用者可以放弃等待</li><li>通过中断实现的任务取消，通常是分为两个版本，一个acquire可取消，而另一个不可以（例如ReentrantLock中的<code>lockInterruptibly()</code>就是可在阻塞等待中被中断的，而<code>lock()</code>是阻塞等待中不可被中断的）。</li></ul><hr><h1 id="读源码之前需要知道的知识"><a href="#读源码之前需要知道的知识" class="headerlink" title="读源码之前需要知道的知识"></a>读源码之前需要知道的知识</h1><h2 id="AQS的内部队列"><a href="#AQS的内部队列" class="headerlink" title="AQS的内部队列"></a>AQS的内部队列</h2><p>在AQS中，被阻塞的线程会被打包成一个Node然后放到等待队列中，head指向队列头结点，tail指向尾结点，队列不存在时（未初始化时）的样子为：<code>head==tail==null</code> ，初始化之后，队列为空的情况为：<code>head==tail==dummy头结点</code>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200407163818175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>head指向dummy头结点，这个头结点存在的意义是为了方便队列操作，并且里面保存的thread恒为null。下面来看一下node每个字段的意思</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>为了抓住重点学习，这里只介绍Node里的重要成员：</p><ul><li>thread ：当前结点里保存的线程</li><li>prev，next：当前结点的前后指针，这里队列的实现是<strong>带有头结点的双向链表</strong>。 prev是靠近头结点那一端的，next是靠近尾结点那一端的。</li><li>waitStatus：初始状态为0。为-1时，表示存在正在阻塞等待的线程，结点入队之后，会自旋一次来再次尝试tryAcquire，如果依然失败，才会进入阻塞，自旋的这一次就是把waitStatus字段CAS成-1。 这一字段取值范围如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前结点为-1, 则说明后一个结点需要park阻塞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="AQS源码解读"><a href="#AQS源码解读" class="headerlink" title="AQS源码解读"></a>AQS源码解读</h1><p>这里先更新一下独占式的部分。。共享式的日后再看.</p><h2 id="独占式代码部分"><a href="#独占式代码部分" class="headerlink" title="独占式代码部分"></a>独占式代码部分</h2><p>先有个宏观上的理解，如下图：<br><img src="https://img-blog.csdnimg.cn/20200407154554112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE2Mjk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中tryRelease，tryAcquire是非阻塞式获取锁。 有了宏观上的框架，再去看一下实现的细节。</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>短路原理</code>, 如果<code>tryAcquire</code>成功的话，就直接跳出if了； 如果 <code>tryAcquire</code>失败，那么会先执行<code>addWaiter</code>把当前线程打包成一个node放入等待队列， 然后再执行<code>acquireQueued</code>尝试一次自旋，如果依然无法获取到锁，就进入阻塞。</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">     <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">     Node pred = tail;</span><br><span class="line">     <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">         node.prev = pred;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">             pred.next = node;</span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     enq(node);</span><br><span class="line">     <span class="keyword">return</span> node;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将当前线程打包成一个node， 然后将这个node入队，如果入队失败则有2种情况：</p><ul><li>队列还不存在（队列还没初始化）</li><li>在入队时，出现了同步问题。（这里的队列也是临界资源，如果CAS失败说明资源竞争失败）<br>当入队失败时，进入<code>enq</code>函数，这一函数的作用是：初始化队列并自旋入队操作。</li></ul><h3 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列未初始化，那么就初始化队列，如果已经初始化了，就将当前结点自旋入队，该方法一定返回true.</p><p><strong>线程被打包成结点，然后入队之后，会进入acquireQueued进行一次自旋try，如果依然失败就阻塞</strong></p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    booleanfailed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// （*）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断前驱结点是不是head，因为head指向的是dummy结点，因此，如果前驱结点就是head了，那么当前结点就是队首了！！ 然后只有队首的结点才有资格在第一次自旋的时候进行<code>tryAcquire</code> </p><p><strong>每一个结点不会改变自己的waitStatus, 只会改变在队列中前驱结点的waitStatus</strong> ， 因此，如果前驱结点是0，则通过CAS操作将其变为-1，然后自旋一次，如果前驱结点是-1，则说明已经自旋过一次了，然后才能进入 <code>parkAndCheckInterrupt</code>函数，也就是将当前结点的线程阻塞。</p><p>这个函数里的几个细节，如果队首元素成功tryAcquire，则需要进行出队操作，把当前结点设置成dummy结点就可以了。<br>在setHead的时候。 <strong>会将thread设置成null 也是用于help gc</strong> 。 同时也要手动让前驱结点的next设置为null， 方便gc回收..</p><p><strong>到此位置，线程就会被卡在<code>parkAndCheckInterrupt</code>这个函数中，等待被唤醒</strong></p><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release的实现就更短了，如果tryRelease成功的话，就看是否还存在阻塞等待的线程，<code>if (h != null &amp;&amp; h.waitStatus != 0)</code> 这句话的判断就是判断否还存在阻塞等待的线程。 如果h是null的话，则说明队列根本就不存在，更别说等待的线程了，如果h.waitStatus不是0的话，则说明队列里存在等待的线程node。</p><p>如果存在正在等待的线程的话，就<code>unparkSuccessor</code> , 即唤醒这个正在等待的队首线程. </p><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，s是下一个需要被唤醒的node结点，然后后面会对其进行unpark（唤醒）操作。</p><h1 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h1><p>到目前位置，只是简单过完了一遍AQS的独占式的acquire和release操作， 它帮我们完成了一部分同步状态管理事情，但是最关键的<code>tryAcquire</code>和<code>tryRelease</code> 其实它是一个需要我们去重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要做的事情"><a href="#需要做的事情" class="headerlink" title="需要做的事情"></a>需要做的事情</h2><p>在使用AQS的时候，往往需要我们自己去重写：</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively：如果对于当前（正调用的）线程，同步是以独占方式进行的，则返回 true。此方法只是 abstractqueuedsynchronizer.conditionobject 方法内进行内部调用，因此，如果不使用条件，则不需要定义它。</li></ul><p>在实现tryAcquire的时候，我们需要对内部的status进行操作，AQS也提供给了我们关于Status操作接口，分别是：</p><ul><li>getState()</li><li>setState(int)</li><li>compareAndSetState(int, int)</li></ul><p>源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">state = newState;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AQS在使用的时候，往往是使用一个内部类继承AQS，然后重写上述提到的方法，然后就可以在当前类中使用这个内部类的acquire / release来实现同步了</strong></p><h2 id="使用AQS完成信号量的功能"><a href="#使用AQS完成信号量的功能" class="headerlink" title="使用AQS完成信号量的功能"></a>使用AQS完成信号量的功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了AQS的原理之后，可以来趁热打铁的看一下ReentrantLock的加锁实现</p><h1 id="ReentrantLock的原理"><a href="#ReentrantLock的原理" class="headerlink" title="ReentrantLock的原理"></a>ReentrantLock的原理</h1><p>这里主要详细介绍一下ReentrantLock对AQS的两种实现方式：</p><ul><li>公平锁（FairSync）</li><li>非公平锁（NonfairSync）<br><img src="https://img-blog.csdnimg.cn/20200407212955709.png" alt="在这里插入图片描述"><br>其中Sync是公平锁和非公平锁的抽象基类，里面已经初步实现了一些方法，但其中的<code>lock()</code>方法和<code>tryAcquire()</code>方法依然是抽象的，需要子类去进行实现，而公平锁和非公平锁的主要区别也主要在这两个函数中，下面来看一下。</li></ul><h2 id="公平锁与非公平锁的实现区别"><a href="#公平锁与非公平锁的实现区别" class="headerlink" title="公平锁与非公平锁的实现区别"></a>公平锁与非公平锁的实现区别</h2><h3 id="lock操作"><a href="#lock操作" class="headerlink" title="lock操作:"></a>lock操作:</h3><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，非公平锁在lock的时候会进行一次CAS操作，如果直接获取到锁了的话，那么就直接继续执行。 在临界区的执行速度比较快的情况下，非公平锁会比公平锁要更快，因为在唤醒阻塞线程的过程中，有可能有其他线程已经取得锁然后执行完并释放了。。 </p><h3 id="tryAcquire操作："><a href="#tryAcquire操作：" class="headerlink" title="tryAcquire操作："></a>tryAcquire操作：</h3><h4 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里直接进行CAS ， 尝试拿锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 重入时，给state加一个acquires偏移量，对应release时会减去一次</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁-1"><a href="#公平锁-1" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里会先判断是否存在比当前线程等待更久的线程！</span></span><br><span class="line">    <span class="comment">// 只有不存在等待的线程的时候，才有资格去尝试获取锁资源（CAS）</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 重入时，给state加一个acquires偏移量，对应release时会减去一次</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，在tryAcquire时，公平锁会先判断是否存在比当前线程等待的更久的线程，如果不存在这样的线程，才能进行CAS尝试获取锁； 而非公平锁是直接进行CAS获取锁。</p><h2 id="关于Interrupt"><a href="#关于Interrupt" class="headerlink" title="关于Interrupt"></a>关于Interrupt</h2><p>我们知道， thread1.interrupt()就是将thread1的中断标志位置为1（Thread.interrupted()是检测并清除中断标志，thread1.isInterrupted()是仅仅检测thread1的中断标志但不清除）.</p><p><code>ReentrantLock()</code> 的<code>lock()</code>方法，thread因等待资源而被阻塞在等待队列中的时候，不会被打断，而是先将这个中断标记位记下来，然后当获取到锁资源之后，执行<code>selfInterrupt()</code>, 也就是在获得锁资源后打断自己！！  如果希望在阻塞队列中依然可以被打断的话，应该使用<code>lockInterruptibly</code> , 这个lock操作是可以允许线程在阻塞等待时被中断的！</p><p>到此为止，我们看到了在ReentrantLock中对tryAcquire和tryRelease的实现，分别实现了公平竞争和非公平竞争的场景，因为这里的ReentrantLock是独占式的锁（也就是说资源只允许被一个线程获取，也可以理解成01信号量），所以并没有实现 <code>tryAcquireShared</code>和<code>tryReleaseShared</code> 这两个方法。 实际上，我们在使用的时候也是，需要哪种模式就实现对应模式的acquire和release.  </p><p>对于 <code>tryAcquireShared</code>和<code>tryReleaseShared</code> 这两个方法的实现例子，可以去看看Semphore的源码，它就是只重写了<code>tryAcquireShared</code>和<code>tryReleaseShared</code>，理解完上面分析的代码之后，去看Semphore的源码也不会很困难了。。日后有时间再写<code>Semphore</code>的源码记录把。。</p>]]></content>
      
      
      <categories>
          
          <category> Java并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/05/hello-world/"/>
      <url>/2020/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
