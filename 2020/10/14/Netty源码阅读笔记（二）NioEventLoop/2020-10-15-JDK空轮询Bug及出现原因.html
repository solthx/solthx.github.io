<hr>
<p>title: JDK空轮询Bug出现原因及解决方法<br>comments: true<br>date: 2020-10-15 10:55:51<br>updated: 2020-10-15 10:55:51<br>tags:<br>categories:</p>
<hr>
<h1 id="什么是JDK空轮询Bug"><a href="#什么是JDK空轮询Bug" class="headerlink" title="什么是JDK空轮询Bug"></a>什么是JDK空轮询Bug</h1><p><strong>JDK NIO的空轮询BUG其实是JDK NIO在Linux系统下的epoll空轮询问题。</strong></p>
<p>epoll是Linux下一种高效的IO复用方式，相较于select和poll机制来说。其高效的原因是将基于事件的fd放到内核中来完成，在内核中基于红黑树+链表数据结构来实现，链表存放有事件发生的fd集合，然后在调用epoll_wait时返回给应用程序，由应用程序来处理这些fd事件。</p>
<p>使用IO多路复用，Linux下一般默认就是epoll，Java NIO在Linux下默认也是epoll机制，但是JDK中epoll的实现却是有漏洞的。其中一个就是Epoll的空轮询Bug, 就是即使是关注的select轮询事件返回数量为0，NIO照样不断的从select本应该阻塞的Selector.select()/Selector.select(timeout)中wake up出来，导致CPU飙到100%问题。</p>
<h1 id="官方给的Bug复现方法"><a href="#官方给的Bug复现方法" class="headerlink" title="官方给的Bug复现方法:"></a><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302" target="_blank" rel="noopener">官方给的Bug复现方法</a>:</h1><p>A DESCRIPTION OF THE PROBLEM :<br>The NIO selector wakes up infinitely in this situation..<br>0. server waits for connection</p>
<ol>
<li>client connects and write message</li>
<li>server accepts and register OP_READ</li>
<li>server reads message and remove OP_READ from interest op set</li>
<li>client close the connection</li>
<li>server write message (without any reading.. surely OP_READ is not set)</li>
<li>server’s select wakes up infinitely with return value 0</li>
</ol>
<h1 id="产生这一Bug的原因："><a href="#产生这一Bug的原因：" class="headerlink" title="产生这一Bug的原因："></a>产生这一Bug的原因：</h1><p>因为poll和epoll对于突然中断的连接socket会对返回的eventSet事件集合置为EPOLLHUP或者EPOLLERR，<font color=red><strong>eventSet事件集合发生了变化</strong></font>，这就导致Selector会被唤醒，如果仅仅是因为这个原因唤醒且没有感兴趣的时间发生的话，就会变成空轮询。 </p>
<p><font size=4><strong>epoll感兴趣的事件集合</strong></font></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EPOLLIN</td>
<td>表示对应的文件描述符可以读（包括对端SOCKET正常关闭)</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td>表示对应的文件描述符可以写；</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td>表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</td>
</tr>
<tr>
<td><font color=red>EPOLLERR</font></td>
<td>表示对应的文件描述符发生错误；</td>
</tr>
<tr>
<td><font color=red>EPOLLHUP</font></td>
<td>表示对应的文件描述符被挂断；</td>
</tr>
<tr>
<td>EPOLLET</td>
<td>将 EPOLL设为边缘触发(Edge Triggered)模式（默认为水平触发），这是相对水平触发(Level Triggered)来说的。</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td>只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socke的话，需要再次把这个socket加入到EPOLL队列里</td>
</tr>
</tbody></table>
<!-- more -->

<h1 id="解决这一Bug的方法"><a href="#解决这一Bug的方法" class="headerlink" title="解决这一Bug的方法"></a>解决这一Bug的方法</h1><p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933" target="_blank" rel="noopener">[JDK-6403933]</a>提到了几个解决方案，这里就只说一下netty的解决方式吧…</p>
<p>就是通过记录空轮询次数来判断是否发生了空轮询（Netty默认是512次），若发生空轮询则重建Selector. </p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>{
    Selector selector = <span class="keyword">this</span>.selector;
    <span class="keyword">try</span> {
        <span class="comment">// selectCnt记录轮询次数, 空轮询次数超过SELECTOR_AUTO_REBUILD_THRESHOLD(默认512)之后，</span>
        <span class="comment">// 则重建selector</span>
        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;
        <span class="comment">// 记录当前事件</span>
        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();
        <span class="comment">// selectDeadLineNanos = 当前时间 + 距离最早的定时任务开始执行的时间</span>
        <span class="comment">// 计算出select操作必须在哪个时间点之前被wakeUp （不然一直被阻塞的话，定时任务就没发被执行）</span>
        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);

        <span class="keyword">long</span> normalizedDeadlineNanos = selectDeadLineNanos - initialNanoTime();
        <span class="keyword">if</span> (nextWakeupTime != normalizedDeadlineNanos) {
            nextWakeupTime = normalizedDeadlineNanos;
        }

        <span class="keyword">for</span> (;;) {
            <span class="comment">// 计算出当前select操作能阻塞的最久时间</span>
            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;
            <span class="comment">// 超过最长等待时间：有定时task需要执行</span>
            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) {
                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) {
                    <span class="comment">//非阻塞，没有数据返回0</span>
                    selector.selectNow();
                    selectCnt = <span class="number">1</span>;
                }
                <span class="keyword">break</span>;
            }

            <span class="comment">// If a task was submitted when wakenUp value was true, the task didn't get a chance to call</span>
            <span class="comment">// Selector#wakeup. So we need to check task queue again before executing select operation.</span>
            <span class="comment">// If we don't, the task might be pended until select operation was timed out.</span>
            <span class="comment">// It might be pended until idle timeout if IdleStateHandler existed in pipeline.</span>
            <span class="comment">// 确定当前确实没有任务需要去执行</span>
            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {
                selector.selectNow();
                selectCnt = <span class="number">1</span>;
                <span class="keyword">break</span>;
            }

            <span class="comment">// 进行select操作, 下面select阻塞中，别人唤醒也可以可以的</span>
            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);
            selectCnt ++;

            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {
                <span class="comment">// - Selected something,</span>
                <span class="comment">// - waken up by user, or</span>
                <span class="comment">// - the task queue has a pending task.</span>
                <span class="comment">// - a scheduled task is ready for processing</span>
                <span class="keyword">break</span>;
            }

            <span class="comment">// 如果select没有触发超时返回，并且确实是监听到了新事件而不是空轮询，那么就一定会在上面的if中返回了</span>
            <span class="comment">// 所以往下走的话，有2个情况:</span>
            <span class="comment">//      1. select超时</span>
            <span class="comment">//      2. 发生了空轮询</span>

            <span class="keyword">if</span> (Thread.interrupted()) {
                <span class="comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span>
                <span class="comment">// As this is most likely a bug in the handler of the user or it's client library we will</span>
                <span class="comment">// also log it.</span>
                <span class="comment">//</span>
                <span class="comment">// See https://github.com/netty/netty/issues/2426</span>
                <span class="keyword">if</span> (logger.isDebugEnabled()) {
                    logger.debug(<span class="string">"Selector.select() returned prematurely because "</span> +
                            <span class="string">"Thread.currentThread().interrupt() was called. Use "</span> +
                            <span class="string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span>);
                }
                selectCnt = <span class="number">1</span>;
                <span class="keyword">break</span>;
            }


            <span class="keyword">long</span> time = System.nanoTime();
            <span class="comment">// select超时的情况（因为实际经过的时间确实是 &gt;= 应该最大阻塞时间 ）</span>
            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) {
                <span class="comment">// timeoutMillis elapsed without anything selected.</span>
                selectCnt = <span class="number">1</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;
                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {
                <span class="comment">// 空轮询次数超过了 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512）</span>
                <span class="comment">// The code exists in an extra method to ensure the method is not too big to inline as this</span>
                <span class="comment">// branch is not very likely to get hit very frequently.</span>

                <span class="comment">// 重建selector</span>
                selector = selectRebuildSelector(selectCnt);
                selectCnt = <span class="number">1</span>;
                <span class="keyword">break</span>;
            }

            currentTimeNanos = time;
        }

        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) {
            <span class="keyword">if</span> (logger.isDebugEnabled()) {
                logger.debug(<span class="string">"Selector.select() returned prematurely {} times in a row for Selector {}."</span>,
                        selectCnt - <span class="number">1</span>, selector);
            }
        }
    } <span class="keyword">catch</span> (CancelledKeyException e) {
        <span class="keyword">if</span> (logger.isDebugEnabled()) {
            logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                    selector, e);
        }
        <span class="comment">// Harmless exception - log anyway</span>
    }
}</code></pre>
